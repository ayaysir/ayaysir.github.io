<!doctype html>














<!-- `site.alt_lang` can specify a language different from the UI -->
<html lang="ko" >
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta
    name="viewport"
    content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover"
  ><!-- Setup Open Graph image -->

  

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Swift: Combine 기본 기능 81가지 한 번에 요약 정리" />
<meta property="og:locale" content="ko" />
<meta name="description" content="출처: https://icksw.tistory.com/category/iOS/Combine 주의: 아래 포스트는 ChatGPT를 이용하여 요약하였으므로 틀린 내용이 있을 수 있습니다." />
<meta property="og:description" content="출처: https://icksw.tistory.com/category/iOS/Combine 주의: 아래 포스트는 ChatGPT를 이용하여 요약하였으므로 틀린 내용이 있을 수 있습니다." />
<link rel="canonical" href="https://ayaysir.github.io/posts/swift-combine-%EA%B8%B0%EB%B3%B8-%EA%B8%B0%EB%8A%A5-%EC%9A%94%EC%95%BD-%EC%A0%95%EB%A6%AC-1-3/" />
<meta property="og:url" content="https://ayaysir.github.io/posts/swift-combine-%EA%B8%B0%EB%B3%B8-%EA%B8%B0%EB%8A%A5-%EC%9A%94%EC%95%BD-%EC%A0%95%EB%A6%AC-1-3/" />
<meta property="og:site_name" content="BGSMM" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-09-02T00:00:00+09:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Swift: Combine 기본 기능 81가지 한 번에 요약 정리" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-09-02T00:00:00+09:00","datePublished":"2024-09-02T00:00:00+09:00","description":"출처: https://icksw.tistory.com/category/iOS/Combine 주의: 아래 포스트는 ChatGPT를 이용하여 요약하였으므로 틀린 내용이 있을 수 있습니다.","headline":"Swift: Combine 기본 기능 81가지 한 번에 요약 정리","mainEntityOfPage":{"@type":"WebPage","@id":"https://ayaysir.github.io/posts/swift-combine-%EA%B8%B0%EB%B3%B8-%EA%B8%B0%EB%8A%A5-%EC%9A%94%EC%95%BD-%EC%A0%95%EB%A6%AC-1-3/"},"url":"https://ayaysir.github.io/posts/swift-combine-%EA%B8%B0%EB%B3%B8-%EA%B8%B0%EB%8A%A5-%EC%9A%94%EC%95%BD-%EC%A0%95%EB%A6%AC-1-3/"}</script>
<!-- End Jekyll SEO tag -->


  <title>Swift: Combine 기본 기능 81가지 한 번에 요약 정리 | BGSMM
  </title>

  <!--
  The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps
  Generated by: https://realfavicongenerator.net/
-->



<link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png">

  <link rel="manifest" href="/assets/img/favicons/site.webmanifest">

<link rel="shortcut icon" href="/assets/img/favicons/favicon.ico">
<meta name="apple-mobile-web-app-title" content="BGSMM">
<meta name="application-name" content="BGSMM">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml">
<meta name="theme-color" content="#ffffff">


  <!-- Resource Hints -->
  
    
      
        <link rel="preconnect" href="https://fonts.googleapis.com" >
      
        <link rel="dns-prefetch" href="https://fonts.googleapis.com" >
      
    
      
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      
        <link rel="dns-prefetch" href="https://fonts.gstatic.com" >
      
    
      
        <link rel="preconnect" href="https://cdn.jsdelivr.net" >
      
        <link rel="dns-prefetch" href="https://cdn.jsdelivr.net" >
      
    
  

  <!-- Bootstrap -->
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.6/dist/css/bootstrap.min.css">
  

  <!-- Theme style -->
  <link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css">

  <!-- Web Font -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap">

  <!-- Font Awesome Icons -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.1/css/all.min.css">

  <!-- 3rd-party Dependencies -->

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.32.2/dist/tocbot.min.css">
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css">
  

  
    <!-- Image Popup -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css">
  

  <!-- Scripts -->

  <script src="/assets/js/dist/theme.min.js"></script>

  <!-- JS selector for site. -->

<!-- commons -->



<!-- layout specified -->


  

  
    <!-- image lazy-loading & popup & clipboard -->
    
  















  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  



  <script defer src="https://cdn.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.13/dayjs.min.js,npm/dayjs@1.11.13/locale/en.js,npm/dayjs@1.11.13/plugin/relativeTime.js,npm/dayjs@1.11.13/plugin/localizedFormat.js,npm/tocbot@4.32.2/dist/tocbot.min.js"></script>







<script defer src="/assets/js/dist/post.min.js"></script>



<!-- Pageviews -->

  

  



  

  <!-- A placeholder to allow defining custom metadata -->

</head>

  <body>
    <!-- The Side Bar -->

<aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end">
  <header class="profile-wrapper">
    <a href="/" id="avatar" class="rounded-circle"><img src="/./assets/img/favicons/mstile-150x150.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a>

    <a class="site-title d-block" href="/">BGSMM</a>
    <p class="site-subtitle fst-italic mb-0">음악, 레트로테크 좋아함</p>
  </header>
  <!-- .profile-wrapper -->

  <nav class="flex-column flex-grow-1 w-100 ps-0">
    <ul class="nav">
      <!-- home -->
      <li class="nav-item">
        <a href="/" class="nav-link">
          <i class="fa-fw fas fa-home"></i>
          <span>HOME</span>
        </a>
      </li>
      <!-- the real tabs -->
      
        <li class="nav-item">
          <a href="/categories/" class="nav-link">
            <i class="fa-fw fas fa-stream"></i>
            

            <span>CATEGORIES</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/tags/" class="nav-link">
            <i class="fa-fw fas fa-tags"></i>
            

            <span>TAGS</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/archives/" class="nav-link">
            <i class="fa-fw fas fa-archive"></i>
            

            <span>ARCHIVES</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/about/" class="nav-link">
            <i class="fa-fw fas fa-info-circle"></i>
            

            <span>ABOUT</span>
          </a>
        </li>
        <!-- .nav-item -->
      
    </ul>
  </nav>

  <div class="sidebar-bottom d-flex flex-wrap  align-items-center w-100">
    
      <button type="button" class="btn btn-link nav-link" aria-label="Switch Mode" id="mode-toggle">
        <i class="fas fa-adjust"></i>
      </button>

      
        <span class="icon-border"></span>
      
    

    

      
        <a
          href="https://github.com/ayaysir"
          aria-label="github"
          

          
            target="_blank"
            
          

          

          
            rel="noopener noreferrer"
          
        >
          <i class="fab fa-github"></i>
        </a>
      
    

      
        <a
          href="javascript:location.href = 'mailto:' + ['yoonbumtae','gmail.com'].join('@')"
          aria-label="email"
          

          

          

          
        >
          <i class="fas fa-envelope"></i>
        </a>
      
    
          
        

      
        <a
          href="/feed.xml"
          aria-label="rss"
          

          

          

          
        >
          <i class="fas fa-rss"></i>
        </a>
      
    
  </div>
  <!-- .sidebar-bottom -->
</aside>
<!-- #sidebar -->


    <div id="main-wrapper" class="d-flex justify-content-center">
      <div class="container d-flex flex-column px-xxl-5">
        <!-- The Top Bar -->

<header id="topbar-wrapper" class="flex-shrink-0" aria-label="Top Bar">
  <div
    id="topbar"
    class="d-flex align-items-center justify-content-between px-lg-3 h-100"
  >
    <nav id="breadcrumb" aria-label="Breadcrumb">
      

      
        
          
            <span>
              <a href="/">Home</a>
            </span>

          
        
          
        
          
            
              <span>Swift: Combine 기본 기능 81가지 한 번에 요약 정리</span>
            

          
        
      
    </nav>
    <!-- endof #breadcrumb -->

    <button type="button" id="sidebar-trigger" class="btn btn-link" aria-label="Sidebar">
      <i class="fas fa-bars fa-fw"></i>
    </button>

    <div id="topbar-title">
      Post
    </div>

    <button type="button" id="search-trigger" class="btn btn-link" aria-label="Search">
      <i class="fas fa-search fa-fw"></i>
    </button>

    <search id="search" class="align-items-center ms-3 ms-lg-0">
      <i class="fas fa-search fa-fw"></i>
      <input
        class="form-control"
        id="search-input"
        type="search"
        aria-label="search"
        autocomplete="off"
        placeholder="Search..."
      >
    </search>
    <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button>
  </div>
</header>


        <div class="row flex-grow-1">
          <main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4">
            
              <!-- Refactor the HTML structure -->



<!--
  In order to allow a wide table to scroll horizontally,
  we suround the markdown table with `<div class="table-wrapper">` and `</div>`
-->



<!--
  Fixed kramdown code highlight rendering:
  https://github.com/penibelst/jekyll-compress-html/issues/101
  https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901
-->



<!-- Change the icon of checkbox -->



<!-- Handle images -->




  
  

  
    
      
      
    

    
    

    

    
    

    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    

    
    

    

    
      
    

    <!-- lazy-load images -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        

        
        
      
    

    <!-- combine -->
    
  
    

    
    

    

    
    

    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    

    
    

    

    
      
    

    <!-- lazy-load images -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        

        
        
      
    

    <!-- combine -->
    
  

  


<!-- Add header for code snippets -->



<!-- Create heading anchors -->





  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    

    
  

  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    

    
  

  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    

    
  

  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    

    
  




<!-- return -->










<article class="px-1" data-toc="true">
  <header>
    <h1 data-toc-skip>Swift: Combine 기본 기능 81가지 한 번에 요약 정리</h1>
    

    <div class="post-meta text-muted">
      <!-- published date -->
      <span>
        Posted
        <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1725202800"
  data-df="ll"
  
    data-bs-toggle="tooltip" data-bs-placement="bottom"
  
>
  Sep  2, 2024
</time>

      </span>

      <!-- lastmod date -->
      

      

      <div class="d-flex justify-content-between">
        <!-- author(s) -->
        <span>
          

          By

          <em>
            
              <a href="https://github.com/ayaysir">ayaysir</a>
            
          </em>
        </span>

        <div>
          <!-- pageviews -->
          

          <!-- read time -->
          <!-- Calculate the post's reading time, and display the word count in tooltip -->



<!-- words per minute -->










<!-- return element -->
<span
  class="readtime"
  data-bs-toggle="tooltip"
  data-bs-placement="bottom"
  title="22087 words"
>
  <em>122 min</em> read</span>

        </div>
      </div>
    </div>
  </header>

  
    <div id="toc-bar" class="d-flex align-items-center justify-content-between invisible">
      <span class="label text-truncate">Swift: Combine 기본 기능 81가지 한 번에 요약 정리</span>
      <button type="button" class="toc-trigger btn me-1">
        <i class="fa-solid fa-list-ul fa-fw"></i>
      </button>
    </div>

    <button id="toc-solo-trigger" type="button" class="toc-trigger btn btn-outline-secondary btn-sm">
      <span class="label ps-2 pe-1">Contents</span>
      <i class="fa-solid fa-angle-right fa-fw"></i>
    </button>

    <dialog id="toc-popup" class="p-0">
      <div class="header d-flex flex-row align-items-center justify-content-between">
        <div class="label text-truncate py-2 ms-4">Swift: Combine 기본 기능 81가지 한 번에 요약 정리</div>
        <button id="toc-popup-close" type="button" class="btn mx-1 my-1 opacity-75">
          <i class="fas fa-close"></i>
        </button>
      </div>
      <div id="toc-popup-content" class="px-4 py-3 pb-4"></div>
    </dialog>
  

  <div class="content">
    <ul>
  <li><strong>출처:</strong> <a href="https://icksw.tistory.com/category/iOS/Combine">https://icksw.tistory.com/category/iOS/Combine</a></li>
  <li><strong>주의:</strong> 아래 포스트는 ChatGPT를 이용하여 요약하였으므로 틀린 내용이 있을 수 있습니다.</li>
</ul>

<p> </p>

<h3 id="1-combine-프레임워크를-사용하여-커스텀-publisher-생성"><span class="me-2"><strong>1. Combine 프레임워크를 사용하여 커스텀 Publisher 생성</strong></span><a href="#1-combine-프레임워크를-사용하여-커스텀-publisher-생성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td class="rouge-code"><pre>class HandsUp: Publisher {
    typealias Output = String
    // Never: The return type of functions that do not return normally, that is, a type with no values.
    typealias Failure = Never
    
    /*
     S: 제네릭 타입
     where:
      - S: Subscriber 타입을 준수
      - Never == S.Failure이어야 함
      - String == S.Input이어야 함
     
     */
    func receive&lt;S&gt;(subscriber: S) where S : Subscriber, Never == S.Failure, String == S.Input {
        DispatchQueue.global(qos: .utility).async {
            let pandas: [String] = ["LeBao", "AiBao", "FuBao"]
            pandas.forEach {
                // receive: Tells the subscriber that the publisher has produced an element.
                _ = subscriber.receive($0)
            }
            
            // Tells the subscriber that the publisher has completed publishing, either normally or with an error.
            subscriber.receive(completion: .finished)
        }
    }
    
}

let handsUpPublisher = HandsUp()

_ = handsUpPublisher.sink(receiveCompletion: { _ in
    print("completed")
}, receiveValue: { panda in
    print("Panda:", panda)
})

/*
 Panda: LeBao
 Panda: AiBao
 Panda: FuBao
 completed
 */
</pre></td></tr></tbody></table></code></div></div>

<p><strong>설명:</strong></p>

<ul>
  <li>위 코드는 Combine 프레임워크의 기본적인 기능인 Publisher를 커스텀하게 생성하는 예제입니다.</li>
  <li><code class="language-plaintext highlighter-rouge">HandsUp</code> 클래스는 <code class="language-plaintext highlighter-rouge">Publisher</code> 프로토콜을 준수하며, <code class="language-plaintext highlighter-rouge">Output</code> 타입은 <code class="language-plaintext highlighter-rouge">String</code>이고, <code class="language-plaintext highlighter-rouge">Failure</code> 타입은 <code class="language-plaintext highlighter-rouge">Never</code>입니다.</li>
  <li><code class="language-plaintext highlighter-rouge">receive(subscriber:)</code> 메서드는 <code class="language-plaintext highlighter-rouge">Subscriber</code>를 받아, 비동기적으로 데이터를 발행하고 완료 상태를 전달합니다.</li>
  <li>비동기적으로 “LeBao”, “AiBao”, “FuBao” 문자열을 전달하고, 발행이 완료되었음을 알립니다.</li>
</ul>

<p> </p>

<h2 id="combine에서-제공하는-publisher"><span class="me-2"><strong>Combine에서 제공하는 Publisher</strong></span><a href="#combine에서-제공하는-publisher" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="2-future-단일-이벤트와-종료-혹은-실패를-제공하는-publisher"><span class="me-2"><strong>2. Future: 단일 이벤트와 종료 혹은 실패를 제공하는 publisher</strong></span><a href="#2-future-단일-이벤트와-종료-혹은-실패를-제공하는-publisher" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="rouge-code"><pre>// 1
let future = Future&lt;String, Error&gt; { promise in
    promise(.success("Future: Success"))
}

_ = future.sink(receiveCompletion: { result in
    print("Future Result:", result)
}, receiveValue: { receiveValue in
    print("receiveValue:", receiveValue)
})

/*
 receiveValue: Future: Success
 Future Result: finished
 */

// 2
let futureWithError = Future&lt;String, Error&gt; { promise in
    promise(.failure(NSError(domain: "Future Error", code: -1)))
}

_ = futureWithError.sink(receiveCompletion: { result in
    print("FutureWithError Result:", result)
}, receiveValue: { receiveValue in
    print("receiveValue:", receiveValue)
})

/*
 FutureWithError Result: failure(Error Domain=Future Error Code=-1 "(null)")
 */

// 3
let futureWithNever = Future&lt;String, Never&gt; { promise in
    promise(.success("FutureWithNever: Never"))
}
_ = futureWithNever.sink {
    print($0)
}

/*
 FutureWithNever: Never
 */

</pre></td></tr></tbody></table></code></div></div>

<h5 id="설명"><span class="me-2"><strong>설명:</strong></span><a href="#설명" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5>

<ul>
  <li><strong>Future</strong>는 Combine의 Publisher 중 하나로, 단일 이벤트와 종료 또는 실패를 제공합니다. 이 Publisher는 단일 값을 emit하고 종료하거나, 오류가 발생하면 실패를 emit합니다.</li>
  <li>첫 번째 예제에서는 <code class="language-plaintext highlighter-rouge">Future</code>가 성공적인 결과를 emit하고, <code class="language-plaintext highlighter-rouge">Future: Success</code>라는 메시지가 출력됩니다.</li>
  <li>두 번째 예제에서는 오류를 발생시키는 <code class="language-plaintext highlighter-rouge">Future</code>를 보여줍니다. 오류가 발생하면 <code class="language-plaintext highlighter-rouge">FutureWithError Result: failure(Error Domain=Future Error Code=-1 "(null)")</code>가 출력됩니다.</li>
  <li>세 번째 예제는 <code class="language-plaintext highlighter-rouge">Future&lt;String, Never&gt;</code>를 사용하여 결과를 emit하지만 실패를 발생시키지 않는 경우를 보여줍니다. 여기서는 <code class="language-plaintext highlighter-rouge">FutureWithNever: Never</code>가 출력됩니다.</li>
</ul>

<p> </p>

<h3 id="3-just-단일-이벤트-발생-후-종료"><span class="me-2"><strong>3. Just: 단일 이벤트 발생 후 종료</strong></span><a href="#3-just-단일-이벤트-발생-후-종료" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre>let just = Just&lt;String&gt;("Monika")

_ = just.sink {
    print("JustResult:", $0)
} receiveValue: {
    print($0)
}

/*
 Monika
 JustResult: finished
 */

</pre></td></tr></tbody></table></code></div></div>

<h5 id="설명-1"><span class="me-2"><strong>설명:</strong></span><a href="#설명-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5>

<ul>
  <li><strong>Just</strong>는 Combine의 Publisher 중 하나로, 단일 값을 emit하고 종료합니다. <code class="language-plaintext highlighter-rouge">Just</code>는 하나의 이벤트를 방출한 후, 완료 상태로 종료됩니다.</li>
  <li>위의 예제에서는 <code class="language-plaintext highlighter-rouge">Just</code>가 <code class="language-plaintext highlighter-rouge">"Monika"</code>라는 값을 emit하고, 이 값이 출력됩니다. 이후 <code class="language-plaintext highlighter-rouge">JustResult: finished</code>라는 메시지가 출력됩니다.</li>
  <li>이 예제는 단일 값을 제공하고 완료 상태로 종료되는 <code class="language-plaintext highlighter-rouge">Just</code> Publisher의 동작을 보여줍니다.</li>
</ul>

<p> </p>

<h3 id="4-deferred-구독이-이뤄질-때-publisher가-만들어질-수-있도록-하는-publisher"><span class="me-2"><strong>4. Deferred: 구독이 이뤄질 때 publisher가 만들어질 수 있도록 하는 publisher</strong></span><a href="#4-deferred-구독이-이뤄질-때-publisher가-만들어질-수-있도록-하는-publisher" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="rouge-code"><pre>class PutYourHandsUp: Publisher {
    typealias Output = String
    typealias Failure = Never
    
    init() {
        Date().timeIntervalSince1970
    }
    
    func receive&lt;S&gt;(subscriber: S) where S : Subscriber, Failure == S.Failure, Output == S.Input {
        DispatchQueue.global(qos: .utility).async {
            let pandas: [String] = ["LeBao", "AiBao", "FuBao"]
            pandas.forEach {
                _ = subscriber.receive($0)
            }
            
            subscriber.receive(completion: .finished)
        }
    }
}

let deferredPYHUPublisher = Deferred&lt;PutYourHandsUp&gt; {
    PutYourHandsUp()
}
print("Deferred Publisher Init: \(Date().timeIntervalSince1970)")
_ = deferredPYHUPublisher.sink(receiveValue: {
    print("Panda:", $0)
})

/*
 Deferred Publisher Init: 1692027749.778286
 (Publisher Init: 1692027749.778328)
 Panda: LeBao
 Panda: AiBao
 Panda: FuBao
 */

</pre></td></tr></tbody></table></code></div></div>

<h5 id="설명-2"><span class="me-2"><strong>설명:</strong></span><a href="#설명-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5>

<ul>
  <li><strong>Deferred</strong>는 Combine의 Publisher를 구독할 때마다 새로 생성할 수 있도록 합니다. 이렇게 하면 Publisher가 실제로 생성되고 초기화되는 시점을 구독 시점으로 지연시킬 수 있습니다.</li>
  <li>위의 예제에서는 <code class="language-plaintext highlighter-rouge">PutYourHandsUp</code>라는 커스텀 Publisher를 사용하여, 구독이 이루어질 때까지 Publisher가 생성되지 않도록 합니다.</li>
  <li>코드에서는 <code class="language-plaintext highlighter-rouge">Deferred</code>를 사용하여 <code class="language-plaintext highlighter-rouge">PutYourHandsUp</code>의 인스턴스를 지연 생성합니다. <code class="language-plaintext highlighter-rouge">Deferred Publisher Init</code> 출력 후에 <code class="language-plaintext highlighter-rouge">PutYourHandsUp</code> 인스턴스가 생성되고 초기화 시점이 기록됩니다.</li>
  <li>구독 시에는 “LeBao”, “AiBao”, “FuBao”라는 문자열이 차례로 출력되며, 이는 <code class="language-plaintext highlighter-rouge">PutYourHandsUp</code> Publisher가 비동기적으로 값을 emit하고 완료 상태로 종료되기 때문입니다.</li>
</ul>

<p> </p>

<h3 id="5-empty-이벤트-없이-종료"><span class="me-2"><strong>5. Empty: 이벤트 없이 종료</strong></span><a href="#5-empty-이벤트-없이-종료" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre>let empty = Empty&lt;String, Never&gt;()
_ = empty.sink(receiveCompletion: { result in
    print("Empty: receiveCompletion:", result)
}, receiveValue: { value in
    print("Empty: receiveValue:", value)
})

/*
 Empty: receiveCompletion: finished
 */

</pre></td></tr></tbody></table></code></div></div>

<h5 id="설명-3"><span class="me-2"><strong>설명:</strong></span><a href="#설명-3" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5>

<ul>
  <li><strong>Empty</strong>는 Combine의 Publisher 중 하나로, 아무런 값을 emit하지 않고 즉시 완료 상태로 종료됩니다. 이 Publisher는 값이 필요 없는 경우나, 단순히 종료 상태를 전달하고자 할 때 유용합니다.</li>
  <li>위의 예제에서는 <code class="language-plaintext highlighter-rouge">Empty</code> Publisher를 사용하여 어떤 값도 emit하지 않고, 완료 상태만을 전달합니다. <code class="language-plaintext highlighter-rouge">receiveCompletion</code>의 출력에서 <code class="language-plaintext highlighter-rouge">finished</code>가 나타나며, <code class="language-plaintext highlighter-rouge">receiveValue</code>의 출력은 없습니다.</li>
  <li>이 예제는 <code class="language-plaintext highlighter-rouge">Empty</code> Publisher가 아무런 값을 방출하지 않고, 단순히 완료 상태로 종료되는 동작을 보여줍니다.</li>
</ul>

<p> </p>

<h3 id="6-fail-오류와-함께-종료"><span class="me-2"><strong>6. Fail: 오류와 함께 종료</strong></span><a href="#6-fail-오류와-함께-종료" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre>let failed = Fail&lt;String, Error&gt;(error: NSError(domain: "Failed", code: -1))
_ = failed.sink(receiveCompletion: { result in
    print("Fail: receiveCompletion:", result)
}, receiveValue: { value in
    print("Fail: receiveValue:", value)
})

/*
 Fail: receiveCompletion: failure(Error Domain=Failed Code=-1 "(null)")
 */

</pre></td></tr></tbody></table></code></div></div>

<h5 id="설명-4"><span class="me-2"><strong>설명:</strong></span><a href="#설명-4" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5>

<ul>
  <li><strong>Fail</strong>은 Combine의 Publisher 중 하나로, 즉시 오류를 발생시키고 종료됩니다. 이 Publisher는 값이 필요 없고, 실패 상태만을 전달해야 할 때 사용됩니다.</li>
  <li>위의 예제에서는 <code class="language-plaintext highlighter-rouge">Fail</code> Publisher를 사용하여 오류를 방출합니다. 이 오류는 <code class="language-plaintext highlighter-rouge">NSError</code>로 정의되며, 오류 도메인은 “Failed”, 코드 값은 <code class="language-plaintext highlighter-rouge">-1</code>입니다.</li>
  <li>코드는 <code class="language-plaintext highlighter-rouge">Fail</code> Publisher가 오류와 함께 종료되는 동작을 보여줍니다. <code class="language-plaintext highlighter-rouge">receiveCompletion</code>에서 오류 정보가 포함된 실패 상태가 출력되며, <code class="language-plaintext highlighter-rouge">receiveValue</code>는 호출되지 않습니다.</li>
</ul>

<p> </p>

<h3 id="7-record-입력과-완료를-기록해-다른-subscriber에서-반복될-수-있는-publisher"><span class="me-2"><strong>7. Record: 입력과 완료를 기록해 다른 subscriber에서 반복될 수 있는 publisher</strong></span><a href="#7-record-입력과-완료를-기록해-다른-subscriber에서-반복될-수-있는-publisher" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre>let record = Record&lt;String, Error&gt; { recording in
    print("===== Make Record ===== ")
    recording.receive("LeBao")
    recording.receive("AiBao")
    recording.receive("FuBao")
    recording.receive(completion: .failure(NSError(domain: "ㅠ", code: -1)))
}

for _ in 1...3 {
    _ = record.sink {
        print($0)
    } receiveValue: {
        print($0, terminator: "\t")
    }
}

/*
 ===== Make Record =====
 LeBao    AiBao    FuBao    failure(Error Domain=ㅠ Code=-1 "(null)")
 LeBao    AiBao    FuBao    failure(Error Domain=ㅠ Code=-1 "(null)")
 LeBao    AiBao    FuBao    failure(Error Domain=ㅠ Code=-1 "(null)")
 */

</pre></td></tr></tbody></table></code></div></div>

<h5 id="설명-5"><span class="me-2"><strong>설명:</strong></span><a href="#설명-5" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5>

<ul>
  <li><strong>Record</strong>는 Combine의 Publisher로, 이벤트와 완료 상태를 기록하여 여러 구독자에게 반복적으로 제공할 수 있습니다. 이 Publisher는 입력된 모든 값을 기록하여 이후의 구독자들이 동일한 값을 받을 수 있도록 합니다.</li>
  <li>위의 예제에서는 <code class="language-plaintext highlighter-rouge">Record</code>를 사용하여 문자열 값을 방출하고, 완료 상태로 오류를 발생시킵니다. 기록된 값과 완료 상태는 여러 번의 구독 시 반복해서 제공됩니다.</li>
  <li>코드는 <code class="language-plaintext highlighter-rouge">record</code> Publisher가 3번 반복하여 같은 기록된 값을 방출하는 것을 보여줍니다. 각각의 구독자에게 동일한 이벤트 시퀀스가 전달됩니다.</li>
</ul>

<p> </p>

<h3 id="8-anypublisher-유형-추상화를-위한-publisher"><span class="me-2"><strong>8. AnyPublisher: 유형 추상화를 위한 Publisher</strong></span><a href="#8-anypublisher-유형-추상화를-위한-publisher" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre>let originalPublisher = [1, nil, 3].publisher
let anyPublisher = originalPublisher.eraseToAnyPublisher()
/*
 이 게시자의 실제 유형이 아닌 다운스트림 구독자에게 AnyPublisher의 인스턴스를 노출하려면 eraseToAnyPublisher()를 사용하십시오. 이러한 유형 삭제 형식은 다른 모듈과 같은 API 경계 전체에서 추상화를 유지합니다. 게시자를 AnyPublisher 유형으로 노출하면 시간이 지남에 따라 기존 클라이언트에 영향을 주지 않고 기본 구현을 변경할 수 있습니다.
 */
anyPublisher.sink { receivedValue in
    print("AnyPublisher:", receivedValue as Any)
}

</pre></td></tr></tbody></table></code></div></div>

<p><a href="/assets/img/wp-content/uploads/2024/09/스크린샷-2024-09-02-오후-5.44.59.jpg" class="popup img-link shimmer"><img src="/assets/img/wp-content/uploads/2024/09/스크린샷-2024-09-02-오후-5.44.59.jpg" alt="" loading="lazy"></a></p>

<h5 id="설명-6"><span class="me-2"><strong>설명:</strong></span><a href="#설명-6" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5>

<ul>
  <li><strong>AnyPublisher</strong>는 Combine의 Publisher의 타입을 추상화하여 다양한 모듈 간의 API 경계에서 일관성을 유지할 수 있게 합니다. <code class="language-plaintext highlighter-rouge">eraseToAnyPublisher()</code> 메서드는 특정 Publisher의 실제 유형을 숨기고, 이를 <code class="language-plaintext highlighter-rouge">AnyPublisher</code>로 변환하여 추상화된 형태로 제공합니다.</li>
  <li>위의 예제에서는 배열 <code class="language-plaintext highlighter-rouge">[1, nil, 3]</code>을 Publisher로 변환한 후, <code class="language-plaintext highlighter-rouge">eraseToAnyPublisher()</code>를 사용하여 <code class="language-plaintext highlighter-rouge">AnyPublisher</code>로 변환합니다. 이를 통해 Publisher의 실제 타입을 숨기고 <code class="language-plaintext highlighter-rouge">AnyPublisher</code> 타입으로 추상화된 Publisher를 제공합니다.</li>
  <li>코드의 마지막 부분에서 <code class="language-plaintext highlighter-rouge">AnyPublisher</code>의 값을 구독하고 출력합니다. 이 방식은 내부 구현에 대한 정보를 숨기면서 외부에 일관된 인터페이스를 제공할 수 있습니다.</li>
</ul>

<p> </p>

<hr />

<h3 id="9-demand-custom-subscriber-intsubscriber-구현"><span class="me-2"><strong>9. Demand Custom Subscriber: IntSubscriber 구현</strong></span><a href="#9-demand-custom-subscriber-intsubscriber-구현" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="rouge-code"><pre>class IntSubscriber: Subscriber {
    
    typealias Input = Int
    typealias Failure = Never
    
    //
    func receive(subscription: Subscription) {
        subscription.request(.max(1))
    }
    
    // Demand: 요구 횟수
    func receive(_ input: Int) -&gt; Subscribers.Demand {
        print("Received Value:", input)
        // .max(n): Creates a demand for the given maximum number of elements.
        // The publisher is free to send fewer than the requested maximum number of elements.
        return .max(1)
        
        /*
         .max(1): Publisher에게 한 번 더 달라고 요청
         .none: Publisher에게 값 더이상 안줘도 된다고 알림
         .unlimited: Publisher에게 끝없이 값을 달라고 요청
         */
    }
    
    func receive(completion: Subscribers.Completion) {
        print("Received completion: \(completion)")
    }
}

let intArray: [Int] = [1, 2, 3, 4, 5]
let intSubscriber = IntSubscriber()

intArray.publisher.subscribe(intSubscriber)

// Combine을 사용할 때 주의할 점은 Publisher의 &lt;Output, Failure&gt; 타입과 Subscriber의 &lt;Input, Failure&gt; 타입이 동일해야 한다는 것!입니다. 이게 다르면 Publisher와 Subscriber는 서로 값을 주고받지 못합니다.

</pre></td></tr></tbody></table></code></div></div>

<p><a href="/assets/img/wp-content/uploads/2024/09/스크린샷-2024-09-02-오후-5.44.50.jpg" class="popup img-link shimmer"><img src="/assets/img/wp-content/uploads/2024/09/스크린샷-2024-09-02-오후-5.44.50.jpg" alt="" loading="lazy"></a></p>

<h5 id="설명-7"><span class="me-2"><strong>설명:</strong></span><a href="#설명-7" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5>

<ul>
  <li><strong>IntSubscriber</strong>는 Combine의 <code class="language-plaintext highlighter-rouge">Subscriber</code> 프로토콜을 구현한 사용자 정의 구독자입니다. 이 구독자는 <code class="language-plaintext highlighter-rouge">Int</code> 타입의 값을 수신하고, <code class="language-plaintext highlighter-rouge">Never</code> 타입의 실패를 허용합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">receive(subscription:)</code> 메서드는 구독 요청을 수행하며, 최대 한 개의 요소를 요청합니다. <code class="language-plaintext highlighter-rouge">request(.max(1))</code>은 Publisher에게 한 번의 값을 더 요청하겠다는 의미입니다.</li>
  <li><code class="language-plaintext highlighter-rouge">receive(_ input:)</code> 메서드는 실제로 수신된 값을 처리합니다. 이 메서드는 <code class="language-plaintext highlighter-rouge">Subscribers.Demand</code>를 반환하여 Publisher에 대해 더 많은 값을 요청할 수 있습니다. 예제에서는 <code class="language-plaintext highlighter-rouge">.max(1)</code>을 반환하여 한 개의 추가 값을 요청합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">receive(completion:)</code> 메서드는 완료 상태를 처리합니다. 완료 상태는 <code class="language-plaintext highlighter-rouge">Never</code> 타입을 사용하여 오류가 발생하지 않음을 나타냅니다.</li>
  <li>마지막으로, <code class="language-plaintext highlighter-rouge">intArray.publisher.subscribe(intSubscriber)</code>를 통해 <code class="language-plaintext highlighter-rouge">IntSubscriber</code>를 <code class="language-plaintext highlighter-rouge">intArray</code> Publisher에 구독자로 추가합니다. 이 구독자는 배열의 각 값을 수신하고, 요청한 만큼의 값을 출력합니다.</li>
  <li>Combine을 사용할 때 주의할 점은 Publisher의 <code class="language-plaintext highlighter-rouge">&lt;Output, Failure&gt;</code> 타입과 Subscriber의 <code class="language-plaintext highlighter-rouge">&lt;Input, Failure&gt;</code> 타입이 동일해야 한다는 것입니다. 이 타입이 다르면 Publisher와 Subscriber는 서로 값을 주고받지 못합니다.</li>
</ul>

<p> </p>

<h3 id="10-anycancellable-구독-취소-및-이벤트-처리"><span class="me-2"><strong>10. AnyCancellable: 구독 취소 및 이벤트 처리</strong></span><a href="#10-anycancellable-구독-취소-및-이벤트-처리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre>let subject1 = PassthroughSubject&lt;Int, Never&gt;()
let anyCancellable1 = subject1
    .handleEvents(receiveCancel: {
        print("Subject 1 is cancelled.")
    })
    .sink { completion in
        print("received completion: \(completion)")
    } receiveValue: { value in
        print("received value: \(value)")
    }

subject1.send(1)
anyCancellable1.cancel()
subject1.send(2)

// sink는 Subscriber를 만들고 바로 request 하는 operator입니다.

</pre></td></tr></tbody></table></code></div></div>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>received value: 1
Subject 1 is cancelled.
</pre></td></tr></tbody></table></code></div></div>

<h5 id="설명-8"><span class="me-2"><strong>설명:</strong></span><a href="#설명-8" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5>

<ul>
  <li><strong>AnyCancellable</strong>는 Combine에서 구독을 취소할 수 있는 객체를 제공합니다. 구독을 취소하면 Publisher로부터 더 이상 값을 수신하지 않습니다.</li>
  <li>위의 예제에서는 <code class="language-plaintext highlighter-rouge">PassthroughSubject</code>를 생성하고, 이를 <code class="language-plaintext highlighter-rouge">handleEvents(receiveCancel:)</code>와 <code class="language-plaintext highlighter-rouge">sink</code>를 사용하여 구독합니다. <code class="language-plaintext highlighter-rouge">handleEvents(receiveCancel:)</code>는 구독이 취소될 때 특정 작업을 수행하도록 합니다. 여기서는 “Subject 1 is cancelled.”를 출력합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">sink</code>는 Subscriber를 생성하고 즉시 구독을 시작합니다. <code class="language-plaintext highlighter-rouge">sink</code>는 값을 수신하고 완료 상태를 처리하는 클로저를 제공합니다.</li>
  <li>예제에서는 <code class="language-plaintext highlighter-rouge">subject1.send(1)</code>을 통해 값을 발행한 후, <code class="language-plaintext highlighter-rouge">anyCancellable1.cancel()</code>을 호출하여 구독을 취소합니다. 이후 <code class="language-plaintext highlighter-rouge">subject1.send(2)</code>를 호출해도 취소된 구독자에게는 값이 전달되지 않습니다.</li>
  <li><code class="language-plaintext highlighter-rouge">sink</code>는 Subscriber를 생성하고 구독을 시작하며, 요청된 값만큼 Publisher가 값을 제공하도록 합니다. 이 과정에서 <code class="language-plaintext highlighter-rouge">AnyCancellable</code> 객체를 사용하여 구독을 취소할 수 있습니다.</li>
</ul>

<p> </p>

<h3 id="11-publisher와-subscriber의-상호작용-값과-완료-이벤트-전달"><span class="me-2"><strong>11. Publisher와 Subscriber의 상호작용: 값과 완료 이벤트 전달</strong></span><a href="#11-publisher와-subscriber의-상호작용-값과-완료-이벤트-전달" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="rouge-code"><pre>/*
 1. Publisher는 값이나 completion event를 Subscriber에게 전달합니다.
 2. Subscriber는 Subscription을 통해 Publisher에게 값을 요청합니다.
 3. Subscription은 Publisher와 Subscriber 사이를 연결합니다.
 4. Subscription은 cancel()을 통해 취소할 수 있으며 이때 호출될 클로저를 설정할 수 있습니다.
 */

let anyPublisher1 = [1, nil, 3].publisher
    .flatMap { value -&gt; AnyPublisher&lt;Int, Never&gt; in
        if let value {
            return Just(value).eraseToAnyPublisher()
        }
        
        return Empty().eraseToAnyPublisher()
    }.eraseToAnyPublisher()

anyPublisher1.sink {
    print("AnyPublisher completion: \($0)")
} receiveValue: {
    print("value: \($0 as Any)")
}

/*
 결과:
 value: 1
 value: 3
 AnyPublisher completion: finished
 */

</pre></td></tr></tbody></table></code></div></div>

<h5 id="설명-9"><span class="me-2"><strong>설명:</strong></span><a href="#설명-9" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5>

<ul>
  <li>이 예제는 Combine의 Publisher와 Subscriber 간의 상호작용을 설명합니다. Publisher는 값을 발행하거나 완료 이벤트를 전달하고, Subscriber는 이를 수신하고 처리합니다.</li>
  <li><strong>Publisher</strong>는 값이나 완료 이벤트를 Subscriber에게 전달합니다. 이 예제에서는 배열 [1, nil, 3]을 Publisher로 변환합니다.</li>
  <li><strong>Subscriber</strong>는 Subscription을 통해 Publisher에게 값을 요청합니다. 여기서는 <code class="language-plaintext highlighter-rouge">flatMap</code>을 사용하여 배열의 각 값을 <code class="language-plaintext highlighter-rouge">Just</code>로 변환하고, <code class="language-plaintext highlighter-rouge">Empty</code>를 사용하여 <code class="language-plaintext highlighter-rouge">nil</code> 값을 처리합니다.</li>
  <li><strong>Subscription</strong>은 Publisher와 Subscriber 사이의 연결을 관리하며, <code class="language-plaintext highlighter-rouge">cancel()</code> 메서드를 통해 구독을 취소할 수 있습니다.</li>
  <li><code class="language-plaintext highlighter-rouge">anyPublisher1</code>은 <code class="language-plaintext highlighter-rouge">flatMap</code>을 사용하여 각 값을 <code class="language-plaintext highlighter-rouge">Just</code>로 변환하고, <code class="language-plaintext highlighter-rouge">Empty</code>로 대체하여 값이 없을 때는 빈 Publisher를 반환합니다. 최종적으로 <code class="language-plaintext highlighter-rouge">eraseToAnyPublisher()</code>로 변환합니다.</li>
  <li>결과적으로, <code class="language-plaintext highlighter-rouge">AnyPublisher</code>는 값을 수신하여 출력하고, 완료 상태를 출력합니다. 값이 1과 3이 출력되며, 완료 이벤트는 <code class="language-plaintext highlighter-rouge">finished</code>로 표시됩니다.</li>
</ul>

<p> </p>

<hr />

<h2 id="subject들"><span class="me-2"><strong>Subject들</strong></span><a href="#subject들" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="12-currentvaluesubject-최신-값과-함께-구독"><span class="me-2"><strong>12. CurrentValueSubject: 최신 값과 함께 구독</strong></span><a href="#12-currentvaluesubject-최신-값과-함께-구독" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td class="rouge-code"><pre>let currentValueSubject = CurrentValueSubject&lt;String, Never&gt;("1")
currentValueSubject
    .sink { completion in
        print("1 번째 sink completion: \(completion)")
    } receiveValue: { value in
        print("1 번째 sink value: \(value)")
    }

currentValueSubject
    .sink { completion in
        print("2 번째 sink completion: \(completion)")
    } receiveValue: { value in
        print("2 번째 sink value: \(value)")
    }
    .cancel()

currentValueSubject
    .sink { completion in
        print("3 번째 sink completion: \(completion)")
    } receiveValue: { value in
        print("3 번째 sink value: \(value)")
    }

currentValueSubject.send("2")
currentValueSubject.send("3")
currentValueSubject.send(completion: .finished)

/*
 결과:
 1 번째 sink value: 1
 2 번째 sink value: 1
 3 번째 sink value: 1
 1 번째 sink value: 2
 3 번째 sink value: 2
 1 번째 sink value: 3
 3 번째 sink value: 3
 1 번째 sink completion: finished
 3 번째 sink completion: finished
 */

</pre></td></tr></tbody></table></code></div></div>

<h5 id="설명-10"><span class="me-2"><strong>설명:</strong></span><a href="#설명-10" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5>

<ul>
  <li><strong>CurrentValueSubject</strong>는 Combine에서 현재 값을 보유하고 있는 Publisher입니다. 구독자는 현재 값과 이후 발행되는 값 모두를 수신할 수 있습니다.</li>
  <li>위의 예제에서는 <code class="language-plaintext highlighter-rouge">CurrentValueSubject</code>를 사용하여 문자열 값을 보유하고 초기 값으로 “1”을 설정합니다.</li>
  <li>첫 번째 <code class="language-plaintext highlighter-rouge">sink</code>는 초기 값 “1”을 수신하고, 그 이후에 발행되는 값도 수신합니다.</li>
  <li>두 번째 <code class="language-plaintext highlighter-rouge">sink</code>는 첫 번째 구독과 동일한 초기 값 “1”을 수신하지만, <code class="language-plaintext highlighter-rouge">cancel()</code>을 호출하여 구독을 취소합니다. 이후 발행되는 값과 완료 상태는 이 구독자에게 전달되지 않습니다.</li>
  <li>세 번째 <code class="language-plaintext highlighter-rouge">sink</code>는 취소되지 않았으므로, 현재 값과 이후 발행되는 값 및 완료 상태를 모두 수신합니다.</li>
  <li>결과적으로, 각 구독자는 초기 값 “1”과 이후 발행된 값 “2” 및 “3”, 그리고 완료 상태를 출력합니다. 취소된 구독자는 값과 완료 상태를 수신하지 않습니다.</li>
</ul>

<p>[the_ad id=”3020”]</p>

<p> </p>

<h3 id="13-passthroughsubject-값을-전파하는-publisher"><span class="me-2"><strong>13. PassthroughSubject: 값을 전파하는 Publisher</strong></span><a href="#13-passthroughsubject-값을-전파하는-publisher" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="rouge-code"><pre>/*
 정의를 보니 "downstream의 subscriber들에게 값을 전파한다"라고 되어있네요.
 그리고 아까 알아본 CurrentValuSubject와 다르게 생성할 때 딱히 초기값이 필요하지 않다고 합니다.
 또한 최신 값을 저장하기 위한 공간도 필요 없죠.
 이름에서 느낄 수 있듯이 그냥 값을 스쳐 보내는 쿨한 녀석입니다.
 따라서 만약에 subscriber가 없거나 Demand가 0이라면 값을 보내더라도 아무 일도 발생하지 않게 됩니다.
 */

let passthroughSubject = PassthroughSubject&lt;String, Never&gt;()

passthroughSubject
    .sink {
        print("1 번째 Passthrough sink completion: \($0)")
    } receiveValue: {
        print("1 번째 Passthrough sink value: \($0)")
    }

passthroughSubject
    .sink {
        print("2 번째 Passthrough sink completion: \($0)")
    } receiveValue: {
        print("2 번째 Passthrough sink value: \($0)")
    }

passthroughSubject.send("ee")
passthroughSubject.send("ff")
passthroughSubject.send(completion: .finished)

/*
 결과:
 1 번째 Passthrough sink value: ee
 2 번째 Passthrough sink value: ee
 1 번째 Passthrough sink value: ff
 2 번째 Passthrough sink value: ff
 1 번째 Passthrough sink completion: finished
 2 번째 Passthrough sink completion: finished
 */

</pre></td></tr></tbody></table></code></div></div>

<h5 id="설명-11"><span class="me-2"><strong>설명:</strong></span><a href="#설명-11" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5>

<ul>
  <li><strong>PassthroughSubject</strong>는 값을 전파하는 Publisher로, 구독자가 값을 수신하기 전에 값을 전달할 수 있습니다. 초기값을 필요로 하지 않으며, 최신 값을 저장하지 않습니다.</li>
  <li>이 예제에서 <code class="language-plaintext highlighter-rouge">PassthroughSubject</code>를 사용하여 두 개의 <code class="language-plaintext highlighter-rouge">sink</code> 구독자를 생성합니다. 이 구독자들은 각각 <code class="language-plaintext highlighter-rouge">PassthroughSubject</code>가 발행하는 값을 수신하고, 완료 상태를 출력합니다.</li>
  <li>구독자는 두 개의 <code class="language-plaintext highlighter-rouge">sink</code>가 모두 같은 값을 수신합니다. <code class="language-plaintext highlighter-rouge">send</code> 메서드를 호출하여 “ee”와 “ff”를 발행하고, <code class="language-plaintext highlighter-rouge">completion: .finished</code>로 완료 상태를 발행합니다.</li>
  <li>결과적으로, 모든 구독자는 각각의 값을 “ee”와 “ff”를 출력하고, 완료 상태를 출력합니다. 구독자가 없거나 <code class="language-plaintext highlighter-rouge">Demand</code>가 0인 경우, 발행된 값은 전파되지 않습니다.</li>
</ul>

<p> </p>

<h3 id="14-assign-객체의-프로퍼티에-값을-할당하는-subscriber"><span class="me-2"><strong>14. Assign: 객체의 프로퍼티에 값을 할당하는 Subscriber</strong></span><a href="#14-assign-객체의-프로퍼티에-값을-할당하는-subscriber" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="rouge-code"><pre>class SampleObject {
    var intValue: Int {
        didSet {
            print("intValue Changed: \(intValue)")
        }
    }
    
    init(intValue: Int) {
        self.intValue = intValue
    }
    
    deinit {
        print("SampleObject deinit")
    }
}

let sampleObject = SampleObject(intValue: 5)
let assign = Subscribers.Assign&lt;SampleObject, Int&gt;(object: sampleObject, keyPath: \.intValue)
let intArrayPublisher = [6, 19, 34, 55, 390].publisher
intArrayPublisher.subscribe(assign)
print("Final IntValue:", sampleObject.intValue)
/*
 결과:
 intValue Changed: 6
 intValue Changed: 19
 intValue Changed: 34
 intValue Changed: 55
 intValue Changed: 390
 Final IntValue: 390
 */

</pre></td></tr></tbody></table></code></div></div>

<h5 id="설명-12"><span class="me-2"><strong>설명:</strong></span><a href="#설명-12" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5>

<ul>
  <li><strong>Assign</strong>는 Combine에서 제공하는 Subscriber로, Publisher가 발행하는 값을 특정 객체의 프로퍼티에 직접 할당합니다. 이를 통해 Publisher의 값을 객체의 프로퍼티에 쉽게 바인딩할 수 있습니다.</li>
  <li>예제에서는 <code class="language-plaintext highlighter-rouge">SampleObject</code>라는 클래스를 정의하고, <code class="language-plaintext highlighter-rouge">intValue</code> 프로퍼티의 값을 변경할 때마다 출력하도록 설정합니다. 객체가 메모리에서 해제될 때 “SampleObject deinit”을 출력합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">Subscribers.Assign</code>는 <code class="language-plaintext highlighter-rouge">SampleObject</code>의 <code class="language-plaintext highlighter-rouge">intValue</code> 프로퍼티를 업데이트하는 Subscriber로 사용됩니다. 배열의 Publisher에서 발행하는 값을 이 프로퍼티에 할당합니다.</li>
  <li>배열 <code class="language-plaintext highlighter-rouge">[6, 19, 34, 55, 390]</code>의 Publisher는 <code class="language-plaintext highlighter-rouge">Assign</code> Subscriber를 통해 각 값을 <code class="language-plaintext highlighter-rouge">intValue</code> 프로퍼티에 할당합니다. 프로퍼티의 값이 변경될 때마다 “intValue Changed”가 출력됩니다.</li>
  <li>최종적으로, 모든 발행된 값이 <code class="language-plaintext highlighter-rouge">intValue</code>에 할당되고, 마지막 값이 최종적으로 출력됩니다. 객체가 해제될 때 <code class="language-plaintext highlighter-rouge">deinit</code>이 호출됩니다.</li>
</ul>

<p> </p>

<h3 id="15-demand-subscriber의-요구-횟수-조절"><span class="me-2"><strong>15. Demand: Subscriber의 요구 횟수 조절</strong></span><a href="#15-demand-subscriber의-요구-횟수-조절" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre></td><td class="rouge-code"><pre>// Demand는 누적되는 값이다, 음수를 넣어서 감소시킬 수는 없다! 정도만 알면 사용할 때 큰 문제는 없겠어요.
class DemandTestSubscriber: Subscriber {
    typealias Input = Int
    typealias Failure = Never
    
    func receive(subscription: Subscription) {
        print("[DEMAND] subscribe 시작!")
        // 여기서 Demand를 설정해줄 수도 있어요!
        // 현재 요청횟수는 1
        subscription.request(.max(1))
    }
    
    func receive(_ input: Int) -&gt; Subscribers.Demand {
        print("[DEMAND] receive input: \(input)")
        
        // input 값이 333일때만 요청횟수를 1 증가
        if input == 333 {
            return .max(1)
        } else {
            return .none
        }
    }
    
    func receive(completion: Subscribers.Completion&lt;Never&gt;) {
        print("[DEMAND] receive completion: \(completion)")
    }
}

print("===== DEMAND =====")
[2, 333, 4, 5].publisher
    .print()
    .subscribe(DemandTestSubscriber())
print("==================")

/*
 결과
 (1) input값이 333일 때만 요청횟수를 1 증가
 ===== DEMAND =====
 receive subscription: ([2, 333, 4, 5])
 [DEMAND] subscribe 시작!
 request max: (1)
 receive value: (2)
 [DEMAND] receive input: 2
 ==================
 */

</pre></td></tr></tbody></table></code></div></div>

<h5 id="설명-13"><span class="me-2"><strong>설명:</strong></span><a href="#설명-13" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5>

<ul>
  <li><strong>Demand</strong>는 Combine의 Subscriber가 Publisher에게 얼마나 많은 값을 요청할 것인지를 조절하는 메커니즘입니다. <code class="language-plaintext highlighter-rouge">Subscribers.Demand</code>를 사용하여 요청할 최대 값의 수를 설정하거나, 추가 값을 요청하지 않도록 설정할 수 있습니다.</li>
  <li>예제에서는 <code class="language-plaintext highlighter-rouge">DemandTestSubscriber</code>가 <code class="language-plaintext highlighter-rouge">Subscription</code>을 수신하고, 초기 요청 횟수를 1로 설정합니다. 이후에는 값이 333일 때만 추가로 요청 횟수를 1 증가시키고, 그 외의 값은 요청하지 않습니다.</li>
  <li>출력 결과는 값이 2일 때는 요청이 없으므로, 값 333이 수신될 때만 추가 요청이 발생합니다. 이로 인해 최종적으로 요청된 값만 수신됩니다.</li>
</ul>

<p> </p>

<h3 id="16-demand-무제한-요청-설정"><span class="me-2"><strong>16. Demand: 무제한 요청 설정</strong></span><a href="#16-demand-무제한-요청-설정" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="rouge-code"><pre>class DemandTestSubscriber2: Subscriber {
    typealias Input = Int
    typealias Failure = Never
    
    func receive(subscription: Subscription) {
        print("[DEMAND] subscribe 시작!")
        // 여기서 Demand를 설정해줄 수도 있어요!
        // 현재 요청횟수는 무제한
        subscription.request(.unlimited)
    }
    
    func receive(_ input: Int) -&gt; Subscribers.Demand {
        // 요청된 무제한 값이 있으므로, receive 메소드에서는 .none을 반환하더라도 계속 값을 수신함
        return .none
    }
    
    func receive(completion: Subscribers.Completion&lt;Never&gt;) {
        print("[DEMAND] receive completion: \(completion)")
    }
}

print("===== DEMAND2 =====")
[2, 333, 4, 5].publisher
    .print()
    .subscribe(DemandTestSubscriber2())
print("==================")

/*
 결과:
 (2) unlimited
 ===== DEMAND2 =====
 receive subscription: ([2, 333, 4, 5])
 [DEMAND] subscribe 시작!
 request unlimited
 receive value: (2)
 receive value: (333)
 receive value: (4)
 receive value: (5)
 receive finished
 [DEMAND] receive completion: finished
 ==================
 */

</pre></td></tr></tbody></table></code></div></div>

<h5 id="설명-14"><span class="me-2"><strong>설명:</strong></span><a href="#설명-14" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5>

<ul>
  <li><strong>Demand</strong>는 Combine의 Subscriber가 Publisher에게 요청하는 값의 수를 조절하는 메커니즘입니다. <code class="language-plaintext highlighter-rouge">Subscribers.Demand</code>를 사용하여 요청할 최대 값의 수를 설정할 수 있으며, 무제한으로 요청할 수도 있습니다.</li>
  <li>예제에서는 <code class="language-plaintext highlighter-rouge">DemandTestSubscriber2</code>가 <code class="language-plaintext highlighter-rouge">Subscription</code>을 수신하고, 무제한으로 값을 요청합니다. <code class="language-plaintext highlighter-rouge">subscription.request(.unlimited)</code>를 호출하여 무제한으로 요청을 설정합니다.</li>
  <li>무제한으로 요청을 설정했으므로, 이후 <code class="language-plaintext highlighter-rouge">receive(_ input: Int)</code> 메소드에서 <code class="language-plaintext highlighter-rouge">.none</code>을 반환하더라도 Publisher에서 발행된 모든 값이 수신됩니다. 이로 인해 Publisher에서 발행된 값들이 모두 수신되며, 완료 이벤트가 전달됩니다.</li>
</ul>

<p> </p>

<h3 id="17-completion-커스텀-오류와-완성-상태-처리"><span class="me-2"><strong>17. Completion: 커스텀 오류와 완성 상태 처리</strong></span><a href="#17-completion-커스텀-오류와-완성-상태-처리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre></td><td class="rouge-code"><pre>// custom Error를 만듭니다.
enum PinguError: Error {
    case pinguIsBaboo
    case elementIsNil
}

class PinguSubscriber: Subscriber {
    typealias Input = Int
    typealias Failure = PinguError
    
    func receive(subscription: Subscription) {
        subscription.request(.unlimited)
    }
    
    func receive(_ input: Int) -&gt; Subscribers.Demand {
        print("receive input: \(input)")
        return .none
    }
    
    func receive(completion: Subscribers.Completion&lt;PinguError&gt;) {
        // .pinguIsBaboo 수신시 실행
        if completion == .failure(.pinguIsBaboo) {
            print("Pingu는 바보입니다.")
        } else {
            print("finished!")
        }
    }
}

let pinguSubject = PassthroughSubject&lt;Int, PinguError&gt;()
let pinguSubscriber = PinguSubscriber()

pinguSubject.subscribe(pinguSubscriber)
pinguSubject.send(100)
pinguSubject.send(completion: .failure(.pinguIsBaboo))
pinguSubject.send(200)

// AnySubscriber
let pinguAnySubscriber = AnySubscriber(pinguSubscriber)
let anySubject1 = PassthroughSubject&lt;Int, PinguError&gt;()
anySubject1.subscribe(pinguAnySubscriber)
anySubject1.send(130300)
anySubject1.send(completion: .failure(.pinguIsBaboo))

/*
 결과:
 receive input: 100
 Pingu는 바보입니다.
 receive input: 130300
 Pingu는 바보입니다.
 */

</pre></td></tr></tbody></table></code></div></div>

<h5 id="설명-15"><span class="me-2"><strong>설명:</strong></span><a href="#설명-15" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5>

<ul>
  <li><strong>Completion</strong> 이벤트는 Publisher가 이벤트 스트림을 완료하거나 실패를 알릴 때 발생합니다. 이 예제에서는 커스텀 오류 <code class="language-plaintext highlighter-rouge">PinguError</code>를 정의하여 Subscriber가 이를 처리하도록 설정합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">PinguSubscriber</code> 클래스는 <code class="language-plaintext highlighter-rouge">Subscriber</code> 프로토콜을 채택하고, <code class="language-plaintext highlighter-rouge">receive(completion:)</code> 메소드에서 커스텀 오류를 확인하여 적절한 메시지를 출력합니다. 만약 오류가 <code class="language-plaintext highlighter-rouge">.pinguIsBaboo</code>인 경우, “Pingu는 바보입니다.”라는 메시지를 출력합니다.</li>
  <li>두 개의 <code class="language-plaintext highlighter-rouge">PassthroughSubject</code> 인스턴스가 생성되고, 각각 <code class="language-plaintext highlighter-rouge">PinguSubscriber</code>와 <code class="language-plaintext highlighter-rouge">AnySubscriber</code>에 연결됩니다. 두 번째 <code class="language-plaintext highlighter-rouge">PassthroughSubject</code>는 <code class="language-plaintext highlighter-rouge">AnySubscriber</code>를 사용하여 이전 Subscriber와 동일한 동작을 수행합니다.</li>
  <li>각 <code class="language-plaintext highlighter-rouge">PassthroughSubject</code>는 값을 전송하고, 커스텀 오류를 발생시킵니다. 결과적으로, 각 Subscriber는 오류가 발생할 때 “Pingu는 바보입니다.”라는 메시지를 출력합니다.</li>
</ul>

<p> </p>

<hr />

<p> </p>

<h3 id="18-클래스로-정의되어야-하는-custom-subscription"><span class="me-2"><strong>18. 클래스로 정의되어야 하는 Custom Subscription</strong></span><a href="#18-클래스로-정의되어야-하는-custom-subscription" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
</pre></td><td class="rouge-code"><pre>/*
 Subscription에는 특정 Subscriber가 Publisher를 subscribe 할 때 정의되는 ID가 있어서 Class로만 정의해야 한다고 합니다. 또한 Subscription을 cancel 하는 작업은 스레드로부터 안전해야 한다고 하며 cancel은 한 번만 할 수 있다고 해요. Subscription을 cancel 하면 Subscriber를 연결해서 할당된 모든 리소스도 해제된다고 합니다.
 */

struct YoutubeSubscriber {
    let name: String
    let age: Int
}

final class PandaSubscription&lt;S: Subscriber&gt;: Subscription where S.Input == YoutubeSubscriber {
    var requested: Subscribers.Demand = .none
    var youtubeSubscribers: [YoutubeSubscriber]
    var subscriber: S?
    
    init(subscriber: S, youtubeSubscribers: [YoutubeSubscriber]) {
        print("PandaSubscription 생성")
        self.subscriber = subscriber
        self.youtubeSubscribers = youtubeSubscribers
    }
    
    func request(_ demand: Subscribers.Demand) {
        print("요청받은 demand : \(demand)")
        for youtubeSubscriber in youtubeSubscribers {
            subscriber?.receive(youtubeSubscriber)
        }
    }
    
    func cancel() {
        print("PandaSubscription이 cancel됨!")
        youtubeSubscribers.removeAll()
        subscriber = nil
    }
}

extension Publishers {
    struct PandaPublisher: Publisher {
        typealias Output = YoutubeSubscriber
        typealias Failure = Never
        
        var youtubeSubscribers: [YoutubeSubscriber]
        
        func receive&lt;S&gt;(subscriber: S) where S : Subscriber, Failure == S.Failure, Output == S.Input {
            let subscription = PandaSubscription(subscriber: subscriber, youtubeSubscribers: youtubeSubscribers)
            subscriber.receive(subscription: subscription)
        }
        
        mutating func append(subscriber: YoutubeSubscriber) {
            youtubeSubscribers.append(subscriber)
        }
    }
    
    static func panda(youtubeSubscribers: [YoutubeSubscriber]) -&gt; Publishers.PandaPublisher {
        return Publishers.PandaPublisher(youtubeSubscribers: youtubeSubscribers)
    }
}

print("======= PandaSubscription =======")
var pandaSubscriptions = Set&lt;AnyCancellable&gt;()
var youtubeSubscribers = [
    YoutubeSubscriber(name: "FuBao", age: 3),
    YoutubeSubscriber(name: "AiBao", age: 10),
    YoutubeSubscriber(name: "LeBao", age: 11),
]

let pandaPublisher = Publishers.panda(youtubeSubscribers: youtubeSubscribers)
pandaPublisher
    .sink {
        print("PandaPublisher:", $0)
    } receiveValue: {
        print("PandaPublisher: name: \($0.name), age: \($0.age)")
    }
    .store(in: &amp;pandaSubscriptions)

pandaSubscriptions.forEach {
    $0.cancel()
}
print("=================================")

/*
 결과:
 ======= PandaSubscription =======
 PandaSubscription 생성
 요청받은 demand : unlimited
 PandaPublisher: name: FuBao, age: 3
 PandaPublisher: name: AiBao, age: 10
 PandaPublisher: name: LeBao, age: 11
 PandaSubscription이 cancel됨!
 =================================
 */

</pre></td></tr></tbody></table></code></div></div>

<h5 id="설명-16"><span class="me-2"><strong>설명:</strong></span><a href="#설명-16" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5>

<ul>
  <li><code class="language-plaintext highlighter-rouge">PandaSubscription</code> 클래스는 커스텀 <code class="language-plaintext highlighter-rouge">Subscription</code>을 정의합니다. 이 클래스는 특정 <code class="language-plaintext highlighter-rouge">Subscriber</code>와 <code class="language-plaintext highlighter-rouge">YoutubeSubscriber</code>의 배열을 사용하여 데이터를 전송하고, <code class="language-plaintext highlighter-rouge">request(_:)</code> 메소드를 통해 데이터를 요청합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">PandaPublisher</code>는 커스텀 <code class="language-plaintext highlighter-rouge">Publisher</code>로, <code class="language-plaintext highlighter-rouge">receive(subscriber:)</code> 메소드를 통해 <code class="language-plaintext highlighter-rouge">PandaSubscription</code>을 생성하고 <code class="language-plaintext highlighter-rouge">Subscriber</code>에 전달합니다.</li>
  <li>이 예제에서는 <code class="language-plaintext highlighter-rouge">YoutubeSubscriber</code>의 배열을 사용하여 <code class="language-plaintext highlighter-rouge">PandaPublisher</code>를 생성하고, <code class="language-plaintext highlighter-rouge">sink(receiveValue:)</code> 를 통해 데이터를 수신합니다. 그 후, <code class="language-plaintext highlighter-rouge">cancel()</code> 메소드를 호출하여 <code class="language-plaintext highlighter-rouge">Subscription</code>을 취소합니다.</li>
  <li>결과적으로, <code class="language-plaintext highlighter-rouge">PandaSubscription</code>이 생성되었고, 데이터가 수신된 후 <code class="language-plaintext highlighter-rouge">Subscription</code>이 취소되었음을 확인할 수 있습니다.</li>
</ul>

<p> </p>

<h2 id="operator들"><span class="me-2"><strong>Operator들</strong></span><a href="#operator들" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="19-publisher의-map-연산자-사용"><span class="me-2"><strong>19. Publisher의 map 연산자 사용</strong></span><a href="#19-publisher의-map-연산자-사용" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>let intPublisher = [1, 2, 3, 4, 5, 6, 7].publisher
intPublisher
    .map { element in
        return element * 2
    }
    .sink(receiveValue: { print($0, terminator: " ") })
// 결과: 2 4 6 8 10 12 14

</pre></td></tr></tbody></table></code></div></div>

<h5 id="설명-17"><span class="me-2"><strong>설명:</strong></span><a href="#설명-17" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5>

<ul>
  <li>이 코드는 <code class="language-plaintext highlighter-rouge">Publisher</code>의 <code class="language-plaintext highlighter-rouge">map</code> 연산자를 사용하여 입력된 배열의 각 요소를 두 배로 변환합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">[1, 2, 3, 4, 5, 6, 7].publisher</code>는 배열을 <code class="language-plaintext highlighter-rouge">Publisher</code>로 변환합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">map</code> 연산자는 배열의 각 요소를 2배로 증가시킵니다. 즉, <code class="language-plaintext highlighter-rouge">1</code>은 <code class="language-plaintext highlighter-rouge">2</code>, <code class="language-plaintext highlighter-rouge">2</code>는 <code class="language-plaintext highlighter-rouge">4</code>, <code class="language-plaintext highlighter-rouge">3</code>은 <code class="language-plaintext highlighter-rouge">6</code>으로 변환됩니다.</li>
  <li><code class="language-plaintext highlighter-rouge">sink(receiveValue:)</code>는 최종 결과를 출력하며, 결과는 <code class="language-plaintext highlighter-rouge">2 4 6 8 10 12 14</code>입니다.</li>
</ul>

<p> </p>

<h3 id="20-keypath를-이용한-매핑"><span class="me-2"><strong>20. KeyPath를 이용한 매핑</strong></span><a href="#20-keypath를-이용한-매핑" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre>struct Point {
    let x: Int
    let y: Int
    let z: Int
}

let pointPublisher = PassthroughSubject&lt;Point, Never&gt;()

pointPublisher
    // KeyPath를 이용한 매핑: x, y, z를 다음 sink 등에 보냄
    // 최대 3개
    .map(\.x, \.y, \.z)
    .sink { x, y, z in
        print("x: \(x), y: \(y), z: \(z)")
    }

pointPublisher.send(Point(x: 344, y: 483, z: 932))
// 결과: x: 344, y: 483, z: 932

</pre></td></tr></tbody></table></code></div></div>

<h5 id="설명-18"><span class="me-2"><strong>설명:</strong></span><a href="#설명-18" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5>

<ul>
  <li>이 코드는 <code class="language-plaintext highlighter-rouge">PassthroughSubject</code>를 사용하여 <code class="language-plaintext highlighter-rouge">Point</code> 구조체를 전달하는 <code class="language-plaintext highlighter-rouge">Publisher</code>를 생성합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">map</code> 연산자를 이용해 <code class="language-plaintext highlighter-rouge">KeyPath</code>를 사용하여 <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">y</code>, <code class="language-plaintext highlighter-rouge">z</code> 프로퍼티를 추출합니다.</li>
  <li>각 프로퍼티는 <code class="language-plaintext highlighter-rouge">sink</code> 연산자에서 개별적으로 전달되어 출력됩니다.</li>
  <li>결과적으로, <code class="language-plaintext highlighter-rouge">pointPublisher.send(Point(x: 344, y: 483, z: 932))</code> 호출 시 <code class="language-plaintext highlighter-rouge">x: 344, y: 483, z: 932</code>가 출력됩니다.</li>
</ul>

<p> </p>

<h3 id="21-trymap"><span class="me-2"><strong>21. TryMap</strong></span><a href="#21-trymap" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="rouge-code"><pre>func checkNil(_ element: Int?) throws -&gt; Int {
    guard let element else {
        throw PinguError.elementIsNil
    }
    
    return element
}

let tryMapPublisher = [1, 2, nil, 4].publisher

let tryMapSink: ((Subscribers.Completion) -&gt; Void) = {
    switch $0 {
    case .failure(let error):
        print("TryMapPublisher sink:", error)
    case .finished:
        print("TryMapPublisher sink: THE END")
    }
}
print("===========")

tryMapPublisher
    .tryMap {
        try checkNil($0)
    }
    .sink(receiveCompletion: tryMapSink) {
        print("TryMapPublisher receiveValue:", $0)
    }
/* 결과:
TryMapPublisher receiveValue: 1
TryMapPublisher receiveValue: 2
TryMapPublisher sink: elementIsNil
*/

</pre></td></tr></tbody></table></code></div></div>

<h5 id="설명-19"><span class="me-2"><strong>설명:</strong></span><a href="#설명-19" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5>

<ul>
  <li><code class="language-plaintext highlighter-rouge">checkNil</code> 함수는 옵셔널 <code class="language-plaintext highlighter-rouge">Int</code> 값을 받아, 값이 없으면 <code class="language-plaintext highlighter-rouge">PinguError.elementIsNil</code> 오류를 던집니다.</li>
  <li><code class="language-plaintext highlighter-rouge">tryMapPublisher</code>는 옵셔널 <code class="language-plaintext highlighter-rouge">Int</code> 값이 포함된 배열로부터 <code class="language-plaintext highlighter-rouge">Publisher</code>를 생성합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">tryMap</code> 연산자를 사용하여 각 요소를 <code class="language-plaintext highlighter-rouge">checkNil</code> 함수로 처리합니다. 만약 함수가 오류를 던지면 <code class="language-plaintext highlighter-rouge">completion</code> 클로저가 호출됩니다.</li>
  <li><code class="language-plaintext highlighter-rouge">sink</code> 연산자는 값을 수신할 때와 완료 시 동작을 정의합니다. 여기서는 오류 발생 시 오류를 출력하고, 완료 시 “THE END”를 출력합니다.</li>
  <li>결과적으로 <code class="language-plaintext highlighter-rouge">nil</code> 값이 오류를 발생시키고, 나머지 값들은 정상적으로 출력됩니다.</li>
</ul>

<p> </p>

<h3 id="22-maperror"><span class="me-2"><strong>22. MapError</strong></span><a href="#22-maperror" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre>enum PandaError: Error {
    case thisIsBlackBear
}

tryMapPublisher
    .tryMap {
        try checkNil($0)
    }
    .mapError {
        print("error detected:", $0)
        return PandaError.thisIsBlackBear
    }
    .sink(receiveCompletion: tryMapSink) {
        print("TryMapPublisher2 receiveValue:", $0)
    }
	
/* 결과:
TryMapPublisher2 receiveValue: 1
TryMapPublisher2 receiveValue: 2
error detected: elementIsNil
TryMapPublisher sink: thisIsBlackBear
*/

</pre></td></tr></tbody></table></code></div></div>

<h5 id="설명-20"><span class="me-2"><strong>설명:</strong></span><a href="#설명-20" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5>

<ul>
  <li><code class="language-plaintext highlighter-rouge">PandaError</code> 열거형은 사용자 정의 오류 타입으로, 하나의 오류 케이스 <code class="language-plaintext highlighter-rouge">thisIsBlackBear</code>를 정의합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">tryMapPublisher</code>는 이전 코드와 동일하게 옵셔널 값을 처리합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">mapError</code> 연산자는 오류가 발생했을 때, 기존 오류를 새로운 오류 타입으로 변환합니다. 여기서는 <code class="language-plaintext highlighter-rouge">PinguError</code> 대신 <code class="language-plaintext highlighter-rouge">PandaError.thisIsBlackBear</code>로 변환합니다.</li>
  <li>결과적으로 <code class="language-plaintext highlighter-rouge">nil</code> 값이 오류를 발생시키고, 변환된 <code class="language-plaintext highlighter-rouge">PandaError.thisIsBlackBear</code>가 출력됩니다. 정상 값들은 계속해서 출력됩니다.</li>
</ul>

<p> </p>

<h3 id="23-scan"><span class="me-2"><strong>23. Scan</strong></span><a href="#23-scan" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre>pandaPublisher
    .scan(0) { accumulatedResult, currentSubscriber in
        print("accumulatedResult: \(accumulatedResult), currentSubscriber: \(currentSubscriber)")
        return accumulatedResult + currentSubscriber.age
    }
    .sink(receiveValue: { print("AgeSum:", $0) })
	
/*
 결과:
 accumulatedResult: 0, currentSubscriber: YoutubeSubscriber(name: "FuBao", age: 3)
 AgeSum: 3
 accumulatedResult: 3, currentSubscriber: YoutubeSubscriber(name: "AiBao", age: 10)
 AgeSum: 13
 accumulatedResult: 13, currentSubscriber: YoutubeSubscriber(name: "LeBao", age: 11)
 AgeSum: 24
 */

</pre></td></tr></tbody></table></code></div></div>

<p><strong>설명:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">scan</code> 연산자는 스트림의 각 이벤트를 처리하며, 이전 값과 현재 값을 이용해 누적 결과를 계산합니다.</li>
  <li>위 코드에서는 <code class="language-plaintext highlighter-rouge">pandaPublisher</code>의 각 구독자의 나이(<code class="language-plaintext highlighter-rouge">currentSubscriber.age</code>)를 누적하여 총합을 계산합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">sink</code> 연산자를 통해 계산된 나이의 총합(<code class="language-plaintext highlighter-rouge">AgeSum</code>)을 출력합니다.</li>
</ul>

<p> </p>

<h3 id="24-tryscan"><span class="me-2"><strong>24. TryScan</strong></span><a href="#24-tryscan" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre>tryMapPublisher
    .tryScan(0) { accResult, currValue in
        try accResult + checkNil(currValue)
    }
    .sink(receiveCompletion: {
      print("[TryScan]", $0)
    }, receiveValue: {
      print("[TryScan]", $0)
    })

/*
 결과:
 [TryScan] 1
 [TryScan] 3
 [TryScan] failure(__lldb_expr_61.PinguError.elementIsNil)
 */

</pre></td></tr></tbody></table></code></div></div>

<p><strong>설명:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">tryScan</code> 연산자는 스트림의 각 이벤트를 처리하며, 이전 값과 현재 값을 이용해 누적 결과를 계산합니다. 이 과정에서 오류가 발생할 수 있습니다.</li>
  <li>위 코드에서는 <code class="language-plaintext highlighter-rouge">tryMapPublisher</code>의 각 값(<code class="language-plaintext highlighter-rouge">currValue</code>)을 <code class="language-plaintext highlighter-rouge">checkNil</code> 함수를 통해 검사하고, 누적 결과(<code class="language-plaintext highlighter-rouge">accResult</code>)와 더하여 총합을 계산합니다. 이 과정에서 오류가 발생할 수 있으므로 <code class="language-plaintext highlighter-rouge">try</code>를 사용합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">sink</code> 연산자를 통해 스트림의 결과를 출력하며, <code class="language-plaintext highlighter-rouge">receiveCompletion</code> 클로저를 통해 스트림의 완료 상태를, <code class="language-plaintext highlighter-rouge">receiveValue</code> 클로저를 통해 누적 결과를 출력합니다.</li>
  <li>결과는 아래와 같으며, <code class="language-plaintext highlighter-rouge">failure</code>는 오류 발생을 나타냅니다:
    <ul>
      <li>[TryScan] 1</li>
      <li>[TryScan] 3</li>
      <li>[TryScan] failure(__lldb_expr_61.PinguError.elementIsNil)</li>
    </ul>
  </li>
</ul>

<p>[the_ad id=”3020”]</p>

<p> </p>

<h3 id="25-setfailuretype"><span class="me-2"><strong>25. SetFailureType</strong></span><a href="#25-setfailuretype" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre>let stfPublisher = [1, 2, 3, 4].publisher
let pinguErrorPublisher = PassthroughSubject&lt;Int, PinguError&gt;()

stfPublisher
    .setFailureType(to: PinguError.self)
    .combineLatest(pinguErrorPublisher)
    .sink(receiveCompletion: {
      print("[SetFailureType]", $0)
    }, receiveValue: {
      print("[SetFailureType]", $0)
    })

pinguErrorPublisher.send(0)
/*
 결과:
 [SetFailureType] (4, 0)
 */

</pre></td></tr></tbody></table></code></div></div>

<p><strong>설명:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">setFailureType</code> 연산자는 Publisher의 실패 타입을 설정하는 데 사용됩니다. 이는 여러 Publisher를 조합할 때 Output과 Failure 타입이 일치해야 하는 경우 유용합니다.</li>
  <li>위 코드에서는 <code class="language-plaintext highlighter-rouge">stfPublisher</code>의 실패 타입을 <code class="language-plaintext highlighter-rouge">PinguError</code>로 설정한 후, <code class="language-plaintext highlighter-rouge">combineLatest</code> 연산자를 사용하여 <code class="language-plaintext highlighter-rouge">pinguErrorPublisher</code>와 결합합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">sink</code> 연산자를 통해 스트림의 결과를 출력합니다. <code class="language-plaintext highlighter-rouge">pinguErrorPublisher.send(0)</code> 호출 후, 결과로 (4, 0) 쌍이 출력됩니다.</li>
  <li>결과는 아래와 같습니다:
    <ul>
      <li>[SetFailureType] (4, 0)</li>
    </ul>
  </li>
</ul>

<p> </p>

<h3 id="26-filter-tryfilter"><span class="me-2"><strong>26. Filter, TryFilter</strong></span><a href="#26-filter-tryfilter" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre>[1, 2, 3, 4, 5, 6, 7].publisher
    .filter { $0 % 2 == 0 }
    .sink { _ in
        print()
    } receiveValue: {
        print($0, terminator: " ")
    }
// 결과: 2 4 6

</pre></td></tr></tbody></table></code></div></div>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="rouge-code"><pre>[2, 2, 4, 4, 5, 6].publisher
    .tryFilter { element in
        if element % 2 == 0 {
            return true
        } else {
            throw PinguError.elementIsNil
        }
    }
    .sink { completion in
        switch completion {
        case .failure(let error):
            print("TryFilter failure:", error)
        case .finished:
            print("TryFilter completed: All is even")
        }
    } receiveValue: { value in
        print("TryFilter receivedValue:", value)
    }

/*
 결과:
 TryFilter receivedValue: 2
 TryFilter receivedValue: 2
 TryFilter receivedValue: 4
 TryFilter receivedValue: 4
 TryFilter failure: elementIsNil
 */

</pre></td></tr></tbody></table></code></div></div>

<p><strong>설명:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">filter</code> 연산자는 Publisher의 출력 값을 필터링하여 조건에 맞는 값만 통과시킵니다. 위 코드에서는 짝수만 출력되도록 설정되어 있으며, 결과로 2, 4, 6이 출력됩니다.</li>
  <li><code class="language-plaintext highlighter-rouge">tryFilter</code> 연산자는 필터링 과정에서 오류를 처리할 수 있는 연산자입니다. 위 코드에서는 홀수를 만나면 <code class="language-plaintext highlighter-rouge">PinguError.elementIsNil</code> 오류를 발생시키고, 짝수는 통과시킵니다.</li>
  <li>결과는 아래와 같으며, 필터링 과정에서 오류가 발생하여 스트림이 실패하게 됩니다:
    <ul>
      <li>TryFilter receivedValue: 2</li>
      <li>TryFilter receivedValue: 2</li>
      <li>TryFilter receivedValue: 4</li>
      <li>TryFilter receivedValue: 4</li>
      <li>TryFilter failure: elementIsNil</li>
    </ul>
  </li>
</ul>

<p> </p>

<h3 id="27-compactmap-trycompactmap"><span class="me-2"><strong>27. CompactMap, TryCompactMap</strong></span><a href="#27-compactmap-trycompactmap" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>["100", "235456", "a.b", "4443", "eefef", "45678.5"].publisher
    .compactMap { Int($0) }
    .sink(receiveCompletion: { _ in print() }, receiveValue: { print($0, terminator: " ") })
// 결과: 100 235456 4443

</pre></td></tr></tbody></table></code></div></div>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre>["100", "235456", "a.b", "4443", "babo", "45678.5"].publisher
    .tryCompactMap {
        if $0 == "babo" {
            throw PinguError.pinguIsBaboo
        }
        
        return Int($0)
    }
    .sink(receiveCompletion: { completion in
        switch completion {
        case .finished:
            print("OK")
        case .failure(let error):
            print("TryCompactMap:", error)
        }
    }, receiveValue: { print($0, terminator: " ") })
// 결과: 100 235456 4443 TryCompactMap: pinguIsBaboo

</pre></td></tr></tbody></table></code></div></div>

<p><strong>설명:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">compactMap</code> 연산자는 Publisher의 값을 변환하고, 변환할 수 없는 값은 걸러냅니다. 위 코드에서는 문자열을 정수로 변환하고, 변환할 수 없는 값은 제외됩니다. 결과로 100, 235456, 4443이 출력됩니다.</li>
  <li><code class="language-plaintext highlighter-rouge">tryCompactMap</code> 연산자는 변환 과정에서 오류를 처리할 수 있습니다. 위 코드에서는 “babo”라는 값이 있을 경우 <code class="language-plaintext highlighter-rouge">PinguError.pinguIsBaboo</code> 오류를 발생시키고, 나머지 값들은 정수로 변환합니다.</li>
  <li>결과는 아래와 같으며, 오류가 발생할 경우 오류 메시지가 출력됩니다:
    <ul>
      <li>100</li>
      <li>235456</li>
      <li>4443</li>
      <li>TryCompactMap: pinguIsBaboo</li>
    </ul>
  </li>
</ul>

<p> </p>

<h3 id="28-removeduplicates-tryremoveduplicates"><span class="me-2"><strong>28. RemoveDuplicates, TryRemoveDuplicates</strong></span><a href="#28-removeduplicates-tryremoveduplicates" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="rouge-code"><pre>struct Name {
    let lastName: String
    let firstName: String

    func printName() {
        print(lastName + firstName)
    }
}

[
    Name(lastName: "Pin", firstName: "gu"),
    Name(lastName: "Pin", firstName: "ga"),
    Name(lastName: "Ro", firstName: "By"),
    Name(lastName: "Ro", firstName: "From"),
    Name(lastName: "Ro", firstName: "Yume"),
    Name(lastName: "O", firstName: "dung")
]
    .publisher
    .removeDuplicates { prev, curr in
        // true이면 중복이라고 판단
        prev.lastName == curr.lastName
    }
    .sink { $0.printName() }

/*
 결과:
 Pingu
 RoBy
 Odung
 */

</pre></td></tr></tbody></table></code></div></div>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre>[1, 2, 2, 3, 3]
    .publisher
    .tryRemoveDuplicates { prev, curr in
        if prev == curr {
            throw PinguError.pinguIsBaboo
        }
        
        return false
    }
    .sink { completion in
        switch completion {
        case .failure(let error):
            print("[TryRemoveDuplicates]", error)
        case .finished:
            print("중복값 없음")
        }
    } receiveValue: { value in
        print(value, terminator: " ")
    }
// 결과: 1 2 [TryRemoveDuplicates] pinguIsBaboo

</pre></td></tr></tbody></table></code></div></div>

<p><strong>설명:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">removeDuplicates</code> 연산자는 스트림에서 중복된 값을 제거합니다. 위 코드에서는 이전 값과 현재 값을 비교하여 <code class="language-plaintext highlighter-rouge">lastName</code>이 동일한 경우 중복으로 간주하고 제거합니다.</li>
  <li>결과적으로 중복된 <code class="language-plaintext highlighter-rouge">lastName</code>을 가진 이름은 첫 번째 항목만 남게 되어, “Pingu”, “RoBy”, “Odung”이 출력됩니다.</li>
  <li><code class="language-plaintext highlighter-rouge">tryRemoveDuplicates</code> 연산자는 중복 값을 발견할 때 오류를 발생시킬 수 있는 연산자입니다. 위 코드에서는 중복된 값이 있을 경우 <code class="language-plaintext highlighter-rouge">PinguError.pinguIsBaboo</code> 오류를 발생시키고, 중복되지 않은 값은 통과합니다.</li>
</ul>

<p> </p>

<h3 id="29-replaceempty"><span class="me-2"><strong>29. ReplaceEmpty</strong></span><a href="#29-replaceempty" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre>Empty&lt;[String], Never&gt;()
    .replaceEmpty(with: ["EE", "EE"])
    .sink { print("[ReplaceEmpty]", $0) }

[Int]().publisher
    .replaceEmpty(with: 5)
    .sink { print("[ReplaceEmpty]", $0) }

/*
 결과:
 [ReplaceEmpty] ["EE", "EE"]
 [ReplaceEmpty] 5
 */

</pre></td></tr></tbody></table></code></div></div>

<p><strong>설명:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">replaceEmpty</code> 연산자는 Publisher가 빈 값을 방출할 때, 대신 제공된 값을 방출하도록 합니다.</li>
  <li>첫 번째 예제에서는 빈 <code class="language-plaintext highlighter-rouge">Empty</code> Publisher가 <code class="language-plaintext highlighter-rouge">replaceEmpty</code> 연산자를 통해 [“EE”, “EE”]로 대체되어 출력됩니다.</li>
  <li>두 번째 예제에서는 빈 배열을 가진 Publisher가 <code class="language-plaintext highlighter-rouge">replaceEmpty</code> 연산자를 통해 5로 대체되어 출력됩니다.</li>
  <li>결과는 아래와 같습니다:
    <ul>
      <li>[ReplaceEmpty] [“EE”, “EE”]</li>
      <li>[ReplaceEmpty] 5</li>
    </ul>
  </li>
</ul>

<p> </p>

<h3 id="30-replaceerror"><span class="me-2"><strong>30. ReplaceError</strong></span><a href="#30-replaceerror" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="rouge-code"><pre>["1", "2", "a.b", "3"].publisher
    .tryCompactMap {
        if Int($0) != nil {
            return $0
        }
        
        throw PandaError.thisIsBlackBear
    }
    .replaceError(with: "FuBao")
    .sink { completion in
        switch completion {
        case .failure(let error):
            print(error.localizedDescription)
        case .finished:
            print("[ReplaceError] 로 인해 에러가 없어졌다.")
        }
    } receiveValue: { value in
        print("[ReplaceError]", value)
    }

/*
 결과:
 [ReplaceError] 1
 [ReplaceError] 2
 [ReplaceError] FuBao
 [ReplaceError] 로 인해 에러가 없어졌다.
 
 참고:
 replaceError는 하나의 Element를 보내고 스트림을 종료해서 에러를 처리하려는 경우에 유용하다고 하네요. catch라는 Operator를 사용해서 에러를 처리해주는 게 좋다고 합니다.
 */

</pre></td></tr></tbody></table></code></div></div>

<p><strong>설명:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">replaceError</code> 연산자는 스트림에서 오류가 발생했을 때 지정된 값을 대신 방출합니다. 위 코드에서는 <code class="language-plaintext highlighter-rouge">tryCompactMap</code> 연산자에서 발생하는 오류를 <code class="language-plaintext highlighter-rouge">"FuBao"</code>로 대체하여 출력합니다.</li>
  <li>첫 번째 예제에서는 오류가 발생하기 전에 <code class="language-plaintext highlighter-rouge">Int($0)</code>가 성공적으로 변환된 값들(“1”, “2”, “3”)이 출력되며, 오류는 “FuBao”로 대체됩니다.</li>
  <li><code class="language-plaintext highlighter-rouge">replaceError</code>는 스트림을 종료시키며, 스트림의 에러를 처리할 때 유용합니다. <code class="language-plaintext highlighter-rouge">catch</code> 연산자를 사용하는 것이 보다 일반적인 에러 처리 방법입니다.</li>
  <li>결과는 아래와 같습니다:
    <ul>
      <li>[ReplaceError] 1</li>
      <li>[ReplaceError] 2</li>
      <li>[ReplaceError] FuBao</li>
      <li>[ReplaceError] 로 인해 에러가 없어졌다.</li>
    </ul>
  </li>
</ul>

<p> </p>

<h3 id="31-catch"><span class="me-2"><strong>31. Catch</strong></span><a href="#31-catch" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="rouge-code"><pre>["1", "2", "a.b", "3"].publisher
    .tryCompactMap {
        if Int($0) != nil {
            return $0
        }
        
        throw PandaError.thisIsBlackBear
    }
    .catch { _ in
        Just("Monika")
    }
    .sink { completion in
        switch completion {
        case .failure(let error):
            print(error.localizedDescription)
        case .finished:
            print("[Catch] 로 인해 에러가 없어졌다.")
        }
    } receiveValue: { value in
        print("[Catch]", value)
    }
/*
 결과:
 [Catch] 1
 [Catch] 2
 [Catch] Monika
 [Catch] 로 인해 에러가 없어졌다.
 */

</pre></td></tr></tbody></table></code></div></div>

<p><strong>설명:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">catch</code> 연산자는 Publisher에서 오류가 발생했을 때, 해당 오류를 처리하고 대체 Publisher를 방출합니다. 위 코드에서는 <code class="language-plaintext highlighter-rouge">tryCompactMap</code> 연산자에서 발생하는 오류를 <code class="language-plaintext highlighter-rouge">Just("Monika")</code>로 대체합니다.</li>
  <li>코드에서는 문자열을 정수로 변환하고, 변환할 수 없는 경우 <code class="language-plaintext highlighter-rouge">PandaError.thisIsBlackBear</code> 오류를 발생시킵니다. 이후 <code class="language-plaintext highlighter-rouge">catch</code> 연산자가 호출되어 오류를 처리하고, 대신 <code class="language-plaintext highlighter-rouge">"Monika"</code>를 방출합니다.</li>
  <li>결과는 아래와 같으며, 오류 발생 후 대체 값이 방출되고 스트림이 정상적으로 종료됩니다:
    <ul>
      <li>[Catch] 1</li>
      <li>[Catch] 2</li>
      <li>[Catch] Monika</li>
      <li>[Catch] 로 인해 에러가 없어졌다.</li>
    </ul>
  </li>
</ul>

<p> </p>

<hr />

<h3 id="reducing-elements로-분류된-publisher"><span class="me-2">Reducing Elements로 분류된 Publisher</span><a href="#reducing-elements로-분류된-publisher" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<ul>
  <li>Collect</li>
  <li>CollectByCount</li>
  <li>CollectByTime</li>
  <li>IgnoreOutput</li>
  <li>Reduce</li>
  <li>TryReduce</li>
</ul>

<p> </p>

<h4 id="이를-활용한-operator"><span class="me-2"><strong>이를 활용한 Operator</strong></span><a href="#이를-활용한-operator" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<ul>
  <li>collect()</li>
  <li>collect(_:)</li>
  <li>collect(_:options:)</li>
  <li>TimeGroupingStrategy</li>
  <li>ignoreOutput()</li>
  <li>reduce(_:_:)</li>
  <li>tryReduce(_:_:)</li>
</ul>

<p> </p>

<h3 id="32-collect"><span class="me-2"><strong>32. Collect</strong></span><a href="#32-collect" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>[1, 2, 3, 4, 5].publisher
    .collect()
    .sink { print("[Collect]", $0) }

</pre></td></tr></tbody></table></code></div></div>

<p><strong>설명:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">collect</code> 연산자는 Upstream에서 받은 모든 값을 모아 하나의 배열로 만들어 Downstream으로 전달합니다. 위 코드에서는 숫자 <code class="language-plaintext highlighter-rouge">1, 2, 3, 4, 5</code>가 배열로 수집되어 한 번에 방출됩니다.</li>
  <li>결과는 다음과 같습니다:
    <ul>
      <li>[Collect] [1, 2, 3, 4, 5]</li>
    </ul>
  </li>
</ul>

<p> </p>

<h3 id="33-collectbycount"><span class="me-2"><strong>33. CollectByCount</strong></span><a href="#33-collectbycount" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>[1, 2, 3, 4, 5, 6, 7].publisher
    .collect(3)
    .sink { print("[CollectByCount]", $0) }
/*
 결과:
 [CollectByCount] [1, 2, 3]
 [CollectByCount] [4, 5, 6]
 [CollectByCount] [7]
 */

</pre></td></tr></tbody></table></code></div></div>

<p><strong>설명:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">collect(_ count: Int)</code> 연산자는 Upstream에서 받은 값을 지정된 개수만큼 모아서 하나의 배열로 만들어 Downstream으로 전달합니다. 위 코드에서는 3개의 값씩 수집하여 방출합니다.</li>
  <li>결과는 아래와 같습니다:
    <ul>
      <li>[CollectByCount] [1, 2, 3]</li>
      <li>[CollectByCount] [4, 5, 6]</li>
      <li>[CollectByCount] [7]</li>
    </ul>
  </li>
</ul>

<p> </p>

<h3 id="34-collectbytime"><span class="me-2"><strong>34. CollectByTime</strong></span><a href="#34-collectbytime" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre>var cbtSubscription = Set()
let timerPublisher = Timer.publish(every: 1, on: .main, in: .default)
timerPublisher
    .autoconnect()
    .collect(.byTime(DispatchQueue.main, .seconds(4)))
    .sink { print("[CollectByTime]", $0) }
    .store(in: &amp;cbtSubscription)
/*
 결과 출력: 출판을 1초마다 하고 콜렉트를 4초로 설정하면 1초 단위로 4개씩 모이고 방출
 [CollectByTime] [2023-08-18 05:58:05 +0000, 2023-08-18 05:58:06 +0000, 2023-08-18 05:58:07 +0000, 2023-08-18 05:58:08 +0000]
 [CollectByTime] [2023-08-18 05:58:09 +0000, 2023-08-18 05:58:10 +0000, 2023-08-18 05:58:11 +0000, 2023-08-18 05:58:12 +0000]
 [CollectByTime] [2023-08-18 05:58:13 +0000, 2023-08-18 05:58:14 +0000, 2023-08-18 05:58:15 +0000, 2023-08-18 05:58:16 +0000]
 [CollectByTime] [2023-08-18 05:58:17 +0000, 2023-08-18 05:58:18 +0000, 2023-08-18 05:58:19 +0000, 2023-08-18 05:58:20 +0000]
 ...
 */

</pre></td></tr></tbody></table></code></div></div>

<p><strong>설명:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">collect(.byTime(_:_:))</code> 연산자는 지정된 시간 간격 동안 Publisher가 방출하는 모든 요소를 수집하여, 지정된 간격이 끝나면 그 그룹을 방출합니다. 위 코드에서는 <code class="language-plaintext highlighter-rouge">Timer</code>가 1초마다 값을 방출하며, 4초마다 값을 그룹화하여 방출합니다.</li>
  <li>결과는 다음과 같으며, 4초마다 Timer가 방출한 값들이 배열로 수집되어 방출됩니다:
    <ul>
      <li>[CollectByTime] [2023-08-18 05:58:<strong>05</strong> +0000, 2023-08-18 05:58:<strong>06</strong> +0000, 2023-08-18 05:58:<strong>07</strong> +0000, 2023-08-18 05:58:<strong>08</strong> +0000]</li>
      <li>[CollectByTime] [2023-08-18 05:58:09 +0000, 2023-08-18 05:58:10 +0000, 2023-08-18 05:58:11 +0000, 2023-08-18 05:58:12 +0000]</li>
      <li>…</li>
    </ul>
  </li>
</ul>

<p> </p>

<h3 id="35-ignoreoutput"><span class="me-2"><strong>35. IgnoreOutput</strong></span><a href="#35-ignoreoutput" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre>[1, 2, 3, 4, 5].publisher
    .ignoreOutput()
    .sink(receiveCompletion: { print("[IgnoreOutput]", $0) },
          receiveValue: { print($0) })

[1, 2, 3, 4, 5].publisher
    .reduce(0, { $0 + $1 })
    .sink { print("[Reduce1]", $0) }
/*
 결과:
 [Reduce1] 15
 */

</pre></td></tr></tbody></table></code></div></div>

<p><strong>설명:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ignoreOutput</code> 연산자는 Upstream에서 방출된 모든 값을 무시하고, 오직 완료 이벤트만 Downstream으로 전달합니다. 따라서, <code class="language-plaintext highlighter-rouge">sink</code>의 <code class="language-plaintext highlighter-rouge">receiveValue</code> 클로저는 호출되지 않으며, <code class="language-plaintext highlighter-rouge">receiveCompletion</code>만 실행됩니다.</li>
  <li><code class="language-plaintext highlighter-rouge">reduce</code> 연산자는 초기값을 시작으로 Upstream에서 방출되는 모든 값을 누적하여 최종 값을 한번에 방출합니다. 위의 코드에서는 모든 값을 더한 <code class="language-plaintext highlighter-rouge">15</code>가 결과로 방출됩니다.</li>
</ul>

<p><strong>[참고]</strong></p>

<ul>
  <li>
    <p><strong>Scan과 Reduce 비교:</strong></p>

    <ul>
      <li>
        <ul>
          <li><code class="language-plaintext highlighter-rouge">scan</code>은 누적 결과를 매번 방출하는 반면, <code class="language-plaintext highlighter-rouge">reduce</code>는 모든 누적이 완료된 후에 최종 결과를 한번에 방출합니다.
            <ul>
              <li>예시 코드:</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>

    <div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre>  pandaPublisher
      .scan(0) { accumulatedResult, currentSubscriber in
          print("accumulatedResult: \(accumulatedResult), currentSubscriber: \(currentSubscriber)")
          return accumulatedResult + currentSubscriber.age
      }
      .sink(receiveValue: { print("AgeSum:", $0) })
  /*
   결과:
   accumulatedResult: 0, currentSubscriber: YoutubeSubscriber(name: "FuBao", age: 3)
   AgeSum: 3
   accumulatedResult: 3, currentSubscriber: YoutubeSubscriber(name: "AiBao", age: 10)
   AgeSum: 13
   accumulatedResult: 13, currentSubscriber: YoutubeSubscriber(name: "LeBao", age: 11)
   AgeSum: 24
   */
    
</pre></td></tr></tbody></table></code></div>    </div>
  </li>
</ul>

<p> </p>

<h3 id="36-tryreduce"><span class="me-2"><strong>36. TryReduce</strong></span><a href="#36-tryreduce" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre>[1, 2, 3, -10, 4].publisher
    .tryReduce(0) { reduceValue, newValue in
        if reduceValue + newValue &lt; 0 {
            throw PinguError.pinguIsBaboo
        }
        return reduceValue + newValue
    }
    .sink(receiveCompletion: { print("[TryReduce Comp]", $0) },
          receiveValue: { print("[TryReduce Val]", $0) })
/*
 결과:
 [TryReduce Comp] failure(__lldb_expr_69.PinguError.pinguIsBaboo)
 */

</pre></td></tr></tbody></table></code></div></div>

<p><strong>설명:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">tryReduce</code> 연산자는 <code class="language-plaintext highlighter-rouge">reduce</code>와 유사하게 작동하지만, 클로저 내부에서 오류를 발생시킬 수 있습니다. 특정 조건을 만족하지 못할 경우 오류를 발생시키고 스트림을 종료시킵니다.</li>
  <li>위의 예제에서는, 누적 값이 음수가 되면 <code class="language-plaintext highlighter-rouge">PinguError.pinguIsBaboo</code> 오류를 발생시킵니다. 오류가 발생한 경우, <code class="language-plaintext highlighter-rouge">receiveCompletion</code> 클로저에서 <code class="language-plaintext highlighter-rouge">failure</code>와 함께 오류 정보가 출력됩니다.</li>
</ul>

<p>[the_ad id=”3020”]</p>

<p> </p>

<hr />

<h3 id="요소에-수학적-연산-적용하기"><span class="me-2"><strong>요소에 수학적 연산 적용하기</strong></span><a href="#요소에-수학적-연산-적용하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Count</code></li>
  <li><code class="language-plaintext highlighter-rouge">Comparison</code></li>
  <li><code class="language-plaintext highlighter-rouge">TryComparison</code></li>
</ul>

<h4 id="연산자"><span class="me-2"><strong>연산자</strong></span><a href="#연산자" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">count()</code></li>
  <li><code class="language-plaintext highlighter-rouge">max()</code></li>
  <li><code class="language-plaintext highlighter-rouge">max(by:)</code></li>
  <li><code class="language-plaintext highlighter-rouge">tryMax(by:)</code></li>
  <li><code class="language-plaintext highlighter-rouge">min()</code></li>
  <li><code class="language-plaintext highlighter-rouge">min(by:)</code></li>
  <li><code class="language-plaintext highlighter-rouge">tryMin(by:)</code></li>
</ul>

<h3 id="37-count"><span class="me-2"><strong>37. Count</strong></span><a href="#37-count" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>[Int](repeating: 0, count: 123).publisher
    .count()
    .sink { print("[Count]", $0) }
/*
 결과:
 [Count] 123
 */

</pre></td></tr></tbody></table></code></div></div>

<p><strong>설명:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">count</code> 연산자는 Upstream에서 방출된 총 항목 수를 계산하고, 그 결과를 Downstream으로 한 번 방출합니다.</li>
  <li>위의 예제에서는 <code class="language-plaintext highlighter-rouge">[Int](repeating: 0, count: 123)</code> 배열을 퍼블리셔로 변환한 후, <code class="language-plaintext highlighter-rouge">count</code> 연산자를 사용하여 123개의 항목을 계산하고 <code class="language-plaintext highlighter-rouge">sink</code>에서 결과 <code class="language-plaintext highlighter-rouge">123</code>을 출력합니다.</li>
</ul>

<p> </p>

<h3 id="38-max"><span class="me-2"><strong>38. Max</strong></span><a href="#38-max" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="rouge-code"><pre>[5, 4, 107, 2, 1].publisher
    .max()
    .sink { print("[Max]", $0) }

protocol Ikimono {}

struct Person: Ikimono {
    let name: String
    let age: Int
}
struct Panda: Ikimono {
    let name: String
    let age: Int
}

[
    Person(name: "FuBao", age: 3),
    Person(name: "AiBao", age: 10),
    Person(name: "LeBao", age: 11),
].publisher
    .max { $0.age &lt; $1.age }
    .sink { print("[Max]", $0) }

([
    Panda(name: "FuBao", age: 3),
    Person(name: "AiBao", age: 10),
    Person(name: "LeBao", age: 11),
] as [Ikimono]).publisher
    .tryMax { first, second in
        if first is Panda {
            return true
        } else {
            throw PandaError.thisIsBlackBear
        }
    }
    .sink(receiveCompletion: { print("[TryMax]", $0) },
              receiveValue: { print("[TryMax]", $0) })
/*
 결과:
 [Max] 107
 [Max] Person(name: "LeBao", age: 11)
 [TryMax] failure(__lldb_expr_69.PandaError.thisIsBlackBear)
 */

</pre></td></tr></tbody></table></code></div></div>

<p><strong>설명:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">max</code> 연산자는 Upstream에서 방출된 값 중 가장 큰 값을 Downstream으로 방출합니다. 기본적으로 값들이 Comparable을 준수해야 합니다.</li>
  <li>첫 번째 예제에서는 정수 배열의 최대값 <code class="language-plaintext highlighter-rouge">107</code>을 출력합니다.</li>
  <li>두 번째 예제에서는 <code class="language-plaintext highlighter-rouge">Person</code> 객체 배열에서 <code class="language-plaintext highlighter-rouge">age</code> 속성이 가장 큰 <code class="language-plaintext highlighter-rouge">Person(name: "LeBao", age: 11)</code> 객체를 출력합니다.</li>
  <li>세 번째 예제에서는 <code class="language-plaintext highlighter-rouge">Ikimono</code> 프로토콜을 준수하는 객체 배열에서 <code class="language-plaintext highlighter-rouge">tryMax</code>를 사용하여 <code class="language-plaintext highlighter-rouge">Panda</code> 객체를 기준으로 최대값을 찾으려고 합니다. 그러나 <code class="language-plaintext highlighter-rouge">Person</code> 객체가 포함되어 있어 <code class="language-plaintext highlighter-rouge">PandaError.thisIsBlackBear</code> 오류가 발생합니다.</li>
</ul>

<p> </p>

<h3 id="39-min"><span class="me-2"><strong>39. Min</strong></span><a href="#39-min" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="rouge-code"><pre>[5, 4, 107, 2, 1].publisher
    .min()
    .sink { print("[Min]", $0) }

[
    Person(name: "FuBao", age: 3),
    Person(name: "AiBao", age: 10),
    Person(name: "LeBao", age: 11),
].publisher
    // 오름차순이라 가정할 때 true가 나와야 min을 찾을 수 있다.
    .min { $0.age &lt; $1.age }
    .sink { print("[Min]", $0) }

([
    Panda(name: "FuBao", age: 3),
    Person(name: "AiBao", age: 10),
    Person(name: "LeBao", age: 11),
] as [Ikimono]).publisher
    .tryMax { first, second in
        if first is Panda {
            return true
        } else {
            throw PandaError.thisIsBlackBear
        }
    }
    .sink(receiveCompletion: { print("[TryMin]", $0) },
              receiveValue: { print("[TryMin]", $0) })
/*
 결과:
 [Min] 1
 [Min] Person(name: "FuBao", age: 3)
 [TryMin] failure(__lldb_expr_69.PandaError.thisIsBlackBear)
 */

</pre></td></tr></tbody></table></code></div></div>

<p><strong>설명:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">min</code> 연산자는 Upstream에서 방출된 값 중 가장 작은 값을 Downstream으로 방출합니다. 기본적으로 값들이 Comparable을 준수해야 합니다.</li>
  <li>첫 번째 예제에서는 정수 배열의 최소값 <code class="language-plaintext highlighter-rouge">1</code>을 출력합니다.</li>
  <li>두 번째 예제에서는 <code class="language-plaintext highlighter-rouge">Person</code> 객체 배열에서 <code class="language-plaintext highlighter-rouge">age</code> 속성이 가장 작은 <code class="language-plaintext highlighter-rouge">Person(name: "FuBao", age: 3)</code> 객체를 출력합니다.</li>
  <li>세 번째 예제에서 <code class="language-plaintext highlighter-rouge">tryMax</code>를 사용하여 최대값을 찾는 예제가 잘못 포함되어 있습니다. <code class="language-plaintext highlighter-rouge">tryMin</code>으로 변경되어야 하며, 주석과 설명에 맞게 수정이 필요합니다. 현재는 <code class="language-plaintext highlighter-rouge">PandaError.thisIsBlackBear</code> 오류가 발생합니다.</li>
</ul>

<p> </p>

<hr />

<p> </p>

<h3 id="요소에-일치-기준matching-criteria-적용하기"><span class="me-2"><strong>요소에 일치 기준(Matching Criteria) 적용하기</strong></span><a href="#요소에-일치-기준matching-criteria-적용하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Contains</code></li>
  <li><code class="language-plaintext highlighter-rouge">ContainsWhere</code></li>
  <li><code class="language-plaintext highlighter-rouge">TryContainsWhere</code></li>
  <li><code class="language-plaintext highlighter-rouge">AllSatisfy</code></li>
  <li><code class="language-plaintext highlighter-rouge">TryAllSatisfy</code></li>
</ul>

<p> </p>

<h4 id="연산자-1"><span class="me-2"><strong>연산자</strong></span><a href="#연산자-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">contains(_:)</code></li>
  <li><code class="language-plaintext highlighter-rouge">contains(where:)</code></li>
  <li><code class="language-plaintext highlighter-rouge">tryContains(where:)</code></li>
  <li><code class="language-plaintext highlighter-rouge">allSatisfy(_:)</code></li>
  <li><code class="language-plaintext highlighter-rouge">tryAllSatisfy(_:)</code></li>
</ul>

<p> </p>

<h3 id="40-contains"><span class="me-2"><strong>40. Contains</strong></span><a href="#40-contains" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>[192, 199, 196, 100, 104].publisher
    .contains(196)
    .sink { print("[Contains]", $0) } // [Contains] true

[192, 199, 196, 100, 104].publisher
    .contains(-348)
    .sink { print("[Contains]", $0) } // [Contains] false

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">contains</code> 연산자는 Upstream에서 특정 값이 존재하는지 여부를 확인합니다.</li>
  <li>첫 번째 예제는 배열에 <code class="language-plaintext highlighter-rouge">196</code>이 포함되어 있는지 확인하며, 두 번째 예제는 <code class="language-plaintext highlighter-rouge">-348</code>이 포함되어 있는지 확인합니다.</li>
</ul>

<p> </p>

<h3 id="41-contains-where"><span class="me-2"><strong>41. Contains Where</strong></span><a href="#41-contains-where" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>["murmur", "twins", "another"].publisher
    .contains(where: { $0.count == 5 })
    .sink { print("[Contains]", $0) } // [Contains] true (-&gt; twins를 읽음)

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">contains(where:)</code> 연산자는 Upstream에서 주어진 조건을 만족하는 값이 존재하는지 확인합니다.</li>
  <li>예제에서는 문자열의 길이가 5인 값이 배열에 포함되어 있는지 확인합니다.</li>
</ul>

<p> </p>

<h3 id="42-trycontains"><span class="me-2"><strong>42. TryContains</strong></span><a href="#42-trycontains" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td class="rouge-code"><pre>// TryContainsWhere: 값 탐색 중 true가 나오면 이후 과정은 무시, 값 탐생 중 true가 나오지 않은 상태에서 에러 발생시 throw
[2, 4, 8, 12, -105, 3, 6, 8].publisher
    .tryContains {
        if $0 &gt;= 0 &amp;&amp; $0 % 2 == 0 {
            return true
        } else {
            throw PinguError.pinguIsBaboo
        }
    }
    .sink {
        print("[TryContains Comp 1]", $0)
    } receiveValue: {
        print("[TryContains Val 1]", $0)
    }
	
/*
결과:
[TryContains Val 1] true
[TryContains Comp 1] finished
*/

[2, 4, 8, 12, -105, 3, 6, 8].publisher
    .tryContains {
        if $0 &gt;= 0 &amp;&amp; $0 % 2 == 1 {
            return true
        } else {
            throw PinguError.pinguIsBaboo
        }
    }
    .sink {
        print("[TryContains Comp 2]", $0)
    } receiveValue: {
        print("[TryContains Val 2]", $0)
    }
	
/*
결과:
[TryContains Comp 2] failure(__lldb_expr_69.PinguError.pinguIsBaboo)
*/

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">tryContains</code> 연산자는 Upstream에서 주어진 조건을 만족하는 값이 있는지 확인하며, 값 탐색 중 조건에 맞지 않는 경우 에러를 발생시킬 수 있습니다.</li>
  <li>첫 번째 예제는 0 이상의 짝수인 값을 탐색하며, 두 번째 예제는 0 이상의 홀수인 값을 탐색합니다.</li>
</ul>

<p> </p>

<h3 id="43-allsatisfy"><span class="me-2"><strong>43. AllSatisfy</strong></span><a href="#43-allsatisfy" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre></td><td class="rouge-code"><pre>[2, 4, 6, 8, 10].publisher
    .allSatisfy { $0 % 2 == 0 }
    .sink { print("[AllSatisfy]", $0) } // [AllSatisfy] true

[2, 4, 6, 8, 9, 10].publisher
    .allSatisfy { $0 % 2 == 0 }
    .sink { print("[AllSatisfy]", $0) } // [AllSatisfy] false

[2, 4, 6, 8, 9, -9, 10].publisher
    .tryAllSatisfy {
        if $0 % 2 == 0 {
            return true
        } else if $0 &gt;= 0 {
            return false
        } else {
            throw PinguError.pinguIsBaboo
        }
    }
    .sink {
        print("[TryAllSatisfy 1 Comp]", $0)
    } receiveValue: {
        print("[TryAllSatisfy 1 Val]", $0)
    }

/*
결과: 
[TryAllSatisfy 1 Val] false
[TryAllSatisfy 1 Comp] finished
*/

[2, 4, 6, 8, 222, -9, 10].publisher
    .tryAllSatisfy {
        if $0 % 2 == 0 {
            return true
        } else if $0 &gt;= 0 {
            return false
        } else {
            throw PinguError.pinguIsBaboo
        }
    }
    .sink {
        print("[TryAllSatisfy 2 Comp]", $0)
    } receiveValue: {
        print("[TryAllSatisfy 2 Val]", $0)
    }

/*
결과:
[TryAllSatisfy 2 Comp] failure(__lldb_expr_69.PinguError.pinguIsBaboo)
*/

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">allSatisfy</code> 연산자는 Upstream의 모든 값이 주어진 조건을 만족하는지 확인합니다.</li>
  <li>첫 번째 예제는 모든 값이 짝수인지 확인하고, 두 번째 예제는 값 중 하나라도 홀수인지 확인합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">tryAllSatisfy</code> 연산자는 조건을 만족하지 않는 경우 에러를 발생시키며, 조건 검사 중 에러가 발생할 경우 처리할 수 있습니다.</li>
  <li>세 번째 예제는 0 이상의 짝수만 있는지를 확인하며, 네 번째 예제는 0 이상의 홀수라도 있는지를 확인합니다.</li>
</ul>

<p> </p>

<hr />

<h3 id="요소에-시퀀스-연산-적용하기"><span class="me-2"><strong>요소에 시퀀스 연산 적용하기</strong></span><a href="#요소에-시퀀스-연산-적용하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">DropUntilOutput</code></li>
  <li><code class="language-plaintext highlighter-rouge">Drop</code></li>
  <li><code class="language-plaintext highlighter-rouge">DropWhile</code></li>
  <li><code class="language-plaintext highlighter-rouge">TryDropWhile</code></li>
  <li><code class="language-plaintext highlighter-rouge">Concatenate</code></li>
  <li><code class="language-plaintext highlighter-rouge">PrefixWhile</code></li>
  <li><code class="language-plaintext highlighter-rouge">TryPrefixWhile</code></li>
  <li><code class="language-plaintext highlighter-rouge">PrefixUntilOutput</code></li>
</ul>

<p> </p>

<h4 id="연산자-2"><span class="me-2"><strong>연산자</strong></span><a href="#연산자-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">drop(untilOutputFrom:)</code></li>
  <li><code class="language-plaintext highlighter-rouge">dropFirst(_:)</code></li>
  <li><code class="language-plaintext highlighter-rouge">drop(while:)</code></li>
  <li><code class="language-plaintext highlighter-rouge">append(_:)</code></li>
  <li><code class="language-plaintext highlighter-rouge">prepend(_:)</code></li>
  <li><code class="language-plaintext highlighter-rouge">prefix(_:)</code></li>
  <li><code class="language-plaintext highlighter-rouge">prefix(while:)</code></li>
  <li><code class="language-plaintext highlighter-rouge">tryPrefix(while:)</code></li>
  <li><code class="language-plaintext highlighter-rouge">prefix(untilOutputFrom:)</code></li>
</ul>

<p> </p>

<h3 id="44-drop-until-output"><span class="me-2"><strong>44. Drop Until Output</strong></span><a href="#44-drop-until-output" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="rouge-code"><pre>// Upstream
let synthPublisher = PassthroughSubject&lt;Int, Never&gt;()
// Downstream
let bassPublisher = PassthroughSubject&lt;String, Never&gt;()

synthPublisher
    .drop(untilOutputFrom: bassPublisher)
    .sink { "DropUntilOutput".printWithResult($0) }

bassPublisher
    .sink { "DropUntilOutput".printWithResult($0) }

for i in 1...8 {
    if i == 5 {
        bassPublisher.send("VERY BIG BASS DROP!!!")
        continue
    }
    
    synthPublisher.send(i)
}

/*
 [DropUntilOutput] VERY BIG BASS DROP!!!
 [DropUntilOutput] 6
 [DropUntilOutput] 7
 [DropUntilOutput] 8
*/

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">drop(untilOutputFrom:)</code> 연산자는 지정된 Publisher로부터 값이 방출될 때까지 Upstream의 값을 무시합니다.</li>
  <li>예제에서는 <code class="language-plaintext highlighter-rouge">synthPublisher</code>의 값이 <code class="language-plaintext highlighter-rouge">bassPublisher</code>에서 첫 값을 받기 전까지 무시됩니다.</li>
</ul>

<p> </p>

<h3 id="45-drop-first"><span class="me-2"><strong>45. Drop First</strong></span><a href="#45-drop-first" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre>["A", "B", "C", "D", "E"].publisher
    .dropFirst(3)
    .sink { "DropFirst".printWithResult($0) }

/*
 [DropFirst] D
 [DropFirst] E
*/

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">dropFirst(_:)</code> 연산자는 지정한 개수만큼의 값을 제외하고 나머지 값을 방출합니다.</li>
  <li>예제에서는 배열의 처음 3개의 값을 제외한 후 나머지 값들을 방출합니다.</li>
</ul>

<p> </p>

<h3 id="46-drop-while"><span class="me-2"><strong>46. Drop While</strong></span><a href="#46-drop-while" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>["3", "4", "Crunchy", "Nuts", "5"].publisher
    .drop { Int($0) != nil }
    .sink { "DropWhile".printWithResult($0) }

/*
 [DropWhile] Crunchy
 [DropWhile] Nuts
 [DropWhile] 5
*/

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">drop(while:)</code> 연산자는 지정된 조건이 <strong>true</strong>인 동안 Upstream의 값을 무시합니다.</li>
  <li>예제에서는 값이 정수일 때까지 무시하며, 이후의 값을 방출합니다.</li>
</ul>

<p> </p>

<h3 id="47-try-drop-while"><span class="me-2"><strong>47. Try Drop While</strong></span><a href="#47-try-drop-while" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre>["3", "4", "G", "Crunchy", "Nuts", "5"].publisher
    .tryDrop {
        if $0 == "G" {
            throw PinguError.pinguIsBaboo
        } else {
            return Int($0) != nil
        }
    }
    .sink { "TryDropWhile Comp".printWithResult($0) } receiveValue: { "TryDropWhile Val".printWithResult($0) }

/*
 [TryDropWhile Comp] failure(__lldb_expr_69.PinguError.pinguIsBaboo)
 [TryDropWhile Val] false
*/

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">tryDrop(_:)</code> 연산자는 지정된 조건이 <strong>true</strong>인 동안 값을 무시하며, 조건 검토 중 에러가 발생할 수 있습니다.</li>
  <li>예제에서는 값이 “G”일 때 에러를 발생시키며, 그 외에는 정수인지 여부에 따라 값을 무시합니다.</li>
</ul>

<p> </p>

<h3 id="48-append"><span class="me-2"><strong>48. Append</strong></span><a href="#48-append" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre>[1, 2, 3, 4].publisher
    .append(5, 6)
    .append([7, 8, 9])
    .sink { _ in
        print()
    } receiveValue: {
        print($0, terminator: " ")
    }

/*
 1 2 3 4 5 6 7 8 9
*/

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">append(_:)</code> 연산자는 Upstream의 값 뒤에 지정된 값을 추가합니다.</li>
  <li>예제에서는 배열의 끝에 <code class="language-plaintext highlighter-rouge">5, 6</code>과 <code class="language-plaintext highlighter-rouge">[7, 8, 9]</code>를 추가합니다.</li>
</ul>

<p>[the_ad id=”3020”]</p>

<h3 id="49-prepend"><span class="me-2"><strong>49. Prepend</strong></span><a href="#49-prepend" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre>[1, 2, 3, 4].publisher
    .prepend(5, 6)
    .prepend([7, 8, 9])
    .sink { _ in
        print()
    } receiveValue: {
        print($0, terminator: " ")
    }

/*
 7 8 9 5 6 1 2 3 4
*/

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">prepend(_:)</code> 연산자는 Upstream의 값 앞에 지정된 값을 추가합니다.</li>
  <li>예제에서는 배열의 앞에 <code class="language-plaintext highlighter-rouge">[7, 8, 9]</code>와 <code class="language-plaintext highlighter-rouge">5, 6</code>을 추가합니다.</li>
</ul>

<p> </p>

<h3 id="50-prefix"><span class="me-2"><strong>50. Prefix</strong></span><a href="#50-prefix" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>[1, 2, 3, 4, 3, 2, 1].publisher
    .prefix(3)
    .sink { "Prefix".printWithResult($0) }

/*
 [Prefix] 1
 [Prefix] 2
 [Prefix] 3
*/

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">prefix(_:)</code> 연산자는 지정한 개수만큼의 값만 방출합니다.</li>
  <li>예제에서는 배열의 처음 3개의 값만 방출합니다.</li>
</ul>

<p> </p>

<h3 id="51-prefix-while"><span class="me-2"><strong>51. Prefix While</strong></span><a href="#51-prefix-while" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>"FLYANDFLY".split(separator: "").publisher
    .prefix { $0 != "A" }
    .sink { "Prefix".printWithResult($0) }

/*
 [Prefix] F
 [Prefix] L
 [Prefix] Y
*/

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">prefix(while:)</code> 연산자는 지정된 조건이 <strong>false</strong>가 될 때까지 값을 방출합니다.</li>
  <li>예제에서는 “A”가 나타날 때까지 문자를 방출합니다.</li>
</ul>

<p> </p>

<h3 id="52-try-prefix-while"><span class="me-2"><strong>52. Try Prefix While</strong></span><a href="#52-try-prefix-while" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre>"FLY_ANDFLY".split(separator: "").publisher
    .tryPrefix {
        if $0.rangeOfCharacter(from: .alphanumerics) != nil {
            throw PinguError.pinguIsBaboo
        }
        
        return $0 != "A"
    }
    .sink { "TryPrefix Comp".printWithResult($0) } receiveValue: { "TryPrefix Val".printWithResult($0)  }

/*
 [TryPrefix Comp] failure(__lldb_expr_69.PinguError.pinguIsBaboo)
 [TryPrefix Val] false
*/

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">tryPrefix(_:)</code> 연산자는 조건이 <strong>false</strong>가 될 때까지 값을 방출하며, 조건 검사 중 에러가 발생할 수 있습니다.</li>
  <li>예제에서는 “A”가 나타나기 전까지 문자를 방출하고, 중간에 에러가 발생할 수 있습니다.</li>
</ul>

<p> </p>

<h3 id="53-prefix-until-output-from"><span class="me-2"><strong>53. Prefix Until Output From</strong></span><a href="#53-prefix-until-output-from" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="rouge-code"><pre>// Upstream Publisher
let flowWaterPublisher = PassthroughSubject&lt;Int, Never&gt;()
// Blocking Publisher
let twistBlockingPublisher = PassthroughSubject&lt;String, Never&gt;()

flowWaterPublisher
    .prefix(untilOutputFrom: twistBlockingPublisher)
    .sink {
        print()
        "PrefixUntilOutputFrom Comp".printWithResult($0)
    } receiveValue: { print($0, terminator: " ")  }

for i in 1...15 {
    if i == 7 {
        twistBlockingPublisher.send("응안돼 돌아가")
        continue
    }
    
    flowWaterPublisher.send(i)
}

/*
 1 2 3 4 5 6
 [PrefixUntilOutputFrom Comp] finished
*/

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">prefix(untilOutputFrom:)</code> 연산자는 지정된 Publisher에서 값이 방출될 때까지 Upstream의 값을 방출합니다.</li>
  <li>예제에서는 <code class="language-plaintext highlighter-rouge">twistBlockingPublisher</code>에서 값이 방출될 때까지 <code class="language-plaintext highlighter-rouge">flowWaterPublisher</code>의 값을 방출합니다.</li>
</ul>

<p> </p>

<hr />

<p> </p>

<h3 id="특정-요소-선택하기"><span class="me-2"><strong>특정 요소 선택하기</strong></span><a href="#특정-요소-선택하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">First</code></li>
  <li><code class="language-plaintext highlighter-rouge">FirstWhere</code></li>
  <li><code class="language-plaintext highlighter-rouge">TryFirstWhere</code></li>
  <li><code class="language-plaintext highlighter-rouge">Last</code></li>
  <li><code class="language-plaintext highlighter-rouge">LastWhere</code></li>
  <li><code class="language-plaintext highlighter-rouge">TryLastWhere</code></li>
  <li><code class="language-plaintext highlighter-rouge">Output</code></li>
</ul>

<h4 id="연산자-3"><span class="me-2"><strong>연산자</strong></span><a href="#연산자-3" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">first()</code></li>
  <li><code class="language-plaintext highlighter-rouge">first(where:)</code></li>
  <li><code class="language-plaintext highlighter-rouge">tryFirst(where:)</code></li>
  <li><code class="language-plaintext highlighter-rouge">last()</code></li>
  <li><code class="language-plaintext highlighter-rouge">last(where:)</code></li>
  <li><code class="language-plaintext highlighter-rouge">tryLast(where:)</code></li>
  <li><code class="language-plaintext highlighter-rouge">output(at:)</code></li>
  <li><code class="language-plaintext highlighter-rouge">output(in:)</code></li>
</ul>

<p> </p>

<h3 id="54-first"><span class="me-2"><strong>54. First</strong></span><a href="#54-first" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>"FIRST".split(separator: "").publisher
    .first()
    .sink { "First".printWithResult($0) } // F

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">first()</code> 연산자는 Upstream에서 방출된 첫 번째 값을 반환합니다.</li>
  <li>예제에서는 문자열에서 첫 번째 문자인 “F”를 반환합니다.</li>
</ul>

<p> </p>

<h3 id="55-first-where"><span class="me-2"><strong>55. First Where</strong></span><a href="#55-first-where" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>[1, 3, 5, 2, 4, 5, 7, 8].publisher
    .first { $0 % 2 == 0 }
    .sink { "First".printWithResult($0) } // 2

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">first(where:)</code> 연산자는 주어진 조건을 만족하는 첫 번째 값을 반환합니다.</li>
  <li>예제에서는 배열에서 첫 번째 짝수인 2를 반환합니다.</li>
</ul>

<p> </p>

<h3 id="56-try-first-where"><span class="me-2"><strong>56. Try First Where</strong></span><a href="#56-try-first-where" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>"FIRST".split(separator: "").publisher
    .tryFirst {
        if $0 == "S" {
            throw PinguError.pinguIsBaboo
        }
        
        return $0 == "T"
    }
    .sink { "TryFirstWhere Comp".printWithResult($0) } receiveValue: { "TryFirstWhere Val".printWithResult($0) }
// 결과: [TryFirstWhere Comp] failure(__lldb_expr_69.PinguError.pinguIsBaboo)
</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">tryFirst(where:)</code> 연산자는 주어진 조건을 만족하는 첫 번째 값을 반환하며, 조건 검사 중 에러가 발생할 수 있습니다.</li>
  <li>예제에서는 “S”일 때 에러를 발생시키고, 그 외에는 “T”를 찾습니다.</li>
</ul>

<p> </p>

<h3 id="57-last"><span class="me-2"><strong>57. Last</strong></span><a href="#57-last" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre>let lastArrayPublisher = "LAST".split(separator: "").publisher
lastArrayPublisher
    .last()
    .sink { "Last".printWithResult($0) } // T

[1, 3, 5, 2, 4, 5, 7, 8].publisher
    .last { $0 % 2 == 1}
    .sink { "Last".printWithResult($0) } // 7

lastArrayPublisher
    .tryLast {
        if $0 == "T" // L을 입력하더라도 마찬가지로 에러 발생. 첫 요소부터 횡단??
        {
            throw PinguError.pinguIsBaboo
        }
        
        return $0 == "S"
    }
    .sink { "TryLastWhere Comp".printWithResult($0) } receiveValue: { "TryLastWhere Val".printWithResult($0) }
// 결과: [TryLastWhere Comp] failure(__lldb_expr_69.PinguError.pinguIsBaboo)
</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">last()</code> 연산자는 Upstream에서 방출된 마지막 값을 반환합니다.</li>
  <li>예제에서는 문자열의 마지막 문자인 “T”와 배열의 마지막 홀수인 7을 반환합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">tryLast(where:)</code> 연산자는 주어진 조건을 만족하는 마지막 값을 반환하며, 조건 검사 중 에러가 발생할 수 있습니다.</li>
  <li>예제에서는 “T”일 때 에러를 발생시키고, 그 외에는 “S”를 찾습니다.</li>
</ul>

<p> </p>

<h3 id="58-output"><span class="me-2"><strong>58. Output</strong></span><a href="#58-output" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="rouge-code"><pre>[0, 2, 163, 4, 8].publisher
    .output(at: 2) // 인덱스
    .sink { "Last at".printWithResult($0) } // 163

[0, 2, 163, 4, 8, 66, 71727485, 49, 3, 5, 3468].publisher
    .print()
    .output(in: 2...6) // Zero-based
    .sink {
        "Last in".printWithResult($0)
    } receiveValue: {
        print($0)
    }
/*
 receive subscription: ([0, 2, 163, 4, 8, 66, 71727485, 49, 3, 5, 3468])
 request unlimited
 receive value: (0)
 request max: (1) (synchronous)
 receive value: (2)
 request max: (1) (synchronous)
 receive value: (163)
 163
 receive value: (4)
 4
 receive value: (8)
 8
 receive value: (66)
 66
 receive value: (71727485)
 71727485
 receive cancel
 [Last in] finished
*/

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">output(at:)</code> 연산자는 지정된 인덱스에서 값을 방출합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">output(in:)</code> 연산자는 지정된 범위의 인덱스에서 값을 방출합니다.</li>
  <li>예제에서는 인덱스 2에서의 값과 범위 2부터 6까지의 값을 방출합니다.</li>
</ul>

<p> </p>

<hr />

<h3 id="여러-퍼블리셔로부터-요소-결합하기"><span class="me-2"><strong>여러 퍼블리셔로부터 요소 결합하기</strong></span><a href="#여러-퍼블리셔로부터-요소-결합하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">CombineLatest</code>: 여러 퍼블리셔로부터 마지막 요소를 모으고 재퍼블리싱</li>
  <li><code class="language-plaintext highlighter-rouge">Merge</code>: 여러 퍼블리셔를 재조립된 스트림으로 취급하여 재퍼블리싱</li>
  <li><code class="language-plaintext highlighter-rouge">Zip</code>: 여러 퍼블리셔로부터 가장 오래된 비방출 요소를 모아 재퍼블리싱</li>
</ul>

<p> </p>

<h4 id="연산자-4"><span class="me-2"><strong>연산자</strong></span><a href="#연산자-4" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">combineLatest(_ other:, _ transform:)</code></li>
  <li><code class="language-plaintext highlighter-rouge">combineLatest(_ other:)</code></li>
  <li><code class="language-plaintext highlighter-rouge">combineLatest(_ publisher1:, _ publisher2:, _ transform:)</code></li>
  <li><code class="language-plaintext highlighter-rouge">combineLatest(_ publisher1:, _ publisher2:)</code></li>
  <li><code class="language-plaintext highlighter-rouge">combineLatest(_ publisher1:, _ publisher2:, _ publisher3:, _ transform:)</code></li>
  <li><code class="language-plaintext highlighter-rouge">combineLatest(_ publisher1:, _ publisher2:, _ publisher3:)</code></li>
  <li><code class="language-plaintext highlighter-rouge">merge(with:)</code></li>
  <li><code class="language-plaintext highlighter-rouge">Publishers.MergeMany</code></li>
  <li><code class="language-plaintext highlighter-rouge">zip(_ other:)</code></li>
  <li><code class="language-plaintext highlighter-rouge">zip(_ other:, _ transform:)</code></li>
</ul>

<p> </p>

<h3 id="59-combinelatest_-other-_-transform"><span class="me-2"><strong>59. combineLatest(_ other:, _ transform:)</strong></span><a href="#59-combinelatest_-other-_-transform" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="rouge-code"><pre>var firstCombinePublisher = PassthroughSubject&lt;String, Never&gt;()
var secondCombinePublisher = PassthroughSubject&lt;String, Never&gt;()

firstCombinePublisher
    .combineLatest(secondCombinePublisher) { firstPubValue, secondPubValue in
        return firstPubValue + ":" + secondPubValue
    }
    .sink { "Combine2 Comp".printWithResult($0) } receiveValue: { "Combine2 Val".printWithResult($0) }

firstCombinePublisher.send("E")
secondCombinePublisher.send("F")

secondCombinePublisher.send("G")
firstCombinePublisher.send("H")

// 두 개의 퍼블리셔를 모두 마감시켜야 finished 처리됨
firstCombinePublisher.send(completion: .finished)
secondCombinePublisher.send(completion: .finished)
/*
     E            H    |
 -------------------------------
           F    G      |
 
 [Combine2] E:F
 [Combine2] E:G
 [Combine2] H:G
 [Combine2 Comp] finished
 */

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">combineLatest(_: _ transform:)</code> 연산자는 두 개의 퍼블리셔를 결합하고, 두 퍼블리셔에서 가장 최근에 방출된 값을 사용하여 변환 클로저를 실행합니다. 이 연산자는 퍼블리셔 중 하나가 새로운 값을 방출할 때마다 변환 클로저를 호출하여 새로운 값을 방출합니다.</li>
  <li>예를 들어, <code class="language-plaintext highlighter-rouge">firstCombinePublisher</code>와 <code class="language-plaintext highlighter-rouge">secondCombinePublisher</code>의 값이 결합되어 방출되며, 각각의 새로운 값이 방출될 때마다 최신 값이 반영됩니다.</li>
  <li>결과적으로, 이 연산자는 두 퍼블리셔가 모두 마감될 때까지 계속 동작하며, 그 결과로 결합된 값이 방출됩니다.</li>
</ul>

<p> </p>

<h3 id="60-combinelatest_-other---튜플-형태로만-내보낼-수-있음"><span class="me-2"><strong>60. combineLatest(_ other:) -&gt; 튜플 형태로만 내보낼 수 있음</strong></span><a href="#60-combinelatest_-other---튜플-형태로만-내보낼-수-있음" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="rouge-code"><pre>firstCombinePublisher = PassthroughSubject&lt;String, Never&gt;()
secondCombinePublisher = PassthroughSubject&lt;String, Never&gt;()

firstCombinePublisher
    .combineLatest(secondCombinePublisher)
    .sink { "CombineO Comp".printWithResult($0) } receiveValue: { "CombineO Val".printWithResult($0) }

firstCombinePublisher.send("E")
secondCombinePublisher.send("F")

secondCombinePublisher.send("G")
firstCombinePublisher.send("H")

firstCombinePublisher.send(completion: .finished)
secondCombinePublisher.send(completion: .finished)
/*
     E            H    |
 -------------------------------
           F    G      |
 
 [CombineO Val] ("E", "F")
 [CombineO Val] ("E", "G")
 [CombineO Val] ("H", "G")
 [CombineO Comp] finished
 */

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">combineLatest(_:)</code> 연산자는 두 개의 퍼블리셔에서 방출된 최신 값을 튜플 형태로 결합하여 방출합니다. 이 경우, 변환 클로저가 없이 튜플 형태로만 결합된 값이 방출됩니다.</li>
  <li>위 예제에서는 <code class="language-plaintext highlighter-rouge">firstCombinePublisher</code>와 <code class="language-plaintext highlighter-rouge">secondCombinePublisher</code>의 최신 값을 결합하여 방출하며, 각 퍼블리셔에서 새로운 값이 방출될 때마다 튜플로 결합된 결과가 방출됩니다.</li>
  <li>퍼블리셔가 모두 마감되면, <code class="language-plaintext highlighter-rouge">finished</code> 이벤트가 방출됩니다.</li>
</ul>

<p>[the_ad id=”3020”]</p>

<p> </p>

<h3 id="61-combinelatest_-publisher1-_-publisher2-_-transform"><span class="me-2"><strong>61. combineLatest(_ publisher1:, _ publisher2:, _ transform:)</strong></span><a href="#61-combinelatest_-publisher1-_-publisher2-_-transform" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
</pre></td><td class="rouge-code"><pre>var thirdCombinePublisher = PassthroughSubject&lt;String, Never&gt;()
/*
 B   O   U   N      C        Y
 ---------------------------------------------
       O       H        M   Y   G   O
 ---------------------------------------------
   F       A      S   H   I       O
 */

firstCombinePublisher
    .combineLatest(secondCombinePublisher, thirdCombinePublisher) { first, second, third in
        return first + ":" + second + ":" + third
    }
    .sink { "Combine3 Comp".printWithResult($0) } receiveValue: { "Combine3 Val".printWithResult($0) }

let firstCombineString = "BOUNCY"
let secondCombineString = "OHMYGO"
let thirdCombineString = "FASHIO"
let combine3Order = [1, 3, 1, 2, 1, 3, 1, 2, 3, 1, 3, 2, 3, 2, 1, 2, 3, 2]

var firstQueue = firstCombineString.split(separator: "")
var secondQueue = secondCombineString.split(separator: "")
var thirdQueue = thirdCombineString.split(separator: "")

combine3Order.forEach { combineIndex in
    switch combineIndex {
    case 1:
        firstCombinePublisher.send(String(firstQueue.removeFirst()))
    case 2:
        secondCombinePublisher.send(String(secondQueue.removeFirst()))
    case 3:
        thirdCombinePublisher.send(String(thirdQueue.removeFirst()))
    default:
        break
    }
}

firstCombinePublisher.send(completion: .finished)
secondCombinePublisher.send(completion: .finished)
thirdCombinePublisher.send(completion: .finished)

// emit Tuple
firstCombinePublisher = PassthroughSubject&lt;String, Never&gt;()
secondCombinePublisher = PassthroughSubject&lt;String, Never&gt;()
thirdCombinePublisher = PassthroughSubject&lt;String, Never&gt;()

firstCombinePublisher
    .combineLatest(secondCombinePublisher, thirdCombinePublisher)
    .sink { "Combine3o Comp".printWithResult($0) } receiveValue: { "Combine3o Val".printWithResult($0) }

firstQueue = firstCombineString.split(separator: "")
secondQueue = secondCombineString.split(separator: "")
thirdQueue = thirdCombineString.split(separator: "")

combine3Order.forEach { combineIndex in
    switch combineIndex {
    case 1:
        firstCombinePublisher.send(String(firstQueue.removeFirst()))
    case 2:
        secondCombinePublisher.send(String(secondQueue.removeFirst()))
    case 3:
        thirdCombinePublisher.send(String(thirdQueue.removeFirst()))
    default:
        break
    }
}

firstCombinePublisher.send(completion: .finished)
secondCombinePublisher.send(completion: .finished)
thirdCombinePublisher.send(completion: .finished)

/*
 B   O   U   N      C        Y
 ---------------------------------------------
       O       H        M   Y   G   O
 ---------------------------------------------
   F       A      S   H   I       O
 
 [Combine3 Val] O:O:F
 [Combine3 Val] U:O:F
 [Combine3 Val] U:O:A
 [Combine3 Val] N:O:A
 [Combine3 Val] N:H:A
 [Combine3 Val] N:H:S
 [Combine3 Val] C:H:S
 [Combine3 Val] C:H:H
 [Combine3 Val] C:M:H
 [Combine3 Val] C:M:I
 [Combine3 Val] C:Y:I
 [Combine3 Val] Y:Y:I
 [Combine3 Val] Y:G:I
 [Combine3 Val] Y:G:O
 [Combine3 Val] Y:O:O
 [Combine3 Comp] finished
 
 [Combine3o Val] ("O", "O", "F")
 [Combine3o Val] ("U", "O", "F")
 [Combine3o Val] ("U", "O", "A")
 [Combine3o Val] ("N", "O", "A")
 [Combine3o Val] ("N", "H", "A")
 [Combine3o Val] ("N", "H", "S")
 [Combine3o Val] ("C", "H", "S")
 [Combine3o Val] ("C", "H", "H")
 [Combine3o Val] ("C", "M", "H")
 [Combine3o Val] ("C", "M", "I")
 [Combine3o Val] ("C", "Y", "I")
 [Combine3o Val] ("Y", "Y", "I")
 [Combine3o Val] ("Y", "G", "I")
 [Combine3o Val] ("Y", "G", "O")
 [Combine3o Val] ("Y", "O", "O")
 [Combine3o Comp] finished
 */

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">combineLatest(_: _ transform:)</code> 연산자는 세 개 이상의 퍼블리셔에서 방출된 값을 결합하고, 변환 클로저를 통해 새로운 값을 생성합니다. 이 연산자는 각 퍼블리셔의 최신 값을 결합하여 클로저에서 정의한 방식으로 변환합니다.</li>
  <li>예제에서는 <code class="language-plaintext highlighter-rouge">firstCombinePublisher</code>, <code class="language-plaintext highlighter-rouge">secondCombinePublisher</code>, <code class="language-plaintext highlighter-rouge">thirdCombinePublisher</code>의 값이 결합되어 새로운 문자열을 생성합니다. 클로저에서는 각 퍼블리셔의 최신 값을 ‘:’로 구분된 문자열로 변환합니다.</li>
  <li>퍼블리셔가 모두 마감되면, <code class="language-plaintext highlighter-rouge">finished</code> 이벤트가 방출됩니다.</li>
</ul>

<p> </p>

<h3 id="62-combinelatest_-publisher1-_-publisher2-_-publisher3-_-transform"><span class="me-2"><strong>62. combineLatest(_ publisher1:, _ publisher2:, _ publisher3:, _ transform:)</strong></span><a href="#62-combinelatest_-publisher1-_-publisher2-_-publisher3-_-transform" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
</pre></td><td class="rouge-code"><pre>firstCombinePublisher = PassthroughSubject&lt;String, Never&gt;()
secondCombinePublisher = PassthroughSubject&lt;String, Never&gt;()
thirdCombinePublisher = PassthroughSubject&lt;String, Never&gt;()
var fourthCombinePublisher = PassthroughSubject&lt;String, Never&gt;()

/*
 B    O   U    N         C         Y
 ---------------------------------------------
        O          H         M   Y      G   O
 ---------------------------------------------
   F         A        S    H   I          O
 ---------------------------------------------
     f           l                   y
 */

let fourthString = "fly"
let combine4Order = [1, 3, 4, 1, 2, 1, 3, 1, 4, 2, 3, 1, 3, 2, 3, 2, 1, 4, 2, 3, 2]

firstQueue = firstCombineString.split(separator: "")
secondQueue = secondCombineString.split(separator: "")
thirdQueue = thirdCombineString.split(separator: "")
var fourthQueue = fourthString.split(separator: "")

firstCombinePublisher
    .combineLatest(secondCombinePublisher, thirdCombinePublisher, fourthCombinePublisher)
    .sink { "Combine4 Comp".printWithResult($0) } receiveValue: { "Combine4 Val".printWithResult($0) }
    

combine4Order.forEach { combineIndex in
    switch combineIndex {
    case 1:
        firstCombinePublisher.send(String(firstQueue.removeFirst()))
    case 2:
        secondCombinePublisher.send(String(secondQueue.removeFirst()))
    case 3:
        thirdCombinePublisher.send(String(thirdQueue.removeFirst()))
    case 4:
        fourthCombinePublisher.send(String(fourthQueue.removeFirst()))
    default:
        break
    }
}

[
    firstCombinePublisher,
    secondCombinePublisher,
    thirdCombinePublisher,
    fourthCombinePublisher,
].forEach {
    $0.send(completion: .finished)
}

/*
 B    O   U    N         C         Y
 ---------------------------------------------
        O          H         M   Y      G   O
 ---------------------------------------------
   F         A        S    H   I          O
 ---------------------------------------------
     f           l                   y
 
 [Combine4 Val] ("O", "O", "F", "f")
 [Combine4 Val] ("U", "O", "F", "f")
 [Combine4 Val] ("U", "O", "A", "f")
 [Combine4 Val] ("N", "O", "A", "f")
 [Combine4 Val] ("N", "O", "A", "l")
 [Combine4 Val] ("N", "H", "A", "l")
 [Combine4 Val] ("N", "H", "S", "l")
 [Combine4 Val] ("C", "H", "S", "l")
 [Combine4 Val] ("C", "H", "H", "l")
 [Combine4 Val] ("C", "M", "H", "l")
 [Combine4 Val] ("C", "M", "I", "l")
 [Combine4 Val] ("C", "Y", "I", "l")
 [Combine4 Val] ("Y", "Y", "I", "l")
 [Combine4 Val] ("Y", "Y", "I", "y")
 [Combine4 Val] ("Y", "G", "I", "y")
 [Combine4 Val] ("Y", "G", "O", "y")
 [Combine4 Val] ("Y", "O", "O", "y")
 [Combine4 Comp] finished
 */

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">combineLatest(_: _ publisher2:, _ publisher3:, _ publisher4:, _ transform:)</code> 연산자는 네 개의 퍼블리셔에서 방출된 값을 결합하고, 변환 클로저를 통해 새로운 값을 생성합니다. 이 연산자는 네 개의 퍼블리셔에서 최신 값을 결합하여 클로저에서 정의한 방식으로 변환합니다.</li>
  <li>예제에서는 <code class="language-plaintext highlighter-rouge">firstCombinePublisher</code>, <code class="language-plaintext highlighter-rouge">secondCombinePublisher</code>, <code class="language-plaintext highlighter-rouge">thirdCombinePublisher</code>, <code class="language-plaintext highlighter-rouge">fourthCombinePublisher</code>의 값이 결합되어 새로운 문자열을 생성합니다. 클로저에서는 각 퍼블리셔의 최신 값을 <code class="language-plaintext highlighter-rouge">':'</code>로 구분된 문자열로 변환합니다.</li>
  <li>퍼블리셔가 모두 마감되면, <code class="language-plaintext highlighter-rouge">finished</code> 이벤트가 방출됩니다.</li>
</ul>

<p> </p>

<h3 id="63-mergewith-other"><span class="me-2"><strong>63. merge(with other:)</strong></span><a href="#63-mergewith-other" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre>var firstMergePublisher = PassthroughSubject&lt;Int, Never&gt;()
var secondMergePublisher = PassthroughSubject&lt;Int, Never&gt;()

firstMergePublisher
    .merge(with: secondMergePublisher)
    .sink { "MergeO Comp".printWithResult($0) } receiveValue: { "MergeO Val".printWithResult($0) }

firstMergePublisher.send(1)
secondMergePublisher.send(38729857)
firstMergePublisher.send(2)
secondMergePublisher.send(19433338)
/*
 [MergeO Val] 1
 [MergeO Val] 38729857
 [MergeO Val] 2
 [MergeO Val] 19433338
 */

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">merge(with:)</code> 연산자는 두 개 이상의 퍼블리셔의 값을 결합하여 방출합니다. 모든 퍼블리셔에서 방출된 값들이 병렬로 처리되어, 각 퍼블리셔에서 방출된 값이 순서에 상관없이 방출됩니다.</li>
  <li>예제에서는 <code class="language-plaintext highlighter-rouge">firstMergePublisher</code>와 <code class="language-plaintext highlighter-rouge">secondMergePublisher</code>에서 방출된 값들이 병합되어 순서에 상관없이 출력됩니다.</li>
</ul>

<p> </p>

<h3 id="64-mergemany"><span class="me-2"><strong>64. MergeMany</strong></span><a href="#64-mergemany" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre>var mergePublishers: [PassthroughSubject&lt;Int, Never&gt;] = (0..&lt;20).map { index in
    PassthroughSubject&lt;Int, Never&gt;()
}

Publishers.MergeMany(mergePublishers)
    .sink { print($0, terminator: " ") }

for (index, publisher) in mergePublishers.enumerated() {
    publisher.send(index)
}
print()
/*
 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
 */

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Publishers.MergeMany</code> 연산자는 배열에 포함된 여러 퍼블리셔를 병합하여 방출합니다. 이 연산자는 각 퍼블리셔에서 방출된 값들을 병렬로 처리합니다.</li>
  <li>예제에서는 20개의 퍼블리셔를 생성하고, 각 퍼블리셔에서 방출된 값들이 순서에 상관없이 출력됩니다.</li>
</ul>

<p> </p>

<h3 id="65-zip_-other"><span class="me-2"><strong>65. zip(_ other:)</strong></span><a href="#65-zip_-other" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="rouge-code"><pre>var firstZipPub = PassthroughSubject&lt;Int, Never&gt;()
var secondZipPub = PassthroughSubject&lt;Int, Never&gt;()

firstZipPub
    .zip(secondZipPub)
    .sink { "Zip2 Comp".printWithResult($0) } receiveValue: { "Zip2 Val".printWithResult($0) }

firstZipPub.send(1)
secondZipPub.send(11)

firstZipPub.send(2)
secondZipPub.send(12)

for i in 3...9 {
    firstZipPub.send(i)
}

// 페어가 완성되어야만 finished 될 수 있음
firstZipPub.send(completion: .finished)

// 아래 부분이 실행되지 않은 경우 (3, 13) ~ (9, 19)는 방출되지 않는다
for i in 3...9 {
    secondZipPub.send(i + 10)
}
/*
 [Zip2 Val] (1, 11)
 [Zip2 Val] (2, 12)
 [Zip2 Val] (3, 13)
 [Zip2 Val] (4, 14)
 [Zip2 Val] (5, 15)
 [Zip2 Val] (6, 16)
 [Zip2 Val] (7, 17)
 [Zip2 Val] (8, 18)
 [Zip2 Val] (9, 19)
 [Zip2 Comp] finished
 */

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">zip(_ other:)</code> 연산자는 두 개의 퍼블리셔에서 방출된 값들을 짝지어 처리합니다. 두 퍼블리셔에서 각각 하나의 값이 방출되면, 이 두 값이 짝을 이루어 방출됩니다.</li>
  <li>예제에서는 <code class="language-plaintext highlighter-rouge">firstZipPub</code>과 <code class="language-plaintext highlighter-rouge">secondZipPub</code>의 값들이 짝지어 방출됩니다. 두 퍼블리셔 중 하나라도 먼저 완료되면, 남은 값들은 방출되지 않습니다.</li>
</ul>

<p> </p>

<h3 id="66-zip_-other-_-transform"><span class="me-2"><strong>66. zip(_ other:, _ transform:)</strong></span><a href="#66-zip_-other-_-transform" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="rouge-code"><pre>firstZipPub = PassthroughSubject&lt;Int, Never&gt;()
secondZipPub = PassthroughSubject&lt;Int, Never&gt;()
var thirdZipPub = PassthroughSubject&lt;Int, Never&gt;()

firstZipPub
    .zip(secondZipPub, thirdZipPub)
    .sink { "Zip3 Comp".printWithResult($0) } receiveValue: { "Zip3 Val".printWithResult($0) }

for i in 1...3 {
    firstZipPub.send(i)
}

for i in 1...3 {
    thirdZipPub.send(i * 100)
}

thirdZipPub.send(completion: .finished)

for i in 1...3 {
    secondZipPub.send(i * 10)
}

/*
 [Zip3 Val] (1, 10, 100)
 [Zip3 Val] (2, 20, 200)
 [Zip3 Val] (3, 30, 300)
 [Zip3 Comp] finished
 */

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">zip(_ other:, _ transform:)</code> 연산자는 여러 개의 퍼블리셔에서 방출된 값들을 결합하여 처리합니다. 변환 클로저를 사용하여 결합된 값을 새로운 형태로 변환합니다.</li>
  <li>예제에서는 <code class="language-plaintext highlighter-rouge">firstZipPub</code>, <code class="language-plaintext highlighter-rouge">secondZipPub</code>, <code class="language-plaintext highlighter-rouge">thirdZipPub</code>에서 방출된 값들이 각각 짝지어 결합된 후, 변환 클로저를 통해 새로운 형태로 방출됩니다.</li>
</ul>

<p> </p>

<hr />

<h3 id="새-퍼블리셔에-구독하여-요소-재퍼블리싱하기"><span class="me-2"><strong>새 퍼블리셔에 구독하여 요소 재퍼블리싱하기</strong></span><a href="#새-퍼블리셔에-구독하여-요소-재퍼블리싱하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">FlatMap</code></li>
  <li><code class="language-plaintext highlighter-rouge">SwitchToLatest</code></li>
</ul>

<h4 id="연산자-5"><span class="me-2"><strong>연산자</strong></span><a href="#연산자-5" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">flatMap(maxPublishers:_:)</code></li>
  <li><code class="language-plaintext highlighter-rouge">switchToLatest()</code></li>
</ul>

<p> </p>

<h3 id="67-flatmap"><span class="me-2"><strong>67. flatMap</strong></span><a href="#67-flatmap" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p><code class="language-plaintext highlighter-rouge">flatMap</code> 연산자는 퍼블리셔가 방출하는 퍼블리셔들을 플랫하게 병합합니다. 즉, 퍼블리셔가 방출하는 퍼블리셔에서 방출된 값을 모두 병합하여 처리합니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="rouge-code"><pre>typealias PassThruSubjString = PassthroughSubject&lt;String, Never&gt;

let fmPub1 = PassThruSubjString()
let fmPub2 = PassThruSubjString()
let fmPubs = PassthroughSubject&lt;PassThruSubjString, Never&gt;()

fmPubs
    // 최대 퍼블리셔 처리 개수
    .flatMap(maxPublishers: .max(2)) { publisher in
        publisher
    }
    .sink { "FlatMap Comp".printWithResult($0) } receiveValue: { "FlatMap Val".printWithResult($0) }

fmPubs.send(fmPub2)
fmPubs.send(fmPub1)

fmPub1.send("Hell")
fmPub1.send("World")

fmPub2.send("Kwangya")
fmPub2.send("ZZZZ")

/*
 max 1:
 [FlatMap Val] Kwangya
 [FlatMap Val] ZZZZ
 
 max 2:
 [FlatMap Val] Hell
 [FlatMap Val] World
 [FlatMap Val] Kwangya
 [FlatMap Val] ZZZZ
 */

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">flatMap</code>은 내부 퍼블리셔가 방출하는 모든 값을 병합하여 방출합니다. <code class="language-plaintext highlighter-rouge">maxPublishers</code> 매개변수를 통해 최대 퍼블리셔 개수를 제한할 수 있습니다.</li>
  <li>예제에서는 <code class="language-plaintext highlighter-rouge">fmPubs</code> 퍼블리셔가 <code class="language-plaintext highlighter-rouge">fmPub1</code>과 <code class="language-plaintext highlighter-rouge">fmPub2</code> 퍼블리셔를 방출하고, 이 퍼블리셔들에서 방출된 값들이 <code class="language-plaintext highlighter-rouge">flatMap</code> 연산자를 통해 병합되어 방출됩니다.</li>
</ul>

<p> </p>

<h3 id="68-flatmap-예제-아스키코드-정수-배열-변환"><span class="me-2"><strong>68. flatMap 예제: 아스키코드 정수 배열 변환</strong></span><a href="#68-flatmap-예제-아스키코드-정수-배열-변환" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="rouge-code"><pre>let decodeOnlyAlphabet: ([Int]) -&gt; AnyPublisher&lt;String, Never&gt; = { codes in
    Just(
        codes
            .compactMap { code in
                guard (65...90).contains(code) || (97...122).contains(code) else { return nil }
                return String(UnicodeScalar(code) ?? " ")
            }
            .joined()
    )
    .eraseToAnyPublisher()
}

let intArrayFMPublisher = PassthroughSubject&lt;[Int], Never&gt;()
intArrayFMPublisher
    .flatMap(decodeOnlyAlphabet)
    .sink { "FlatMap Comp".printWithResult($0) } receiveValue: { "FlatMap Val".printWithResult($0) }

intArrayFMPublisher.send([1, 80, 105, 110, 103, 117])
intArrayFMPublisher.send([1, 80, 105, 110, 103, 97])
intArrayFMPublisher.send(completion: .finished)
/*
 [FlatMap Val] Pingu
 [FlatMap Val] Pinga
 [FlatMap Comp] finished
 */

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li>예제에서는 정수 배열을 받아 아스키 코드 값에 따라 문자열로 변환하는 <code class="language-plaintext highlighter-rouge">decodeOnlyAlphabet</code> 함수가 사용됩니다. <code class="language-plaintext highlighter-rouge">flatMap</code>을 사용하여 배열을 문자열로 변환한 후 방출합니다.</li>
  <li>정수 배열이 방출되면, 해당 배열이 문자열로 변환된 후 방출됩니다.</li>
</ul>

<p> </p>

<h3 id="69-switchtolatest"><span class="me-2"><strong>69. switchToLatest</strong></span><a href="#69-switchtolatest" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p><code class="language-plaintext highlighter-rouge">switchToLatest</code> 연산자는 퍼블리셔가 방출하는 퍼블리셔들 중에서 최신의 퍼블리셔에서 방출된 값만을 처리합니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="rouge-code"><pre>typealias PssthrusbjInt = PassthroughSubject&lt;Int, Never&gt;
let slPub1 = PssthrusbjInt()
let slPub2 = PssthrusbjInt()
let slPub3 = PssthrusbjInt()
let slPubs = PassthroughSubject&lt;PssthrusbjInt, Never&gt;()

slPubs
    .switchToLatest()
    .sink { "SwitchToLatest Comp".printWithResult($0) } receiveValue: { "SwitchToLatest Val".printWithResult($0) }

slPubs.send(slPub1)
slPub1.send(99)
slPub1.send(18)

slPubs.send(slPub2)
slPub1.send(73939)
slPub2.send(-999)

slPubs.send(slPub3)
slPub1.send(245243939)
slPub2.send(182435)
slPub3.send(111111)

slPub3.send(completion: .finished)
slPubs.send(completion: .finished)
/*
 [SwitchToLatest Val] 99
 [SwitchToLatest Val] 18
 [SwitchToLatest Val] -999
 [SwitchToLatest Val] 111111
 [SwitchToLatest Comp] finished
 */

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">switchToLatest</code>는 새로운 퍼블리셔가 방출될 때마다 이전 퍼블리셔를 무시하고 새로운 퍼블리셔의 값을 처리합니다. 이전 퍼블리셔에서 방출된 값들은 무시됩니다.</li>
  <li>예제에서는 <code class="language-plaintext highlighter-rouge">slPubs</code> 퍼블리셔가 <code class="language-plaintext highlighter-rouge">slPub1</code>, <code class="language-plaintext highlighter-rouge">slPub2</code>, <code class="language-plaintext highlighter-rouge">slPub3</code>을 순차적으로 방출합니다. 각 퍼블리셔에서 방출된 값 중 최신의 퍼블리셔에서 방출된 값만이 처리됩니다.</li>
</ul>

<p> </p>

<h3 id="70-switchtolatest-예제-이전-요청-무시"><span class="me-2"><strong>70. switchToLatest 예제: 이전 요청 무시</strong></span><a href="#70-switchtolatest-예제-이전-요청-무시" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="rouge-code"><pre>var utSubsc = Set()
func userTapMockUp() {
    let url = URL(string: "https://source.unsplash.com/random")!
    
    func getImage() -&gt; AnyPublisher&lt;UIImage?, Never&gt; {
        URLSession.shared
            .dataTaskPublisher(for: url)
            .map { data, _ in UIImage(data: data) }
            .replaceError(with: nil)
            .eraseToAnyPublisher()
    }
    
    let userTap = PassthroughSubject&lt;Void, Never&gt;()
    userTap
        .map { _ in getImage() }
        .switchToLatest()
        .sink { "UserTap Comp".printWithResult($0 as Any) } receiveValue: { "UserTap Val".printWithResult($0 as Any) }
        // Stores this type-erasing cancellable instance in the specified set.
        .store(in: &amp;utSubsc)
    
    userTap.send()
    
    DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
        userTap.send()
    }
    
    DispatchQueue.main.asyncAfter(deadline: .now() + 2.1) {
        userTap.send()
    }
}
userTapMockUp()
/*
 [UserTap Val] Optional()
 [UserTap Val] Optional()
 */

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li>이 예제에서는 사용자가 화면을 탭할 때마다 새로운 이미지를 비동기로 로드합니다. <code class="language-plaintext highlighter-rouge">switchToLatest</code>를 사용하여 최신의 이미지 요청만을 처리하며, 이전의 요청은 무시합니다.</li>
  <li>사용자가 탭할 때마다 새로운 이미지가 로드되고, 그 결과로 최신의 이미지가 화면에 표시됩니다.</li>
</ul>

<p> </p>

<hr />

<h3 id="오류-처리하기"><span class="me-2"><strong>오류 처리하기</strong></span><a href="#오류-처리하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">AssertNoFailure</code></li>
  <li><code class="language-plaintext highlighter-rouge">Catch</code></li>
  <li><code class="language-plaintext highlighter-rouge">TryCatch</code></li>
  <li><code class="language-plaintext highlighter-rouge">Retry</code></li>
</ul>

<p> </p>

<h4 id="연산자-6"><span class="me-2"><strong>연산자</strong></span><a href="#연산자-6" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">assertNoFailure(_:file:line:)</code></li>
  <li><code class="language-plaintext highlighter-rouge">catch(_:)</code></li>
  <li><code class="language-plaintext highlighter-rouge">tryCatch(_:)</code></li>
  <li><code class="language-plaintext highlighter-rouge">retry(_:)</code></li>
</ul>

<p> </p>

<h3 id="71-assertnofailure_fileline"><span class="me-2"><strong>71. assertNoFailure(_:file:line:)</strong></span><a href="#71-assertnofailure_fileline" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p><code class="language-plaintext highlighter-rouge">assertNoFailure</code> 연산자는 퍼블리셔가 방출하는 값에서 오류가 발생하지 않음을 보장합니다. 만약 오류가 발생하면 <code class="language-plaintext highlighter-rouge">fatalError</code>를 호출하여 앱이 종료됩니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>let intPub1 = PassthroughSubject&lt;Int, PinguError&gt;()

intPub1
    .assertNoFailure()
    .sink { "assertNoFailure Comp".printWithResult($0) } receiveValue: { "assertNoFailure Val".printWithResult($0) }

intPub1.send(1)
intPub1.send(2)
// intPub1.send(completion: .failure(.pinguIsBaboo)) // FatalError 발생

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li>이 예제에서는 <code class="language-plaintext highlighter-rouge">assertNoFailure</code>를 사용하여 퍼블리셔가 오류를 방출하지 않도록 보장합니다. 만약 오류가 발생하면 앱이 종료됩니다.</li>
  <li>주석 처리된 <code class="language-plaintext highlighter-rouge">completion: .failure(.pinguIsBaboo)</code>는 주석을 해제하면 <code class="language-plaintext highlighter-rouge">fatalError</code>가 호출되어 앱이 종료됩니다.</li>
</ul>

<p> </p>

<h3 id="72-catch"><span class="me-2"><strong>72. catch</strong></span><a href="#72-catch" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p><code class="language-plaintext highlighter-rouge">catch</code> 연산자는 오류가 발생했을 때 대체 값을 방출하도록 합니다. 예를 들어, 오류가 발생하면 <code class="language-plaintext highlighter-rouge">Just</code> 퍼블리셔를 사용하여 기본 값을 방출할 수 있습니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre>[4, 6, 0, 1, 3, 7].publisher
    .tryMap {
        guard $0 != 0 else { throw PinguError.pinguIsBaboo }
        return $0 * 2
    }
    .catch { _ in Just(-999) }
    .sink { "catch Comp".printWithResult($0) } receiveValue: { "catch Val".printWithResult($0) }

/*
 [catch Val] 8
 [catch Val] 12
 [catch Val] -999
 [catch Comp] finished
 */

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">catch</code> 연산자는 <code class="language-plaintext highlighter-rouge">tryMap</code>에서 발생한 오류를 처리하여 기본 값인 <code class="language-plaintext highlighter-rouge">-999</code>를 방출합니다.</li>
  <li>오류가 발생한 후, 대체 값이 방출되고 스트림이 정상적으로 종료됩니다.</li>
</ul>

<p>[the_ad id=”3020”]</p>

<p> </p>

<h3 id="73-trycatch"><span class="me-2"><strong>73. tryCatch</strong></span><a href="#73-trycatch" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p><code class="language-plaintext highlighter-rouge">tryCatch</code> 연산자는 오류가 발생했을 때 대체 퍼블리셔를 방출합니다. 또한, 오류를 변환하여 다른 퍼블리셔를 방출할 수도 있습니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="rouge-code"><pre>let intPub2 = [4, 6, 0, 1, 3, 7].publisher
let anotherIntPub2 = [99, 999, 9999].publisher

// tryCatch에 에러 변환을 지정하지 않았을 경우
intPub2
    .tryMap {
        guard $0 != 0 else { throw PinguError.pinguIsBaboo }
        return $0 * 2
    }
    .tryCatch { error -&gt; AnyPublisher&lt;Int, Never&gt; in
        if error is PinguError { throw PandaError.thisIsBlackBear }
        return anotherIntPub2.eraseToAnyPublisher()
    }
    .sink { "tryCatch Comp".printWithResult($0) } receiveValue: { "tryCatch Val".printWithResult($0) }
    
/*
 * tryCatch에 에러 변환을 지정하지 않았을 경우
 [tryCatch Val] 8
 [tryCatch Val] 12
 [tryCatch Val] 99
 [tryCatch Val] 999
 [tryCatch Val] 9999
 [tryCatch Comp] finished
 
 * tryCatch에 에러 변환을 지정한 경우
 [tryCatch Val] 8
 [tryCatch Val] 12
 [tryCatch Comp] failure(__lldb_expr_85.PandaError.thisIsBlackBear)
 */

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li>예제에서는 <code class="language-plaintext highlighter-rouge">tryMap</code>에서 발생한 <code class="language-plaintext highlighter-rouge">PinguError</code>를 <code class="language-plaintext highlighter-rouge">tryCatch</code>로 처리하여, 오류가 발생할 경우 <code class="language-plaintext highlighter-rouge">PandaError</code>를 방출하거나 <code class="language-plaintext highlighter-rouge">anotherIntPub2</code> 퍼블리셔로 대체합니다.</li>
  <li>에러 변환이 없을 때는 대체 퍼블리셔가 방출되며, 에러 변환이 있을 경우 에러가 다시 방출될 수 있습니다.</li>
</ul>

<p> </p>

<h3 id="74-retry"><span class="me-2"><strong>74. Retry</strong></span><a href="#74-retry" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p><code class="language-plaintext highlighter-rouge">retry</code> 연산자는 오류가 발생했을 때 일정 횟수만큼 재시도합니다. 재시도가 끝나면 오류를 방출합니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="rouge-code"><pre>var retryCount: Int = 0
func retryTest() throws {
    if retryCount &lt; 2 {
        retryCount += 1
        print("\(retryCount) 번째 재시도")
        throw PandaError.thisIsBlackBear
    }
}

[1, 2, 3, 4].publisher
    .tryMap { value in
        try retryTest()
        return value
    }
    .retry(3)
    .sink { "retry Comp".printWithResult($0) } receiveValue: { "retry Val".printWithResult($0) }

/*
 retryCount &lt; 2
 1 번째 재시도
 2 번째 재시도
 [retry Val] 1
 [retry Val] 2
 [retry Val] 3
 [retry Val] 4
 [retry Comp] finished
 
 retryCount &lt; 4
 1 번째 재시도
 2 번째 재시도
 3 번째 재시도
 4 번째 재시도
 [retry Comp] failure(__lldb_expr_91.PandaError.thisIsBlackBear)
 */

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li>예제에서는 <code class="language-plaintext highlighter-rouge">retryTest</code> 함수가 재시도를 구현하며, <code class="language-plaintext highlighter-rouge">retry</code> 연산자를 통해 최대 3번의 재시도를 시도합니다.</li>
  <li>재시도 횟수가 지정된 횟수 내에서 오류가 발생하면, 그 이후에 성공하거나 오류가 발생하여 스트림이 종료됩니다.</li>
</ul>

<p> </p>

<hr />

<h3 id="타이밍-제어하기"><span class="me-2"><strong>타이밍 제어하기</strong></span><a href="#타이밍-제어하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">MeasureInterval</code></li>
  <li><code class="language-plaintext highlighter-rouge">Debounce</code></li>
  <li><code class="language-plaintext highlighter-rouge">Delay</code></li>
  <li><code class="language-plaintext highlighter-rouge">Throttle</code></li>
  <li><code class="language-plaintext highlighter-rouge">Timeout</code></li>
</ul>

<p> </p>

<h4 id="연산자-7"><span class="me-2"><strong>연산자</strong></span><a href="#연산자-7" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">measureInterval(using:options:)</code></li>
  <li><code class="language-plaintext highlighter-rouge">debounce(for:scheduler:options:)</code></li>
  <li><code class="language-plaintext highlighter-rouge">delay(for:tolerance:scheduler:options:)</code></li>
  <li><code class="language-plaintext highlighter-rouge">throttle(for:scheduler:latest:)</code></li>
  <li><code class="language-plaintext highlighter-rouge">timeout(_:scheduler:options:customError:)</code></li>
</ul>

<p> </p>

<h3 id="75-measureintervalusingoptions"><span class="me-2"><strong>75. measureInterval(using:options:)</strong></span><a href="#75-measureintervalusingoptions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p><code class="language-plaintext highlighter-rouge">measureInterval(using:options:)</code> 연산자는 퍼블리셔의 값을 방출한 시간 간격을 측정합니다. 주어진 스케줄러를 사용하여 시간 간격을 계산합니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="rouge-code"><pre>var miSubsc = Set&lt;AnyCancellable&gt;()
let miPub = PassthroughSubject&lt;Int, Never&gt;()

miPub
    .measureInterval(using: DispatchQueue.main)
    .sink {
        "MeasureInterval".printWithResult($0)
    } receiveValue: { nanosecond in
        print("Measure Time:", Double(nanosecond.magnitude) / 1000000000.0)
    }
    .store(in: &amp;miSubsc)
	
miPub.send(1)
sl...eep(1) // 해당 함수는 그대로 적으면 워드프레스 오류가 발샘하므로 ...를 제거
miPub.send(3584)
sl..eep(3)
miPub.send(56245)

/*
 Measure Time: 0.000358334
 Measure Time: 1.002780583
 Measure Time: 3.001439042
 */

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">measureInterval</code>는 퍼블리셔가 방출한 값의 간격을 측정합니다. 위의 예제에서 `miPub` 퍼블리셔가 방출한 값의 간격이 초 단위로 측정됩니다.</li>
</ul>

<p> </p>

<h3 id="76-debounce"><span class="me-2"><strong>76. Debounce</strong></span><a href="#76-debounce" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p><code class="language-plaintext highlighter-rouge">debounce(for:scheduler:options:)</code> 연산자는 값의 수신이 멈춘 후 일정 시간이 지나면 가장 최근의 값을 Downstream으로 전달합니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="rouge-code"><pre>var dbcSubsc = Set&lt;AnyCancellable&gt;()
let operationQueue: OperationQueue = {
    let operaionQueue = OperationQueue()
    operaionQueue.maxConcurrentOperationCount = 1
    return operaionQueue
}()

let textField = PassthroughSubject&lt;String, Never&gt;()
let bounces: [(String, TimeInterval)] = [ // 입력값, 입력 후 기다리는 시간
    ("www", 0.5),
    (".", 0.5),
    ("p", 1),
    ("ing", 0.5),
    ("u", 0.5),
    (".", 1.2),
    ("co", 0.5),
    ("m", 5),
]

var requestString = ""
textField
    .debounce(for: .seconds(1.0), scheduler: DispatchQueue.main)
    .sink { print("이번에 받은 값: \($0) , Network Request with: \(requestString)") }
    .store(in: &amp;dbcSubsc)

for bounce in bounces {
    operationQueue.addOperation {
        requestString += bounce.0
        textField.send(bounce.0)
        
        usleep(UInt32(bounce.1 * 1000000))
    }
}
/*
 이번에 받은 값: p , Network Request with: www.p
 이번에 받은 값: . , Network Request with: www.pingu.
 이번에 받은 값: m , Network Request with: www.pingu.com
 */

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">debounce</code>는 값이 일정 시간 동안 멈춘 후 가장 최근 값을 전달합니다. 위의 예제에서는 `textField`에서 입력된 값이 일정 시간 후에 처리됩니다.</li>
</ul>

<p> </p>

<h3 id="77-delay"><span class="me-2"><strong>77. Delay</strong></span><a href="#77-delay" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p><code class="language-plaintext highlighter-rouge">delay(for:tolerance:scheduler:options:)</code> 연산자는 주어진 시간 동안 값을 지연시킵니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="rouge-code"><pre>var delaySubsc = Set&lt;AnyCancellable&gt;()
let dateFormatter: DateFormatter = {
    let dateFormatter = DateFormatter()
    dateFormatter.dateStyle = .none
    dateFormatter.timeStyle = .long
    return dateFormatter
}()

Timer.publish(every: 1, on: .main, in: .default)
    .autoconnect()
    .handleEvents(receiveOutput:  { date in
        print("[Delay HE] Downstream으로 보낸값(현재시간): \(dateFormatter.string(from: date))")
    })
    .delay(for: .seconds(3), scheduler: RunLoop.main, options: .none)
    .sink {
        "Delay Comp".printWithResult($0)
    } receiveValue: {
        let now = Date()
        print("[Delay Val] 받은 값: \(dateFormatter.string(from: $0)) | 보낸시간: \(String(format: "%2.f", now.timeIntervalSince($0)))초 전")
    }
    .cancel()
    // .store(in: &amp;delaySubsc)

/*
 [Delay HE] Downstream으로 보낸값(현재시간): 1:40:47 PM GMT+9 (A)
 [Delay HE] Downstream으로 보낸값(현재시간): 1:40:48 PM GMT+9 (B)
 [Delay HE] Downstream으로 보낸값(현재시간): 1:40:49 PM GMT+9 (C)
 [Delay HE] Downstream으로 보낸값(현재시간): 1:40:50 PM GMT+9 (D)
 [Delay Val] 받은 값: 1:40:47 PM GMT+9 | 보낸시간:  3초 전    (A)
 [Delay HE] Downstream으로 보낸값(현재시간): 1:40:51 PM GMT+9
 [Delay Val] 받은 값: 1:40:48 PM GMT+9 | 보낸시간:  3초 전    (B)
 [Delay HE] Downstream으로 보낸값(현재시간): 1:40:52 PM GMT+9
 [Delay Val] 받은 값: 1:40:49 PM GMT+9 | 보낸시간:  3초 전    (C)
 [Delay HE] Downstream으로 보낸값(현재시간): 1:40:53 PM GMT+9
 [Delay Val] 받은 값: 1:40:50 PM GMT+9 | 보낸시간:  3초 전    (D)
 [Delay HE] Downstream으로 보낸값(현재시간): 1:40:54 PM GMT+9
 
 즉 Upstream Publisher에서 내려보낸 값이 3초 뒤에야 Downstream에 전달되는 것이죠.
 Downstream에서 받은 값은 현재 시간보다 3초 전의 값인 것을 볼 수 있어요.
 */

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">delay</code>는 값이 일정 시간 동안 지연되어 Downstream으로 전달됩니다. 위의 예제에서는 3초의 지연이 적용되었습니다.</li>
</ul>

<p> </p>

<h3 id="78-throttle"><span class="me-2"><strong>78. Throttle</strong></span><a href="#78-throttle" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p><code class="language-plaintext highlighter-rouge">throttle(for:scheduler:latest:)</code> 연산자는 지정된 시간 간격마다 Upstream 퍼블리셔가 보낸 가장 최근 값 혹은 가장 첫 번째 값을 Downstream으로 전달합니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
</pre></td><td class="rouge-code"><pre>var thrSubsc = Set&lt;AnyCancellable&gt;()
let thrOpQue: OperationQueue = {
    let operationQueue = OperationQueue()
    operationQueue.maxConcurrentOperationCount = 1
    return operationQueue
}()

let textField2 = PassthroughSubject&lt;String, Never&gt;()
let throttles: [(String, TimeInterval)] = bounces
var requestString2 = ""

textField2
    .throttle(for: .seconds(2), scheduler: DispatchQueue.main, latest: true)
    .sink {
        "Throttle Comp".printWithResult($0)
    } receiveValue: {
        print("[Throttle] 이번시간동안 받은 값중 최신값: \($0), 현재시간: \(Date().description), Network Request with: \(requestString)")
    }
    .cancel()
    // .store(in: &amp;thrSubsc)

textField2
    .sink(receiveCompletion: { print($0) },
          receiveValue: { string in
        print("[Throttle] 현재시간: \(Date().description), 이번에 내려보낸 값: \(string)")
    })
    .cancel()
    // .store(in: &amp;thrSubsc)

for throttle in throttles {
    thrOpQue.addOperation {
        requestString2 += throttle.0
        textField2.send(throttle.0)
        
        usleep(UInt32(throttle.1 * 1_000_000))
    }
}

/*
 Network Request를 2초마다 보냄
 
 [Throttle] 현재시간: 2023-08-19 04:57:23 +0000, 이번에 내려보낸 값: www
 [Throttle] 이번시간동안 받은 값중 최신값: www, 현재시간: 2023-08-19 04:57:24 +0000, Network Request with: www
 [Throttle] 현재시간: 2023-08-19 04:57:24 +0000, 이번에 내려보낸 값: .
 [Throttle] 현재시간: 2023-08-19 04:57:25 +0000, 이번에 내려보낸 값: p
 [Throttle] 현재시간: 2023-08-19 04:57:26 +0000, 이번에 내려보낸 값: ing
 [Throttle] 이번시간동안 받은 값중 최신값: ing, 현재시간: 2023-08-19 04:57:26 +0000, Network Request with: www.ping
 [Throttle] 현재시간: 2023-08-19 04:57:26 +0000, 이번에 내려보낸 값: u
 [Throttle] 현재시간: 2023-08-19 04:57:27 +0000, 이번에 내려보낸 값: .
 [Throttle] 이번시간동안 받은 값중 최신값: ., 현재시간: 2023-08-19 04:57:28 +0000, Network Request with: www.pingu.co
 [Throttle] 현재시간: 2023-08-19 04:57:28 +0000, 이번에 내려보낸 값: co
 [Throttle] 현재시간: 2023-08-19 04:57:28 +0000, 이번에 내려보낸 값: m
 [Throttle] 이번시간동안 받은 값중 최신값: m, 현재시간: 2023-08-19 04:57:30 +0000, Network Request with: www.pingu.com
 */

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">throttle</code>는 지정된 시간 간격마다 최신 값 또는 첫 번째 값을 Downstream으로 전달합니다. 위의 예제에서는 2초마다 최신 값이 전달됩니다.</li>
</ul>

<p> </p>

<h3 id="79-timeout"><span class="me-2"><strong>79. Timeout</strong></span><a href="#79-timeout" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p><code class="language-plaintext highlighter-rouge">timeout(_:scheduler:options:customError:)</code> 연산자는 주어진 시간 내에 값을 받지 못할 경우 에러를 발생시킵니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="rouge-code"><pre>struct TimeoutError: Error {}
let ttIntPublisher = PassthroughSubject&lt;Int, TimeoutError&gt;()
ttIntPublisher
    .timeout(.seconds(2), scheduler: DispatchQueue.main) {
        return TimeoutError()
    }
    .sink { "Timeout Comp".printWithResult($0) } receiveValue: { "Timeout Val".printWithResult($0) }
    .store(in: &amp;thrSubsc)

ttIntPublisher.send(1)
ttIntPublisher.send(2)
// timeout 최대 시간이 2초 설정인데 2.5초뒤에 send되도록 함
DispatchQueue.main.asyncAfter(deadline: .now() + 2.5) {
    ttIntPublisher.send(3)
}

/*
 [Timeout Val] 1
 [Timeout Val] 2
 [Timeout Comp] failure(__lldb_expr_120.TimeoutError())
 
 customError 클로저에서 에러를 반환하지 않으면 그냥 finished 됩니다!
 */

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">timeout</code>은 지정된 시간 내에 값을 받지 못하면 에러를 발생시키거나 커스텀 에러를 발생시킬 수 있습니다. 위의 예제에서는 2초를 초과할 경우 에러가 발생합니다.</li>
</ul>

<p> </p>

<hr />

<h3 id="인코딩-및-디코딩"><span class="me-2"><strong>인코딩 및 디코딩</strong></span><a href="#인코딩-및-디코딩" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Encode</code></li>
  <li><code class="language-plaintext highlighter-rouge">Decode</code></li>
</ul>

<p> </p>

<h4 id="연산자-8"><span class="me-2"><strong>연산자</strong></span><a href="#연산자-8" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">encode(encoder:)</code></li>
  <li><code class="language-plaintext highlighter-rouge">decode(type:decoder:)</code></li>
</ul>

<p> </p>

<h3 id="80-encode"><span class="me-2"><strong>80. Encode</strong></span><a href="#80-encode" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p><code class="language-plaintext highlighter-rouge">encode(encoder:)</code> 연산자는 퍼블리셔에서 발행된 값을 지정된 인코더를 사용하여 인코딩합니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="rouge-code"><pre>struct GiantPanda: Codable {
    let name: String
    let age: Int
    let address: String
}

let gPandaPub = PassthroughSubject&lt;GiantPanda, Never&gt;()
gPandaPub
    .encode(encoder: JSONEncoder())
    .sink {
        "Encode Comp".printWithResult($0)
    } receiveValue: { data in
        print("[Encode Val] 인코딩된 값: \(data)")
        guard let string = String(data: data, encoding: .utf8) else {
            return
        }
        print("[Encode Val] 인코딩 값의 문자열 표현: \(string)")
    }

gPandaPub.send(.init(name: "FuBao", age: 3, address: "용인시"))
/*
 [Encode Val] 인코딩된 값: 46 bytes
 [Encode Val] 인코딩 값의 문자열 표현: {"name":"FuBao","age":3,"address":"용인시"}
 */

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">encode</code>는 퍼블리셔가 방출한 값을 인코더를 사용하여 인코딩합니다. 위의 예제에서는 `GiantPanda` 객체가 JSON으로 인코딩됩니다.</li>
</ul>

<p> </p>

<h3 id="81-decode"><span class="me-2"><strong>81. Decode</strong></span><a href="#81-decode" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p><code class="language-plaintext highlighter-rouge">decode(type:decoder:)</code> 연산자는 데이터 타입을 지정하여 데이터를 디코딩합니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre>let gPandaDataPub = PassthroughSubject&lt;Data, Never&gt;()
gPandaDataPub
    .decode(type: GiantPanda.self, decoder: JSONDecoder())
    .sink{
        "Decode Comp".printWithResult($0)
    } receiveValue: { decoded in
        "Decode Val".printWithResult(decoded)
    }

let jsonString = """
    {"name":"LeBao","age":11,"address":"용인시"}
"""
let lebaoData = Data(jsonString.utf8)
gPandaDataPub.send(lebaoData)
/*
 [Decode Val] GiantPanda(name: "LeBao", age: 11, address: "용인시")
 */

</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">decode</code>는 퍼블리셔가 방출한 데이터를 지정된 디코더를 사용하여 디코딩합니다. 위의 예제에서는 JSON 데이터를 `GiantPanda` 객체로 디코딩합니다.</li>
</ul>

<p> </p>

<p>[rcblock id=”6686”]</p>

  </div>

  <div class="post-tail-wrapper text-muted">
    <!-- categories -->
    
      <div class="post-meta mb-3">
        <i class="far fa-folder-open fa-fw me-1"></i>
        
          <a href="/categories/devlog/">DevLog</a>,
          <a href="/categories/swift/">Swift</a>
      </div>
    

    <!-- tags -->
    

    <div
      class="
        post-tail-bottom
        d-flex justify-content-between align-items-center mt-5 pb-2
      "
    >
      <div class="license-wrapper">
        
          

          This post is licensed under 
        <a href="https://creativecommons.org/licenses/by/4.0/">
          CC BY 4.0
        </a>
         by the author.
        
      </div>

      <!-- Post sharing snippet -->

<div class="share-wrapper d-flex align-items-center">
  <span class="share-label text-muted">Share</span>
  <span class="share-icons">
    
    
    

    

      

      <a href="https://twitter.com/intent/tweet?text=Swift:%20Combine%20%EA%B8%B0%EB%B3%B8%20%EA%B8%B0%EB%8A%A5%2081%EA%B0%80%EC%A7%80%20%ED%95%9C%20%EB%B2%88%EC%97%90%20%EC%9A%94%EC%95%BD%20%EC%A0%95%EB%A6%AC%20-%20BGSMM&url=https%3A%2F%2Fayaysir.github.io%2Fposts%2Fswift-combine-%25EA%25B8%25B0%25EB%25B3%25B8-%25EA%25B8%25B0%25EB%258A%25A5-%25EC%259A%2594%25EC%2595%25BD-%25EC%25A0%2595%25EB%25A6%25AC-1-3%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter">
        <i class="fa-fw fa-brands fa-square-x-twitter"></i>
      </a>
    

      

      <a href="https://www.facebook.com/sharer/sharer.php?title=Swift:%20Combine%20%EA%B8%B0%EB%B3%B8%20%EA%B8%B0%EB%8A%A5%2081%EA%B0%80%EC%A7%80%20%ED%95%9C%20%EB%B2%88%EC%97%90%20%EC%9A%94%EC%95%BD%20%EC%A0%95%EB%A6%AC%20-%20BGSMM&u=https%3A%2F%2Fayaysir.github.io%2Fposts%2Fswift-combine-%25EA%25B8%25B0%25EB%25B3%25B8-%25EA%25B8%25B0%25EB%258A%25A5-%25EC%259A%2594%25EC%2595%25BD-%25EC%25A0%2595%25EB%25A6%25AC-1-3%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook">
        <i class="fa-fw fab fa-facebook-square"></i>
      </a>
    

      

      <a href="https://t.me/share/url?url=https%3A%2F%2Fayaysir.github.io%2Fposts%2Fswift-combine-%25EA%25B8%25B0%25EB%25B3%25B8-%25EA%25B8%25B0%25EB%258A%25A5-%25EC%259A%2594%25EC%2595%25BD-%25EC%25A0%2595%25EB%25A6%25AC-1-3%2F&text=Swift:%20Combine%20%EA%B8%B0%EB%B3%B8%20%EA%B8%B0%EB%8A%A5%2081%EA%B0%80%EC%A7%80%20%ED%95%9C%20%EB%B2%88%EC%97%90%20%EC%9A%94%EC%95%BD%20%EC%A0%95%EB%A6%AC%20-%20BGSMM" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram">
        <i class="fa-fw fab fa-telegram"></i>
      </a>
    

    <button
      id="copy-link"
      aria-label="Copy link"
      class="btn small"
      data-bs-toggle="tooltip"
      data-bs-placement="top"
      title="Copy link"
      data-title-succeed="Link copied successfully!"
    >
      <i class="fa-fw fas fa-link pe-none fs-6"></i>
    </button>
  </span>
</div>

    </div>
    <!-- .post-tail-bottom -->
  </div>
  <!-- div.post-tail-wrapper -->
</article>


            
          </main>

          <!-- panel -->
          <aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 text-muted">
            <div class="access">
              <!-- Get 5 last posted/updated posts -->














  <section id="access-lastmod">
    <h2 class="panel-heading">Recently Updated</h2>
    <ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2">
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/xcode-where-is-infoplist/">Xcode 에서 Info.plist 파일이 없을 때</a>
        </li>
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/swift-urlscheme/">Swift: iOS에서 Custom URL Scheme 등록해서 url로 앱 열기</a>
        </li>
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/swift-translation/">SwiftUI: 번역 기능 (Translation) 사용하기 (iOS 18 이상)</a>
        </li>
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/swift-extensioncontext-error-ios18/">Swift: Action Extension에서 extensionContext가 iOS 18에서 작동하지 않는 문제</a>
        </li>
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/swift-action-extension/">Swift: Action Extension으로 사진을 내 앱으로 전송하기</a>
        </li>
      
    </ul>
  </section>
  <!-- #access-lastmod -->


              <!-- The trending tags list -->















  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        



  <section>
    <h2 class="panel-heading">Trending Tags</h2>
    <div class="d-flex flex-wrap mt-3 mb-1 me-3">
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/audiokit/">AudioKit</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%EC%9D%8C%ED%96%A5%EC%9D%B4%EB%A1%A0/">음향이론</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/swift/">swift</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/java/">java</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/">자바스크립트</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/spring-boot/">spring-boot</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/spring/">spring</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/vue-js/">vue-js</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%EC%9E%90%EB%B0%94/">자바</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/opengl/">opengl</a>
      
    </div>
  </section>


            </div>

            
              
              






  <div class="toc-border-cover z-3"></div>
  <section id="toc-wrapper" class="invisible position-sticky ps-0 pe-4 pb-4">
    <h2 class="panel-heading ps-3 pb-2 mb-0">Contents</h2>
    <nav id="toc"></nav>
  </section>


            
          </aside>
        </div>

        <div class="row">
          <!-- tail -->
          <div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4">
            
              
              <!-- Recommend the other 3 posts according to the tags and categories of the current post. -->

<!-- The total size of related posts -->


<!-- An random integer that bigger than 0 -->


<!-- Equals to TAG_SCORE / {max_categories_hierarchy} -->















  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  
    
  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  











  <aside id="related-posts" aria-labelledby="related-label">
    <h3 class="mb-4" id="related-label">Further Reading</h3>
    <nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4">
      
        <article class="col">
          <a href="/posts/swift-urlscheme/" class="post-preview card h-100">
            <div class="card-body">
              <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1761365460"
  data-df="ll"
  
>
  Oct 25, 2025
</time>

              <h4 class="pt-0 my-2">Swift: iOS에서 Custom URL Scheme 등록해서 url로 앱 열기</h4>
              <div class="text-muted">
                <p>iOS에서 Custom URL Scheme를 등록하는 방법입니다.  ---  ## 1. 메인 앱에 URL Scheme 등록  먼저 ImageTranslator 앱의 Info.plist에 다음을 추가하세요.  ```xml CFBundleURLTypes         CFBundleURLSchemes            imagetranslator    ...</p>
              </div>
            </div>
          </a>
        </article>
      
        <article class="col">
          <a href="/posts/swift-extensioncontext-error-ios18/" class="post-preview card h-100">
            <div class="card-body">
              <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1761315060"
  data-df="ll"
  
>
  Oct 24, 2025
</time>

              <h4 class="pt-0 my-2">Swift: Action Extension에서 extensionContext가 iOS 18에서 작동하지 않는 문제</h4>
              <div class="text-muted">
                <p>iOS 18부터 **Action Extension에서 메인 앱을 여는(openURL) 기능이 동작하지 않는 문제** (iOS 17 이하에서는 정상 동작했음) 에 대한 해결방법 요약입니다.  ### 원문 링크 - [Stack Overflow](https://stackoverflow.com/questions/79077018/unable-to-open-ma...</p>
              </div>
            </div>
          </a>
        </article>
      
        <article class="col">
          <a href="/posts/swift-action-extension/" class="post-preview card h-100">
            <div class="card-body">
              <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1761307860"
  data-df="ll"
  
>
  Oct 24, 2025
</time>

              <h4 class="pt-0 my-2">Swift: Action Extension으로 사진을 내 앱으로 전송하기</h4>
              <div class="text-muted">
                <p>“Action Extension으로 사진을 내 앱에 넘기는 방법”은 Share Extension과 비슷하지만, Action Extension은 ‘공유’가 아니라 원본 앱의 컨텍스트 안에서 바로 실행되는 확장(App Extension) 입니다. 즉, 사용자가 사진 앱, 파일 앱 등에서 “공유” 메뉴 대신 “작업(Action)” 메뉴에서 내 앱을 실행할 ...</p>
              </div>
            </div>
          </a>
        </article>
      
    </nav>
  </aside>
  <!-- #related-posts -->


            
              
              <!-- Navigation buttons at the bottom of the post. -->

<nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation">
  
  

  
    <a
      href="/posts/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BF%BC%EB%93%9C%ED%8A%B8%EB%A6%AC-%EB%B0%B1%EC%A4%80-1992-%EC%BF%BC%EB%93%9C%ED%8A%B8%EB%A6%AC%EB%A1%9C-%EC%95%95%EC%B6%95-%EB%B0%8F-%ED%95%B4/"
      class="btn btn-outline-primary"
      aria-label="Older"
    >
      <p>코딩테스트: 쿼드트리 (백준 1992) + 쿼드트리로 압축 및 해제하는 과정</p>
    </a>
  

  
    <a
      href="/posts/%EC%9C%A0%EB%9F%BD-%EB%B8%8C%EB%9D%BC%EC%8A%A4-%EB%B0%B4%EB%93%9C-%EC%B1%94%ED%94%BC%EC%96%B8%EC%8B%AD-%EC%B5%9C%EA%B3%A0%EC%9D%98-%EC%88%9C%EA%B0%84-%EB%8B%A4%EC%84%AF-%EA%B0%80%EC%A7%80%EC%99%80/"
      class="btn btn-outline-primary"
      aria-label="Newer"
    >
      <p>유럽 브라스 밴드 챔피언십: 최고의 순간 다섯 가지와 최악의 순간 다섯 가지</p>
    </a>
  
</nav>

            

            <!-- The Footer -->

<footer
  aria-label="Site Info"
  class="
    d-flex flex-column justify-content-center text-muted
    flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3
  "
>
  <p>©
    <time>2025</time>

    
      <a href="https://github.com/ayaysir">ayaysir</a>.
    

    
      <span
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author."
      >Some rights reserved.</span>
    
  </p>

  <p>Using the <a
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="v7.3.1"
        href="https://github.com/cotes2020/jekyll-theme-chirpy"
        target="_blank"
        rel="noopener"
      >Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.
  </p>
</footer>

          </div>
        </div>

        <!-- The Search results -->

<div id="search-result-wrapper" class="d-flex justify-content-center d-none">
  <div class="col-11 content">
    <div id="search-hints">
      <!-- The trending tags list -->















  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        



  <section>
    <h2 class="panel-heading">Trending Tags</h2>
    <div class="d-flex flex-wrap mt-3 mb-1 me-3">
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/audiokit/">AudioKit</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%EC%9D%8C%ED%96%A5%EC%9D%B4%EB%A1%A0/">음향이론</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/swift/">swift</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/java/">java</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/">자바스크립트</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/spring-boot/">spring-boot</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/spring/">spring</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/vue-js/">vue-js</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%EC%9E%90%EB%B0%94/">자바</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/opengl/">opengl</a>
      
    </div>
  </section>


    </div>
    <div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div>
  </div>
</div>

      </div>

      <aside aria-label="Scroll to Top">
        <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow">
          <i class="fas fa-angle-up"></i>
        </button>
      </aside>
    </div>

    <div id="mask" class="d-none position-fixed w-100 h-100 z-1"></div>

    
      <aside
  id="notification"
  class="toast"
  role="alert"
  aria-live="assertive"
  aria-atomic="true"
  data-bs-animation="true"
  data-bs-autohide="false"
>
  <div class="toast-header">
    <button
      type="button"
      class="btn-close ms-auto"
      data-bs-dismiss="toast"
      aria-label="Close"
    ></button>
  </div>
  <div class="toast-body text-center pt-0">
    <p class="px-2 mb-3">A new version of content is available.</p>
    <button type="button" class="btn btn-primary" aria-label="Update">
      Update
    </button>
  </div>
</aside>

    

    <!-- Embedded scripts -->

    
      
      <!-- The comments switcher -->

  
  <!-- https://giscus.app/ -->
<script>
  (function () {
    const themeMapper = Theme.getThemeMapper('light', 'dark_dimmed');
    const initTheme = themeMapper[Theme.visualState];

    let lang = 'en';if (lang.length > 2 && !lang.startsWith('zh')) {
      lang = lang.slice(0, 2);
    }

    let giscusAttributes = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'ayaysir/ayaysir.github.io',
      'data-repo-id': 'R_kgDOOurl2w',
      'data-category': 'General',
      'data-category-id': 'DIC_kwDOOurl284CxFIa',
      'data-mapping': 'pathname',
      'data-strict' : '0',
      'data-reactions-enabled': '1',
      'data-emit-metadata': '0',
      'data-theme': initTheme,
      'data-input-position': 'bottom',
      'data-lang': lang,
      'data-loading': 'lazy',
      crossorigin: 'anonymous',
      async: ''
    };

    let giscusNode = document.createElement('script');
    Object.entries(giscusAttributes).forEach(([key, value]) =>
      giscusNode.setAttribute(key, value)
    );

    const $footer = document.querySelector('footer');
    $footer.insertAdjacentElement("beforebegin", giscusNode);

    addEventListener('message', (event) => {
      if (event.source === window && event.data && event.data.id === Theme.ID) {
        const newTheme = themeMapper[Theme.visualState];

        const message = {
          setConfig: {
            theme: newTheme
          }
        };

        const giscus =
          document.getElementsByClassName('giscus-frame')[0].contentWindow;
        giscus.postMessage({ giscus: message }, 'https://giscus.app');
      }
    });
  })();
</script>



    

    <!--
  Jekyll Simple Search loader
  See: <https://github.com/christian-fei/Simple-Jekyll-Search>
-->





<script>
  
  document.addEventListener('DOMContentLoaded', () => {
    SimpleJekyllSearch({
      searchInput: document.getElementById('search-input'),
      resultsContainer: document.getElementById('search-results'),
      json: '/assets/js/data/search.json',
      searchResultTemplate: '  <article class="px-1 px-sm-2 px-lg-4 px-xl-0">    <header>      <h2><a href="{url}">{title}</a></h2>      <div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1">        {categories}        {tags}      </div>    </header>    <p>{content}</p>  </article>',
      noResultsText: '<p class="mt-5">Oops! No results found.</p>',
      templateMiddleware: function(prop, value, template) {
        if (prop === 'categories') {
          if (value === '') {
            return `${value}`;
          } else {
            return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`;
          }
        }

        if (prop === 'tags') {
          if (value === '') {
            return `${value}`;
          } else {
            return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`;
          }
        }
      }
    });
  });
</script>

  </body>
</html>

