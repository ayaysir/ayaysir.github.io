---
published: false
title: "Swift: 스위프트 둘러보기 2 (enum, 프로토콜, 에러 핸들링, 제너릭 타입)"
date: 2019-01-29
categories: 
  - "none"
tags: 
  - "swift"
  - "스위프트"
---

둘러보기 1: [http://yoonbumtae.com/?p=592](http://yoonbumtae.com/?p=592)

**enum**: 자바의 Enum과 거의 유사합니다.

```
import Foundation 

//=========== enum: 자바의 그것과 같음 ===========//

enum Rank: Int {
    case ace = 1    // 원래 0부터 시작하는데 특별히 1부터 시작하도록 지정
    case two, three, four, five, six, seven, eight, nine, ten
    case jack, queen, king

    func simpleDescription() -> String {
        switch self {
        case .ace:
            return "에이스"
        case .jack:
            return "잭"
        case .queen:
            return "퀸"
        case .king:
            return "킹"
        default:
            return String(self.rawValue)
        }
    }
}
let ace = Rank.ace
let aceRawValue = ace.rawValue
print(ace, ace.simpleDescription()) // ace 에이스
print(Rank.eight.rawValue)  // 8

// 에러: print(Rank(rawValue: 8).simpleDescription())
// must be unwrapped to refer to member 'simpleDescription' 
// of wrapped base type 'Rank'

print(Rank(rawValue: 8))
if let eight = Rank(rawValue: 8) {
    let eightDescription = eight.simpleDescription()
    print(eightDescription) // 8
}
// print(eightDescription) // 에러: use of unresolved identifier 

let three: Rank! = Rank(rawValue: 3)
print(three.simpleDescription())    // 3

/****************************************************/

// 실험 두개의 Rank 값의 원본 값을 비교하는 함수를 만들어보자.
func compareOfTwoRanks(_ one: Rank, _ another: Rank)  {
   if one.rawValue > another.rawValue{
       print(one.simpleDescription() + "이 더 크다")
   } else if one.rawValue < another.rawValue{
       print(another.simpleDescription() + "이 더 크다")
   } else {
       print("똑같다")
   }
}
compareOfTwoRanks(Rank.queen, Rank.jack)    // 퀸이 더 크다

/****************************************************/

// 실험 Suit에 color 메서드를 추가해 보자. 
// color 메서드는 스페이드와 클로버는 'black'을 반환하고 
// 하트와 다이아몬드는 'red'를 반환하도록 하면 됩니다.

enum Suit { // Int 등의 값이 없으면 이 enum의 rawValue값은 없다
    case spades, hearts, diamonds, clubs

    func simpleDescription() -> String {
        switch self {
        case .spades:
            return "spades"
        case .hearts:
            return "hearts"
        case .diamonds:
            return "diamonds"
        case .clubs:
            return "clubs"
        }
    }

    func color() -> String {
        switch self{
        case .spades:
            return "Black"
        case .clubs:
            return "Black"
        case .hearts:
            return "Red"
        case .diamonds:
            return "Red"
        }
    }
}
let hearts = Suit.hearts
let heartsDescription = hearts.simpleDescription()
let heartsColor = hearts.color()
print(heartsDescription, heartsColor)   // hearts Red

/****************************************************/

enum ServerResponse {
    case result(String, String)
    case failure(String)
    case thirdDeath(String, Int)
}

let success = ServerResponse.result("6:00 am", "8:09 pm")
let failure = ServerResponse.failure("Out of cheese.")
let death = ServerResponse.thirdDeath("죽었습니다.", 3)

switch success {
case let .result(sunrise, sunset):
    print("Sunrise is at \(sunrise) and sunset is at \(sunset).")
case let .failure(message):
    print("Failure...  \(message)")
case let .thirdDeath(message, count):
    print("Death...  \(count)번 \(message)")
}   // Sunrise is at 6:00 am and sunset is at 8:09 pm.

// 실험 ServerResponse에 세번째 경우를 추가하고 스위치문에도 추가해보자.

/****************************************************/
```

* * *

**프로토콜**: 프로토콜은 메소드, 속성 그리고 다른 특정 작업 또는 기능의 부분에 맞는 요구 사항의 청사진을 정의합니다. 자바의 Interface와 유사한 개념입니다.

```
protocol ExampleProtocol {
    var simpleDescription: String { get }
    // 읽기 속성: { get }
    // 읽기, 쓰기 속성: { get set }
    mutating func adjust()
}

// 클래스, 열거형, 구조체 모두에 프로토콜을 사용할 수 있다.

class SimpleClass: ExampleProtocol {
    var simpleDescription: String = "A very simple class."
    var anotherProperty: Int = 69105
    func adjust() {
        simpleDescription += "  Now 100% adjusted."
    }
}
var a = SimpleClass()
a.adjust()
let aDescription = a.simpleDescription
print(aDescription) // A very simple class.  Now 100% adjusted.

struct SimpleStructure: ExampleProtocol {
    var simpleDescription: String = "A simple structure"
    mutating func adjust() {
        simpleDescription += " (adjusted)"
    }
}
var b = SimpleStructure()
b.adjust()
let bDescription = b.simpleDescription
print(bDescription) // A simple structure (adjusted)

// 실험: Add another requirement to ExampleProtocol. 
// What changes do you need to make to SimpleClass and SimpleStructure 
// so that they still conform to the protocol?

// mutating: 수정할 수 있음 (immutable한 메소드 앞에 사용)

// print(7.simpleDescription) // 에러: 'Int' has no member 'simpleDescription'
extension Int: ExampleProtocol {
    var simpleDescription: String {
        return "숫자는 \(self)입니다."
    }
    mutating func adjust() {
        self += 42
    }
}
print(7.simpleDescription)  // 숫자는 7입니다.
var num: Int = 30;
num.adjust()
print(num)  // 72

/****************************************************/

// 실험: extension을 사용해 Double 타입에 absoluteValue 속성을 추가해보자.
protocol NumberProtocol {
    var absoluteValue: Double { get }
}
extension Double: NumberProtocol{
    var absoluteValue: Double{
        return self < 0 ? self * (-1) : self
    }

}
print((-17.4).absoluteValue)    // 17.4

/****************************************************/

let protocolValue: ExampleProtocol = a
print(protocolValue.simpleDescription)
// Prints "A very simple class.  Now 100% adjusted."
// print(protocolValue.anotherProperty)  // Uncomment to see the error

// protocolValue는 SimpleClass의 런타입(a 객체)을 가지고 있지만,
// 컴파일러는 ExampleProtocol로 취급하므로
// anotherProperty(SimpleClass에 있음)은 사용할 수 없음

/****************************************************/

```

* * *

**에러 핸들링**

```
//=========== 에러 핸들링 1 ===========//

enum PrinterError: Error {
    case outOfPaper
    case noToner
    case onFire
}

func send(job: Int, toPrinter printerName: String) throws -> String {
    if printerName == "Never Has Toner" {
        throw PrinterError.noToner
    }
    return "Job sent"
}
do{
    let printerResponse2 = try send(job: 2, toPrinter: "Magenta Lover")
     print(printerResponse2)    // Job sent

    let printerResponse = try send(job: 1, toPrinter: "Never Has Toner")
    print(printerResponse) // 표시 안됨
   
} catch {
    print(error)    // noToner
}

// 실험: Add code to throw an error inside the do block. 
// What kind of error do you need to throw so that
// the error is handled by the first catch block? 
// What about the second and third blocks?

// throw PrinterError.onFire
// thorw PrinterError.outOfPaper

do {
   throw PrinterError.outOfPaper
} catch PrinterError.onFire {
    print("I'll just put this over here, with the rest of the fire.")
} catch let printerError as PrinterError {
    print("Printer error: \(printerError).")
} catch {
    print(error)
}

/****************************************************/

//=========== 에러 핸들링 2 ===========//

let printerSuccess = try? send(job: 1884, toPrinter: "Mergenthaler")    // Optional("Job sent")
let printerFailure = try? send(job: 1885, toPrinter: "Never Has Toner") // nil
print(printerSuccess, printerFailure)

var fridgeIsOpen = false
let fridgeContent = ["milk", "eggs", "leftovers", "rottenApple"]

func fridgeContains(_ food: String) throws -> Bool {
    fridgeIsOpen = true
    defer {
        print("여기는 DEFER")
        fridgeIsOpen = false
    }

    if food == "rottenApple"{        
        throw PrinterError.onFire
    }

    let result = fridgeContent.contains(food)
    return result
}
let openFridge = try? fridgeContains("rottenApple")
// 여기는 DEFER
print(openFridge)   // nil
print(fridgeIsOpen) // Prints "false"

/****************************************************/
```

* * *

**제너릭 타입**

```
//=========== 제너릭 타입 ===========//

func makeArray<Item>(repeating item: Item, numberOfTimes: Int) -> [Item] {
    var result = [Item]()
    for _ in 0..<numberOfTimes {
        result.append(item)
    }
    return result
}
let res1 = makeArray(repeating: "knock", numberOfTimes: 4)
print(res1) // ["knock", "knock", "knock", "knock"]

// Reimplement the Swift standard library's optional type
enum OptionalValue<Wrapped> {
    case none
    case some(Wrapped)
}
var possibleInteger: OptionalValue<Int> = .none
possibleInteger = .some(100)
print(possibleInteger)  // some("Strings")

var possibleString: OptionalValue<String> = .none
print(possibleString)   // none
possibleString = .some("Strings")
print(possibleString)   // some("Strings")

// where 절 넣기
func anyCommonElements<T: Sequence, U: Sequence>(_ lhs: T, _ rhs: U) -> Bool
    where T.Element: Equatable, T.Element == U.Element
{
    for lhsItem in lhs {
        for rhsItem in rhs {
            if lhsItem == rhsItem {
                return true
            }
        }
    }
    return false
}
print (anyCommonElements([1, 2, 3], [3]))   // true
print (anyCommonElements([1, 2, 3], [4]))  // false

// 실험: Modify the anyCommonElements(_:_:) function to
// make a function that returns an array of the elements
// that any two sequences have in common.
func anyCommonElements2<T: Sequence, U: Sequence>(_ lhs: T, _ rhs: U) -> [T.Element]
    where T.Element: Equatable, T.Element == U.Element
{
    var tempArr: [T.Element] = []   // 배열 만들기(Sequence 타입은 불가)
   
    for lhsItem in lhs {
        for rhsItem in rhs {
            if lhsItem == rhsItem {
                tempArr.append(lhsItem)
            }
        }
    }
    return tempArr
}

let common = anyCommonElements2([1, 2, 3, 4, 5], [3, 5])
print(common)   // [3, 5]
```
