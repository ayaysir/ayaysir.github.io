---
title: "자바스크립트 예제: 압축 (카카오 2018 코딩테스트 기출)"
date: 2020-05-25
categories: 
  - "DevLog"
  - "코딩테스트"
tags: 
  - "자바스크립트"
---

프로그래머스 사이트에서 [문제 풀기](https://programmers.co.kr/learn/courses/30/lessons/17684#)

![신입사원 어피치는 카카오톡으로 전송되는 메시지를 압축하여 전송 효율을 높이는 업무를 맡게 되었다. 메시지를 압축하더라도 전달되는 정보가 바뀌어서는 안 되므로, 압축 전의 정보를 완벽하게 복원 가능한 무손실 압축 알고리즘을 구현하기로 했다. 어피치는 여러 압축 알고리즘 중에서 성능이 좋고 구현이 간단한 LZW(Lempel–Ziv–Welch) 압축을 구현하기로 했다. LZW 압축은 1983년 발표된 알고리즘으로, 이미지 파일 포맷인 GIF 등 다양한 응용에서 사용되었다. LZW 압축은 다음 과정을 거친다. 길이가 1인 모든 단어를 포함하도록 사전을 초기화한다. 사전에서 현재 입력과 일치하는 가장 긴 문자열 w를 찾는다. w에 해당하는 사전의 색인 번호를 출력하고, 입력에서 w를 제거한다. 입력에서 처리되지 않은 다음 글자가 남아있다면(c), w+c에 해당하는 단어를 사전에 등록한다. 단계 2로 돌아간다. 압축 알고리즘이 영문 대문자만 처리한다고 할 때, 사전은 다음과 같이 초기화된다. 사전의 색인 번호는 정수값으로 주어지며, 1부터 시작한다고 하자. 색인 번호 1 2 3 … 24 25 26 단어 A B C … X Y Z 예를 들어 입력으로 KAKAO가 들어온다고 하자. 현재 사전에는 KAKAO의 첫 글자 K는 등록되어 있으나, 두 번째 글자까지인 KA는 없으므로, 첫 글자 K에 해당하는 색인 번호 11을 출력하고, 다음 글자인 A를 포함한 KA를 사전에 27 번째로 등록한다. 두 번째 글자 A는 사전에 있으나, 세 번째 글자까지인 AK는 사전에 없으므로, A의 색인 번호 1을 출력하고, AK를 사전에 28 번째로 등록한다. 세 번째 글자에서 시작하는 KA가 사전에 있으므로, KA에 해당하는 색인 번호 27을 출력하고, 다음 글자 O를 포함한 KAO를 29 번째로 등록한다. 마지막으로 처리되지 않은 글자 O에 해당하는 색인 번호 15를 출력한다. 현재 입력(w) 다음 글자(c) 출력 사전 추가(w+c) K A 11 27: KA A K 1 28: AK KA O 27 29: KAO O 15 이 과정을 거쳐 다섯 글자의 문장 KAKAO가 4개의 색인 번호 [11, 1, 27, 15]로 압축된다. 입력으로 TOBEORNOTTOBEORTOBEORNOT가 들어오면 다음과 같이 압축이 진행된다. 현재 입력(w) 다음 글자(c) 출력 사전 추가(w+c) T O 20 27: TO O B 15 28: OB B E 2 29: BE E O 5 30: EO O R 15 31: OR R N 18 32: RN N O 14 33: NO O T 15 34: OT T T 20 35: TT TO B 27 36: TOB BE O 29 37: BEO OR T 31 38: ORT TOB E 36 39: TOBE EO R 30 40: EOR RN O 32 41: RNO OT 34 입력 형식 입력으로 영문 대문자로만 이뤄진 문자열 msg가 주어진다. msg의 길이는 1 글자 이상, 1000 글자 이하이다. 출력 형식 주어진 문자열을 압축한 후의 사전 색인 번호를 배열로 출력하라. 입출력 예제 msg answer KAKAO [11, 1, 27, 15] TOBEORNOTTOBEORTOBEORNOT [20, 15, 2, 5, 15, 18, 14, 15, 20, 27, 29, 31, 36, 30, 32, 34] ABABABABABABABAB [1, 2, 27, 29, 28, 31, 30] 문제 해설 GIF 파일 등에서 실제로 쓰이는 LZW 알고리즘을 설명해주고, 구현하는 문제입니다. 실제로 쓰이는 알고리즘을 구현해보는 것이 어떠셨나요? 압축이라는 말만으로 얼핏 어려워 보이지만, 설명에 나온 의사코드Pseudocode를 그대로 따라서 구현만 하면 되는 문제로, 기초적인 문자열과 배열을 다룰 수 있다면 풀 수 있는 문제입니다. 이 문제의 정답률은 95.80%입니다. 가장 많은 지원자가 잘 풀어주셨습니다. 언어별로는 Java 언어 사용자들이 조금 어려워했습니다.](./assets/img/wp-content/uploads/2020/05/스크린샷-2020-05-25-오후-12.43.00.png)

 ![](/assets/img/wp-content/uploads/2020/05/스크린샷-2020-05-25-오후-12.43.49.png)

 ![](/assets/img/wp-content/uploads/2020/05/스크린샷-2020-05-25-오후-12.44.41.png) ![](/assets/img/wp-content/uploads/2020/05/스크린샷-2020-05-25-오후-12.45.48.png)

#### **코드**

```
function solution(msg) {
    var answer = [];
    
    // 사전 작성
    const dict = {}
    for(let i = 1; i <= 26; i++) {
        dict[String.fromCharCode(i + 64)] = i
    }
    let maxIdx = 26
    
    let idx = 0
    let msgLen = msg.length
    while(idx < msgLen) {
        let currentMaxStr = ""
        for(let j = idx; j < msgLen; j++) {
            const target = msg.substring(idx, j + 1)
            if(dict[target]) {
                currentMaxStr = target
            } else {
                dict[target] = ++maxIdx
                break
            }
        }
        answer.push(dict[currentMaxStr])
        // idx를 currentMaxStr 만큼 증가
        idx += currentMaxStr.length
    }
    
    return answer;
}
```

일단 정답 처리된 코드입니다. 밑에부터는 각 부분별 분석입니다.

* * *

#### **해설**

먼저 사전을 객체 형식으로 작성합니다. 문제에서는 `"A"` 부터 `"Z"`까지 사전이 미리 주어져 있다고 했으므로 그에 대한 사전을 작성합니다. key가 문자, value가 인덱스 번호이면 문제 풀기에 유리합니다. `String.fromCharCode(숫자)`는 해당 숫자의 아스키 코드 및 유니코드를 반환합니다. 예를 들어 `String.fromCharCode(65)`는 문자 `"A"`를 반환합니다.

`maxIdx` 변수는 현재 사전에서 최대 인덱스를 저장합니다. 객체 내에서 현재 최대 인덱스를 알아낼 수 있는 방법도 있겠지만 그냥 별도의 변수에서 따로 관리하는게 편할 것 같아서 분리했습니다.

```
// 사전 작성
const dict = {}
for(let i = 1; i <= 26; i++) {
    dict[String.fromCharCode(i + 64)] = i
}
let maxIdx = 26
```

 

다음 `msg` 문자 길이만큼 반복문을 돌면서 그 문자부터 시작해서 문자 끝까지 **2중 반복문**을 사용해 추출해 보겠습니다. 위의 정답코드와는 다른데 일단 `for`문을 사용해 보겠습니다.

```
for(let i = 0; i < msg.length; i++) {
    for(let j = i; j < msg.length; j++) {
        console.log(msg.substring(i, j + 1))
    }
}
```

 ![](/assets/img/wp-content/uploads/2020/05/스크린샷-2020-05-25-오후-1.04.59.png)

위와 같은 문자열들이 추출됩니다.

다음으로 저 2중 반복문을 순회하면서 사전에 문자열이 있다면 정답 배열에 집어넣고, 사전에 없는 문자열이라면 새로 추가하는 코드를 작성해 보겠습니다.

먼저 사전에 있다면 바로 정답에 집어넣지 않고 사전에 있는 더 긴 문자열이 있는지 확인하기 위해 `currentMaxStr` 이라는 변수를 만들겠습니다. 위 문제 예시 중  `"KAKAO"` 의 경우 3회전 부분에서 `"K"`도 사전에 있고, `"KA"`도 사전에 있는 경우 `"K"`는 중복 출력하지 않고 `"KA"` 만 출력해야 하기 때문입니다.

그리고 이 2중 반복문은 뒤로 갈수록 더 긴 문자열을 `target`으로 하므로 길이를 판별하는 별도의 조건은 없어도 됩니다.

```
for (let i = 0; i < msg.length; i++) {
    let currentMaxStr = ""
    for (let j = i; j < msg.length; j++) {
        const target = msg.substring(i, j + 1)
        if(dict[target]) { // 사전에 있는 문자열이라면
            currentMaxStr = target // 일단 바로 정답에 넣지 않고 더 긴 문자열이 있는지 보류
        } else {
            // 사전에 없는 값이면
            dict[target] = ++maxIdx // maxIdx를 1 증가 시킨 값을 인덱스로 하여 새로 사전에 추가
            break // 사전 추가 이후 더 진행되면 안되므로 현재 for문 중단
        }
        answer.push(dict[currentMaxStr])
    }
}
```

 

 ![](/assets/img/wp-content/uploads/2020/05/스크린샷-2020-05-25-오후-1.55.31.png)

이렇게 하면 뭔가 나오긴 하는데 문제에서 요구하는 것과 약간 다릅니다.

 ![](/assets/img/wp-content/uploads/2020/05/스크린샷-2020-05-25-오후-1.20.12.png)

중간에 1이 중복되어 나오는 것을 볼 수 있습니다. 제가 계속 해맸던 부분인데 2중 반복문에서 첫 반복문을 for문으로 쓰면 안됩니다.

 ![](/assets/img/wp-content/uploads/2020/05/스크린샷-2020-05-25-오후-1.04.59_.png)

위 그림에서 주황색 부분은 원래 출력이 되면 안되는데, 왜 되는 것일까요?

첫 번째 for문은 `i`가 1씩 증가하면서 모든 텍스트를 검사하고, 사전에 있으면 무조건 출력을 하도록 되어있는데 여기서 중복된 출력을 검사할 부분이 없어서 문제가 생기는 것입니다. 예를 들어 `"KA"`가 사전에 있으면 다음 `"A"`는 애초에 `"KA"`에 포함된 부분이므로 검사할 필요 없이 패스해야 됩니다.

이것을 해결하는 방법은 여러 가지가 있겠지만, 저는 첫 번째 반복문을 for에서 `while`문으로 변경한 뒤, 현재 사전에 있는 최대 글자만큼 인덱스를 증가시키는 방법을 사용했더니 정상적으로 작동을 했습니다.

```
let idx = 0
const msgLen = msg.length
while (idx < msgLen) {
    let currentMaxStr = ""
    for (let j = idx; j < msgLen; j++) {
        const target = msg.substring(idx, j + 1)
        if (dict[target]) { // 사전에 있는 문자열이라면
            currentMaxStr = target // 일단 바로 정답에 넣지 않고 더 긴 문자열이 있는지 보류
        } else {
            // 사전에 없는 값이면
            dict[target] = ++maxIdx // maxIdx를 1 증가 시킨 값을 인덱스로 하여 새로 사전에 추가
            break // 사전 추가 이후 더 진행되면 안되므로 현재 for문 중단
        }
    }
    answer.push(dict[currentMaxStr])
    idx += currentMaxStr.length // idx를 현재 사전에 있는 최대 길이만큼 증가
}
```

 ![](/assets/img/wp-content/uploads/2020/05/스크린샷-2020-05-25-오후-2.00.37.png)

이렇게 하면 정답이 나온 것을 확인할 수 있습니다.
