---
title: "격투 게임이 지연 기반 넷코드 및 롤백 넷코드를 사용하는 방법에 대한 설명 2 - 롤백(Rollback) 넷코드"
date: 2022-03-14
categories: 
  - "DevLog"
  - "Game"
---

\[rcblock id="4252"\]

#### **롤백 넷코드 (Rollback Netcode)**

게임의 넷코드 선택에도 불구하고 플레이어와 상대 간의 거리를 단번에 바꿀 수 없고, 네트워크가 정보를 누락하거나 지연(delay)시키는 것을 막을 수 없기 때문에 어떻게 롤백 넷코드 전략이 다른 것보다 훨씬 더 나을 수 있는지 궁금할 수 있습니다. 관건은 넷코드가 불확실성을 어떻게 처리하느냐에 있습니다.

원격 플레이어로부터 정보가 없을 때는 이전 [포스트](http://yoonbumtae.com/?p=4224)에서 자세히 설명한 대로 일시 중지하고 기다려야 합니다. 롤백의 가장 큰 장점은 상대의 입력 누락을 절대 기다리지 않는다는 것입니다. 대신 롤백 넷코드는 게임을 계속 정상적으로 실행합니다. 로컬 플레이어의 모든 입력은 마치 오프라인인 것처럼 즉시 처리됩니다. 그런 다음 몇 프레임 후에 원격 플레이어로부터의 입력이 들어오면 롤백을 통해 과거를 수정함으로써 오류를 바로잡습니다. 이는 로컬 플레이어가 네트워크 불안정성의 상당 부분을 알아차리지 못할 정도로 정교한 방식으로 수행되며, 입력이 항상 일관되게 처리된다는 확신을 갖고 나머지 단계를 플레이할 수 있습니다.

그 "롤백"이 무엇인지부터 살펴보겠습니다.

 

#### **선 조치 후 사과 (Act now, apologize later)**

원격 입력 신호가 없다면 롤백 넷코드가 게임을 계속 시뮬레이션합니다. 그러다가 결국 (발견되지 못했던) 그 입력이 들어오면 상대방이 그 버튼을 눌렀을 때를 지나 게임이 진행되어 이미 화면에 다른 결과를 보여주게 됩니다.이 문제를 해결하기 위해 롤백 넷코드는 시뮬레이션을 되돌리고 올바른 입력을 적용한 다음 플레이어에게 즉시 새로운 결과를 표시합니다.

아래 예에서 로컬 플레이어와 원격 플레이어 모두 `프레임 1`에서 중간 주먹(meidum punch)을 누르지만 상대방의 입력이 네트워크를 통해 지연되고 `프레임 4`에서 3프레임 후에 도달한다고 가정해 보겠습니다. 오프라인 플레이처럼 로컬 플레아어의 움직임이 곧바로 화면에서 애니메이션을 시작하고, 상대방이 아무것도 하지 않았다고 가정하고 아무 일 없다는 듯이 게임이 이어집니다. `프레임 4`에서는 `프레임 1`에서 눌린 것으로 표시된 상대방의 입력이 마침내 도착합니다. 이것은 우리가 지난 3개의 프레임에서 플레이어에게 보여준 것이 실제로 일어난 것이 아니라는 것을 의미하며, 게임은 백그라운드에서 몇 가지 계산을 수행하여 과거를 개변해야 합니다.

먼저, 게임 상태는 `프레임 1` 이전의 상태로 다시 로드됩니다. 즉, 입력을 적용해야 하는 이전의 몇 프레임 전으로 "롤백"됩니다. 그런 다음 원격 플레이어로부터의 입력과 더불어, 과거 프레임에서 로컬 플레이어가 눌렀던 입력 모두가 적용되고, 게임은 여러 프레임을 다시 시뮬레이션(re-simulate)하여 현재 프레임에 다시 도달합니다.

 

<iframe width="480" height="270" src="https://giphy.com/embed/LPYYEf6vuN4fNKulCQ" frameborder="0" class="giphy-embed" allowfullscreen="allowfullscreen"></iframe>

_원격 플레이어의 Jago(오른쪽 캐릭터)는 `프레임 1`에서 MP(medium punch)를 누릅니다. 그 입력이 도달했을 때, 우리는 이미 `프레임 4`에 있습니다. 그래서 우리는 `프레임 1`로 되감고, Jago가 MP를 누르도록 한 다음, 매우 빠르게 `프레임 4`로 다시 시뮬레이션을 해야 합니다. 주황색 인디케이터와 "고스트" 버전의 Jago는 플레이어가 절대 볼 수 없는 백그라운드 계산을 나타냅니다. 30%의 속도에서, 로컬 플레이어는 단지 Jago의 MP가 시작될 때 몇 프레임 동안 나타나는 것을 볼 뿐입니다._[](https://giphy.com/gifs/LPYYEf6vuN4fNKulCQ)

 

이 모든 것이 하나의 게임 프레임에서 즉시 발생합니다. 로컬 플레이어는 게임이 이러한 단계를 개별적으로 수행하는 것을 절대 볼 수 없습니다. 대신 그들이 보는 것은 그들이 원래 그렇다고 생각한(그러나 거짓이었다) 게임 상태가 실제로 정확한 게임 상태로 즉시 대체된다는 것입니다. 게임에서 일어나는 일에 따라 캐릭터가 갑자기 약간 튀어보일 수 있으며 일반적으로 원격 플레이어의 움직임에 대한 애니메이션은 로컬 플레이어에게 표시될 때 시작 시 이미 몇 프레임으로 나타나는 경향이 있습니다.

 

<iframe width="480" height="270" src="https://giphy.com/embed/grSymnUeeVUQ9UYUD6" frameborder="0" class="giphy-embed" allowfullscreen="allowfullscreen"></iframe>

_Jago는 머리 위로 공격합니다. 영상은 Jago가 공격했을 때 0, 1, 2, 3 프레임의 롤백을 하는 동작을 보여주는데, 이 프레임은 이동 시작 시 동일한 수의 프레임을 깎아줍니다(shave). 심지어 30%의 속도에서도 차이를 구별하기 어렵습니다._

 

다시 말해서, 롤백은 각 클라이언트가 일시적으로 락스텝 모델을 해제하도록 합니다. 로컬과 원격의 각 게임은 연결 품질과 롤백 시점에 일어나는 일에 따라 각 플레이어에게 약간 다른 것을 보여줄 수 있습니다. 그러나 게임은 입력이 몇 프레임 후에 수신될 때마다 항상 두 플레이어에게 모두 동일하도록 수정됩니다.

롤백 넷코드의 이 중요한 속성을 반복할 가치가 있습니다. 로컬 플레이어의 입력은 항상 즉시 표시되며 취소할 수 없습니다. `프레임 4`에서 버튼을 누르면 해당 정보가 게임에서 즉시 처리되고 움직임이 즉시 화면에 나타납니다. 해당 버튼을 눌렀을 때 롤백이 발생하면 롤백 계산을 통해 항상 올바르게 다시 적용됩니다. 또한 게임이 원격 입력을 기다리고 있고 두 플레이어 모두에게 응답이 없을 때 지연 기반 넷코드 프레임워크에서 발생할 수 있는 네트워크 지연(lag)으로 인해 입력이 무효화되거나 먹히(eaten)는 경우는 없습니다. 따라서 플레이어는 네트워크 품질과 상관없이 자신이 누르는 버튼이 실행될 것이라는 확신을 가질 수 있어 온라인 플레이의 일관성을 크게 높일 수 있습니다.

추가적인 이점으로, 게임에 네트워크 문제가 발생하면 스파이크가 발생한 직후에만 롤백이 발생하므로 매우 로컬화된(localized) 접근 방식이 됩니다. 지연 기반 솔루션에서 게임은 입력 지연을 몇 초 동안 부풀려 문제가 오랜 시간 누적되는 나비효과를 유발할 수 있습니다. 롤백 넷코드는 이러한 이유로 Wi-Fi와 같이 패킷 손실 가능성이 높은 연결에 특히 좋습니다.

이것이 롤백의 핵심 개념입니다. 하지만 여기서 더 향상될 수 있습니다.

 

\[the\_ad id="3513"\]

 

#### **예측의 기초**

위의 예에서, 원격 플레이어에 대한 입력이 누락되었을 때, 우리는 단순히 게임이 시뮬레이션할 수 있도록 (그 입력된 누락이) 아무것도 입력하지 않는다고 가정했습니다. 이것은 일반적으로 꽤 나쁜 가정인데, 플레이어들이 아무것도 하지 않는 경우는 드물고, 롤백을 하기 바로 전에 플레이어에게 보이는 시각적 상태는 거의 항상 부정확하기 때문입니다. 알고 보면, 우리는 놀라운 정확도로 상대방이 무엇을 하는지 예측할 수 있습니다.

입력이 누락된 경우 롤백 솔루션은 현재 누락된 프레임에 대해 원격 플레이어에서 마지막으로 알려진 입력을 복제합니다. 만약 그들이 다운백(down-back)이었다면, 게임은 그들이 계속해서 다운백 할 것이라고 예측합니다. 만약 그들이 버튼을 누르고 있다면, 게임은 그들이 여전히 버튼을 누르고 있다고 가정합니다. 그런 다음 게임은 원격 플레이어의 예측된 입력값으로 실행됩니다.

(참고: 이러한 예제 비디오를 최대한 이해하기 쉽게 유지하기 위해 네트워크 전송 시간이 즉각적이며, 프레임이 누락되는 이유가 네트워크에 잠시 과부하가 걸리기 때문이라고 일시적으로 가정하겠습니다. 걱정하지 마세요, 개념은 네트워크 지연과 함께 여전히 완벽하게 작동하지만, 영상은 조금 혼란스러울 것입니다.)

 

<iframe width="480" height="270" src="https://giphy.com/embed/0rfzmMth1C01K68CBI" frameborder="0" class="giphy-embed" allowfullscreen="allowfullscreen"></iframe>

[](https://giphy.com/gifs/0rfzmMth1C01K68CBI)

_원격 플레이어의 Fulgore(오른쪽 캐릭터)에 대한 입력은 `프레임 3` 이후에 손실되지만 롤백 모델에서 게임은 게임을 계속 진행시키기 위해 마지막으로 알려진 입력을 복제합니다. 예상 프레임은 주황색으로 표시되고 마지막으로 알려진 입력은 `프레임 3`의 입력 상자 아래에 주황색 캐럿_(▴)_으로 표시됩니다._

 

실제의 정확한 원격 입력이 몇 프레임 후에 도착하면 게임은 이를 사용하는 방법을 결정해야 합니다. 입력이 잘못된 경우 이전에 설명된 대로 롤백을 수행합니다. 게임은 이전 게임 상태로 되감고 새 입력을 사용하여 이수 상황을 다시 시뮬레이션 및 재예측합니다. 그러나 이러한 입력이 정확히 예측된 것과 같다면(예를 들어, 플레이어가 실제로 계속 다운백을 유지한 경우) 롤백이 발생할 필요가 없습니다. 예측 기간 동안 플레이어에게 보여주던 게임이 맞았습니다! 게임은 단순히 원격 플레이어의 마지막 올바른 입력으로 알고 있는 것을 업데이트하고 로컬 플레이어는 아무 것도 잘못되었다는 것을 모릅니다. 게임이 입력을 올바르게 예측하면 롤백은 네트워크 문제가 있더라도 게임이 완벽하게 느껴지도록 합니다.

 

<iframe width="480" height="270" src="https://giphy.com/embed/smMcpzK4zVEdipE795" frameborder="0" class="giphy-embed" allowfullscreen="allowfullscreen"></iframe>

[](https://giphy.com/gifs/smMcpzK4zVEdipE795)

_원격 플레이어의 Fulgore(오른쪽 캐릭터)에 대한 입력은 다시 `프레임 3` 이후에 손실됩니다. 입력은 결국 `프레임 8`에서 한꺼번에 들어왔는데 Fulgore는 실제로 우리의 예측과 같이 앞으로 유지되었습니다. 게임은 이것이 사실인지 빠르게 확인한 결과 롤백할 필요가 없으므로 계속 진행됩니다._

 

예측은 롤백 넷코드 패러다임에 비교적 기본적인 추가이지만 파급력은 큽니다. 원격 플레이어가 예상치 못한 행동을 했을 경우에만 경기를 롤백하고 재시뮬레이션하는 것은 미묘한 장점이 많아 좀 더 논의해야 합니다. 이는 처음에 생각하는 것보다 연결 불량으로 인한 영향을 감추는 것에 있어 더 많은 기능을 합니다.

 

#### **예측이 좋은 이유**

롤백의 "예측" 버전은 1인칭 슈팅 게임과 같은 다른 장르를 플레이할 때 예상할 수 있는 것만큼 발전되지 않았습니다. 언급했듯이, 원격 플레이어가 네트워크로부터 정보를 마지막으로 수신했을 때 입력 정보를 변경하지 않았다고 가정하는 것이 실제로 하는 일입니다.

결과적으로 플레이어가 실제로 입력을 얼마나 자주 변경하는지 분석한다면 이것은 매우 합리적인 가정입니다. 선수들이 앞뒤로 왔다 갔다 하는 스트리트 파이터와 같은 게임의 시합에서 한 선수가 1초에 5번 정도 이동 방향을 바꾼다고 가정해 봅시다. 이것은 특히 활동적인 프로 플레이어들에게도 잘 적용되는 범위입니다. 즉, 주어진 1초 동안 60개 프레임 중 5개 프레임에 대한 원격 플레이어의 입력만 필요합니다 (1초의 8% 정도로 엄청 낮음). 나머지 55프레임에 대한 플레이어의 입력은 이전 프레임과 동일하다고 가정하는 것만으로도 높은 정확도로 예측할 수 있습니다.

그리고 이것은 전형적으로 시합에서 가장 활동적인 부분입니다. 상대를 넘어뜨리고 압박하려 한다면 수비수가 30, 60, 120프레임 연속 다운백(down-back)을 잡는 것은 흔한 일입니다. 상대가 점프할 경우 45프레임 정도 공중에 떠 있는 상태이며 전체 시간 동안 하나의 버튼만 누를 가능성이 높습니다. 상대가 계속 누르고 있거나 버튼을 계속 누르지 않을 것이라는 프레임별 예측이 95%의 시간이 맞는다면 네트워크가 이를 알려줄 때까지 기다려야 하는 이유가 있을까요?

이것이 의미하는 바는 원격 입력이 변경되지 않은 이러한 순간에 네트워크 스파이크가 발생하면 두 플레이어 모두에게 완전히 보이지 않는다는 것입니다. 정보가 초당 여러 번 늦게 도착할 수 있는 모호한 연결에서도, 이러한 지연의 상당한 부분은 원격 플레이어가 입력을 변경하지 않는 순간과 무작위로 일치합니다. 지연 기반 게임은 여기서 일시 중지하고 기다려야 하지만 롤백 게임은 정보가 도착할 때 입력이 올바른지 확인하고 아무것도 변경할 필요가 없기 때문에 연결이 완벽하게 보이는 것입니다.

 

#### **롤백은 게임 상태를 고려한다**

롤백이 잘못된 연결을 숨기는 더 많은 방법이 있습니다. 경기 중 언제든 문제가 발생할 수 있는 지연 기반 솔루션과 달리 롤백 방식은 원격 플레이어의 새로운 입력이 게임 상태를 변경한 경우에만 시각적 변화를 보여줍니다.

동영상으로 예를 들어 설명하겠습니다. 여기에서 Jago를 플레이하는 원격 상대 플레이어는 `프레임 2`에서 강펀치(heavy punch)를 날리고 게임은 네트워크를 통해 이 입력을 수신한 뒤 움직임을 애니메이션하기 시작합니다. 강펀치를 누른 직후(`프레임 4`)에 엄청난 네트워크 스파이크가 발생하고 다음 5개 프레임에 대한 모든 정보가 제시간에 도착하지 않습니다. 설명된 대로 롤백은 상관하지 않습니다. 어쨌든 게임을 계속 시뮬레이션할 것입니다. 이 경우 Jago는 마지막으로 알려진 프레임의 강펀치 버튼에서 손가락을 떼었기 때문에 아무 것도 입력하지 않는다고 가정합니다.

`프레임 8`에서 이 누락된 5개 프레임(`프레임 4 ~ 8`)에 대한 모든 정보가 쏟아들어오고, 결과적으로 상대방은 버튼을 마구잡이로 누르고 있었습니다. 이것은 우리가 예측한 것이 아니므로 강펀치가 시작될 때까지 게임을 5프레임 되감고 올바른 입력으로 이 5프레임을 다시 시뮬레이션하고 플레이어에게 실제 게임 상태를 보여주어야 합니다.

 

<iframe width="480" height="270" src="https://giphy.com/embed/OdzttyY9nWbBVuVPcN" frameborder="0" class="giphy-embed" allowfullscreen="allowfullscreen"></iframe>

[](https://giphy.com/gifs/OdzttyY9nWbBVuVPcN)

_Jago(오른쪽 캐릭터)가 HP(heavy punch)를 누르지만, 그 후 입력이 잠시 손실됩니다. 롤백은 어쨌든 계속 시뮬레이션합니다. 그 입력값들이 들어왔을 때 Jago는 버튼을 눌렀다는 것이 밝혀졌습니다. 예측과 일치하지 않으므로 롤백하고 다시 시뮬레이션해야 합니다. 그러나 최종 결과는 동일하므로 플레이어들은 네트워크 문제가 있는지 전혀 모릅니다._

 

하지만 상대가 헛손질(whiffing) 중이었기 때문에 게임의 규칙에 따르면 지금은 자신의 캐릭터를 제어할 수 없다고 말합니다. 이러한 새 입력은 게임 상태에 대해 아무 것도 변경하지 않았습니다! 게임을 롤백하고 여러 프레임을 다시 시뮬레이션했지만 최종 결과는 화면에 표시된 것과 같았고 다시 한 번 두 플레이어 모두 지연이 완전히 보이지 않습니다.

이전 섹션에서와 같이 경기 중에 상대방의 입력이 게임 상태를 변경할 수 없는 경우를 항상 생각하십시오. 이것은 게임에 따라 다르지만 일반적으로 넘어지거나, 콤보가 될 때, 블록 기절 상태에서, 움직임이 시작될 때, 회복 중이거나 헛손질을 할 때 등 많은 시간이 포함됩니다. 이러한 작업을 완료하는 데 걸리는 프레임 수도 짧지 않습니다. 스트리트 파이터 게임에서 하드 넉다운(hard knockdown)은 60프레임이 소요될 수 있고, 헤비 어택(heavy attack)은 30프레임 이상이 소요될 수 있으며, 콤보(combo)는 10초 이상 지속될 수 있습니다! 게임이 이러한 작업의 시작을 올바르게 등록했다면, 이 기간 동안 게임이 격렬하게 롤백되더라도 상대가 게임 상태를 다시 변경할 수 있을 때까지 지연에 대해 완전히 면역이 됩니다.

이것을 예측 모델과 함께 사용하면 전투 중에 지연이 "흡수"되는 빈도를 볼 수 있습니다. 연결 문제는 사라지지 않았지만, 롤백 솔루션은 최대한 자주 이를 무시하는 것이 가장 효과적이며, 가장 느린 연결도 플레이 가능한 것처럼 느끼게 할 수 있습니다. Killer Instinct(게임명)의 경우 200ms 핑에 접근하는 연결을 통해 싱가포르와 미국 동부 간에 온라인 세트를 플레이할 수 있습니다. 이는 지연 기반 넷코드로는 불가능에 가까운 일입니다.

 

\[the\_ad id="1801"\]

 

#### **지연 기반 넷코드와 롤백 넷코드는 명확히 구분되는가?**

실제 상황에서 입력은 항상 네트워크를 통해 전송하는 데 시간이 걸립니다. 즉, 모든 입력은 항상 의도한 프레임 후에 도착합니다. 이것은 입력이 상태를 변경하는 한 버튼을 누르거나 방향을 변경할 때마다 항상 약간의 롤백이 발생한다는 것을 의미한다고 볼 수 있습니다.

결과적으로 지연 기반 솔루션과 롤백 솔루션을 결합하여 이러한 문제를 해결할 수 있습니다. 사실, 롤백을 사용하는 모든 현대 격투 게임은 지연 기반 프레임워크를 기반으로 구축되며 지연은 시작 시 고정되고 절대 변경되지 않는다는 중요한 경고가 있습니다. 당신이 적절하게 작은 지연값을 선택하고 고정하면 모든 상태 변경 시 롤백을 트리거할 필요 없이 "많은" 상대 입력이 사용자에게 도달할 수 있는 충분한 시간이 주어집니다. 네트워크 스파이크가 있는 경우 입력 지연을 늘리거나 일시 중지 또는 대기하지 않고, 롤백이 (선택된 지연 시간보다 더 오래 걸리는) 그 입력들을 대신합니다. 지연이 작고 일관성이 있는 한 플레이어는 빠르게 적응할 것이며 많은 사람들은 오프라인 플레이와 차이를 알아차리지 못할 것입니다.

이 지연 프레임의 설정 가능 여부는 개발자의 재량에 달려 있습니다. 3rd Strike Online Edition, Darkstalkers Resurrection, Skullgirls 및 Samurai Shodown V Special과 같은 일부 게임에서는 사용자가 일반적으로 0에서 8프레임 사이의 지연을 설정할 수 있습니다. 킬러 인스팅트(Killer Instinct) 및 인저스티스 2(Injustice 2)와 같은 다른 게임은 보편적으로 모든 플레이어의 숫자(이 게임의 경우 3프레임)를 선택하고 변경할 수 있는 옵션을 제공하지 않습니다.

 

\[caption id="attachment\_4236" align="alignnone" width="641"\] ![](/assets/img/wp-content/uploads/2022/03/skullgirlsggpo.jpg) Skullgirls(게임명)는 각 사용자가 원하는 입력 지연 프레임 수를 수동으로 선택할 수 있습니다. 롤백은 네트워크 지연이 이 숫자보다 큰 경우에만 시작됩니다.\[/caption\]

 

두 방법 모두 장단점이 있습니다. 사용자가 자신의 지연을 선택할 수 있다는 것은 연결 강도를 고려하고 그에 맞게 지연을 조정할 수 있음을 의미합니다. 그러나 이는 또한 롤백이 어떻게 작동하는지 또는 이 설정이 제어하는 것을 이해하지 못하는 플레이어가 연결 및 경험에 부적합한 설정을 선택할 가능성이 훨씬 더 높다는 것을 의미합니다. 지연을 항상 일관되게 강제하면 일부 시합에는 이론적으로 필요한 것보다 약간 더 지연이 있음을 의미할 수 있지만, 모든 연결에서 일관성을 얻을 수 있습니다. 일부 개발자는 플레이어에게 서로 다른 연결에서 서로 다른(안정적이지만) 지연에 대한 반응을 조정하도록 요청하는 것이 대부분의 연결에 적합한 설정을 항상 사용하는 것보다 더 많은 단점을 가지고 있다고 느낄 수 있습니다.

 

#### **롤백의 이점 요약**

롤백은 순수한 지연 기반 솔루션을 괴롭히는 일관성 문제를 크게 해결합니다. 로컬 플레이어는 네트워크 문제의 영향을 받지 않으므로 입력이 항상 같은 방식으로 처리됩니다. 특정 녹다운 설정을 수행하려고 하거나 매우 촉박한 타이밍이 필요한 콤보가 있는 경우 롤백을 사용하면 지연에 관계없이 항상 동일한 방식으로 실행할 수 있습니다. 네트워크 스파이크가 발생하면 경기의 현재 순간에만 영향을 미치는 반면 지연 기반 게임은 입력 지연을 몇 초 동안 부풀리고 망가트릴 수 있습니다.

네트워크 불안정 또는 지연의 상당 부분은 롤백 넷코드를 사용할 때 두 플레이어 모두에게 보이지 않게 됩니다. 원격 플레이어가 캐릭터에 일어나는 일을 변경할 수 없거나 이전 프레임의 동작(또는 무동작)을 반복하기로 선택할 때마다 롤백 시스템은 시각적 변화를 일으키지 않으며 그 시간 동안 네트워킹 문제가 사라집니다. 이것은 또한 상대방이 던진 장풍과 같은 것들에도 영향을 미칩니다. 일단 던지면 상대방은 궤적을 변경하기 위해 아무 것도 할 수 없으며 화면을 가로지르는 경로는 롤백 및 네트워크 문제에 영향을 받지 않으므로 오프라인 타이밍으로 차단하거나 점프할 수 있습니다.

롤백은 격투 게임에서 지연을 숨기기 위한 최고의 솔루션입니다. 하지만 이제 롤백 넷코드를 게임에 적용하는 데 필요한 사항에 대해 이야기할 때입니다.

 

 

* * *

(계속)

\[rcblock id="4252"\]
