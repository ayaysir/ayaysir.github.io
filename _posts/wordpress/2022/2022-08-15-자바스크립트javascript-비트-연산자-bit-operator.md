---
title: "자바스크립트(JavaScript): 비트 연산자 (Bit Operator)"
date: 2022-08-15
categories: 
  - "DevLog"
  - "JavaScript"
---

### **자바스크립트(JavaScript): 비트 연산자 (Bit Operator)**

비트 연산자란 2진수(binary)를 연산할 때 사용하는 연산자입니다.

예를 들어 십진법으로 표기한 정수 `70`을 이진법 표기로 변환하면

 ![](/assets/img/wp-content/uploads/2022/08/binary1.webp)

`1000110B` 가 되는데, 이 이진법으로 변환된 값을 기준으로 연산을 수행하는 연산자가 비트 연산자입니다.

이하 별도의 표기법이 없는 경우는 전부 십진법 숫자이며, 이진법은 (`이진법: 숫자`) 또는 숫자 뒤에 `B`가 붙어 있습니다.

 

#### **1: AND( `&` ) 연산**

`AND` 연산은 두 개의 숫자(값이)를 각 비트마다 `AND` 연산합니다. `AND` 연산은 곱연산으로 두 비트가 모두 `1`일 경우에만 `1`를 반환하며, 두 비트 중 하나라도 `0`이라면 `0`를 반환합니다.

- `1 & 1 = 1`
- `1 & 0 = 0`
- `0 & 1 = 0`
- `0 & 0 = 0`

 

`70(1000110B)`과 `54(110110B)`의 `AND` 연산을 수행해 보겠습니다.

```
console.log(70 & 54)
// 결과: 6
```

왜 `6(110B)`이 나올까요? 70과 60을 이진법으로 변환시킨 뒤 계산해보면 이해할 수 있습니다.

 ![](/assets/img/wp-content/uploads/2022/08/스크린샷-2022-08-16-오전-1.53.15.png)

위 표처럼 십진법을 이진법으로 변환시킨 뒤, 각 자릿수마다 `AND` 연산을 한 뒤 나온 비트들을 다시 십진법 표기로 변환하면 6이 나오는 것을 알 수 있습니다.

 

##### **예제: 특정 자리의 비트수가 1인지 확인**

`AND` 연산은 양쪽 모두가 `1`인 경우 외에는 전부 `0`을 반환합니다. 이 속성을 이용해 숫자의 어떤 자리수가 `1`인지 여부를 확인할 수 있습니다.

`204(11001100B)`의 각 자릿수가 1인지 확인하기

```
for(let i = 0; i < 8 ; i++) {
    const digit = (8 - 1) - i
    const powed = Math.pow(2, digit)
    console.log(digit, (powed & 204) != 0)
}

```

 ![](/assets/img/wp-content/uploads/2022/08/스크린샷-2022-08-16-오전-2.03.08.png)

 

`204`와 `2^7 = 128(1000 0000B)`를 `AND` 연산하면 맨 앞의 `1`을 제외하고는 공통되는 비트가 없으므로 나머지는 전부 `0`이 됩니다. 따라서 `204 & 128`의 연산 결과는 `128(1000 0000B)`이 됩니다.

 ![](/assets/img/wp-content/uploads/2022/08/스크린샷-2022-08-16-오전-2.06.37.png)

`204`와 `2^5 = 32(0010 0000B)`를 `AND` 연산하면 공통되는 부분이 하나도 없으므로 연산 결과는 `0`이 됩니다.

위의 패턴으로 볼 때 각 자리값마다 연산 결과가 `0`이 아닌 경우 해당 자릿수는 `1`이므로 `true`, 아니라면 `false`를 반환합니다.

[비트 필드](https://ko.wikipedia.org/wiki/%EB%B9%84%ED%8A%B8_%ED%95%84%EB%93%9C) 또는 비트 플래그라 불리는 데이터 저장 기법이 있는데, 비트 필드를 사용할 때 체크 여부를 이러한 `AND` 연산으로 판별합니다.

 

#### **2: OR( `|` ) 연산**

`OR` 연산은 두 개의 숫자를 각 비트마다 `OR` 연산합니다. `OR` 연산은 합연산으로 두 비트 중  하나라도 `1`일 경우에는 `1`를 반환하며, 두 비트가 모두 `0`인 경우에만 `0`를 반환합니다.

- `1 | 1 = 1`
- `1 | 0 = 1`
- `0 | 1 = 1`
- `0 | 0 = 0`

 

`70(1000110B)`과 `54(110110B)`의 `OR` 연산을 수행해 보겠습니다.

```
console.log(70 | 54) 
// 결과: 118
```

AND 연산과 달리 `118(111 0110B)`이 나오는 이유는 아래 그림을 보면 알 수 있습니다.

 ![](/assets/img/wp-content/uploads/2022/08/스크린샷-2022-08-16-오전-2.15.03.png)

 

#### **3: XOR( `^` ) 연산 - Exclusive OR**

두 비트의 값이 같은 경우 `0`를 반환하며, 두 비트값이 다른 경우에는 `1`를 반환합니다.

참고로 두 값을 더한 뒤 `mod(%) 2`를 했을때의 값과 동일합니다.

- `1 ^ 1 = 0`
- `1 ^ 0 = 1`
- `0 ^ 1 = 1`
- `0 ^ 0 = 0`

 

`70(1000110B)`과 `54(110110B)`의 `XOR` 연산을 수행해 보겠습니다.

```
console.log(70 ^ 54) 
// 결과: 112
```

`70 ^ 54 = 112 (111 0000B)`

 ![](/assets/img/wp-content/uploads/2022/08/스크린샷-2022-08-16-오전-2.54.49.jpg)

 

#### **4: NOT( `~` ) 연산**

`NOT` 연산은 `1`을 `0`으로, `0`을 `1`로 반전시킵니다.

자바스크립트 내에서 음수의 비트 표기법에 의해 `NOT` 연산자를 수행하면 해당 양수/음수 부호와 반대되는 값이 나옵니다.

[모질라 문서 Bitwise NOT (~) 참고](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_NOT)

 

#### **5: 왼쪽(`<<`) / 오른쪽(`>>`) SHIFT 연산**

왼쪽 `SHIFT (<<)` 연산자는 모든 비트를 왼쪽으로 _x_ 칸씩 이동시킵니다. 이동 범위를 초과하는 값은 버려지고, 새로 생긴 빈 칸은 `0`으로 채워집니다.

 

아래 코드는 `70(1000110B)`의 모든 비트를 왼쪽으로 `2`칸씩 이동하라는 의미로, 결과는 `280(1 0001 1000B)`이 나옵니다. 왼쪽으로 2칸씩 이동하면서 새로 생긴 끝의 2자리는 `0`으로 채워집니다.

```
console.log(70 << 2) 
// 결과: 280
```

 ![](/assets/img/wp-content/uploads/2022/08/스크린샷-2022-08-16-오전-2.39.54.png)

 

오른쪽 `SHIFT (>>)` 연산자는 모든 비트를 오른쪽으로 _x_ 칸씩 이동시킵니다. 이동 범위를 초과하는 부분은 버려집니다.

 

아래 코드는 `70(1000110B)`의 모든 비트를 오른쪽으로 2칸씩 이동하라는 의미로, 결과는 `17(10001B)`이 나옵니다.오른쪽으로 2칸씩 이동하면서 맨 끝자리 2개의 비트는 버려집니다..

```
console.log(70 >> 2) 
// 결과: 17
```

 ![](/assets/img/wp-content/uploads/2022/08/스크린샷-2022-08-16-오전-2.44.37.png)
