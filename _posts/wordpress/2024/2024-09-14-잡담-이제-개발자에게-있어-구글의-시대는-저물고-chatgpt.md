---
title: "[잡담] 이제 개발자에게 있어 구글의 시대는 저물고 ChatGPT의 시대가 도래했음을 느낌"
date: 2024-09-14
categories: 
  - "DevLog"
  - "diary.dev"
---

#### **잡담**

최근 구글이 개발자들 사이에서 소외되고 있다는 이야기에 전적으로 공감합니다. 저도 요즘에 [ChatGPT](https://openai.com/chatgpt/)를 개발에 활용하면서 여러 가지를 느꼈습니다.

ChatGPT 3.5 버전까지는 원하는 답을 정확하게 얻기가 어려워서 가끔 재미 삼아 사용하는 정도였으며, 개발 보조 도구로 사용하기도 어려울 정도였습니다. 하지만 ChatGPT 4o으로 업그레이드된 이후에는 한글로 질문해도 척척 알아듣고, 약 80% 정도는 제가 원하는 답을 정확하게 제공하는 느낌입니다.

특히, 일반적인 구글 검색과 가장 큰 차이점은 영어로 된 정보도 알아서 한국어로 번역하거나 생성하여 제공해 준다는 점입니다. 그리고 원하는 맥락에 맞춰서 답변을 도출해 주는 것이 매우 인상적이며 구글 검색과 차별되는 큰 특징 중 하나라고 생각합니다.

제가 5년 이상 개발 관련 블로그를 운영하면서도 구글의 영향력이 줄어들고 있다는 것을 몸소 체감하고 있습니다. ChatGPT가 이 정도인데, [Copilot](https://www.microsoft.com/ko-kr/microsoft-copilot) 같은 개발용 전문 AI 툴은 아직 사용해 보지 않았지만, 훨씬 더 편리할 것이라고 예상하고 있습니다.

이미 저는 4o으로 업그레이드 되고 나서는 개발 외에 블로그 포스트 작성에서도 ChatGPT를 적극적으로 도입하고 있습니다. 기존에 제가 전적으로 작성해야 했을 때의 투입량과 비교했을 때 AI를 도입하면 10~20%의 투입량만으로도 블로그 글이 뚝딱 완성이 되었고, 그 결과물이 심지어 제가 작성했을 때의 결과물보다 퀄리티가 좋은 것을 보고 이제 개발 블로그의 시대 및 전통적인 역할(스스로 내용을 정리하며 개발 내용을 학습하고 공유) 또한 끝나가고 있음을 절실히 느끼고 있습니다.

하단에 제가 개발에 이용한 질문과 ChatGPT의 답변을 첨부합니다. 예시로, Swift의 `CoreData`라는 프레임워크의 CRUD(생성(Create), 읽기(Read), 업데이트(Update), 삭제(Delete)) 기능을 제 현재 상황(속성 및 클래스 이름)에 맞게 전체 코드를 생성해 주었습니다.

* * *

**_swift의 core data에서 다음과 같은 엔티티의 CRUD를 수행하는 코드를 작성해줘._**

**_자동 생성된 클래스 이름: Memo_** **_속성_** **_\- url (URI, non-optional)_** **_\- text (String, optional)_** **_\- createdDate(date, optional)_** **_\- modifiedDate(date, optional)_**

 

Core Data를 사용하여 Memo 엔티티의 CRUD 작업을 수행하는 코드를 작성할 수 있습니다. 이 코드는 Swift와 Core Data를 사용하며, Memo 클래스가 자동 생성되었다고 가정합니다.

**Core Data CRUD 작업 예시 코드**

1. **Core Data Stack 설정**: 보통 AppDelegate 또는 별도의 Core Data 관리 클래스에서 Core Data 스택을 설정합니다. (persistentContainer, viewContext 등)
2. **CRUD 작업을 위한 코드**: 아래는 각 CRUD(Create, Read, Update, Delete)를 수행하는 예시 코드입니다.

```
import CoreData
import UIKit

// Core Data Manager
class CoreDataManager {
    static let shared = CoreDataManager()
    
    // MARK: - Persistent Container
    lazy var persistentContainer: NSPersistentContainer = {
        let container = NSPersistentContainer(name: "YourDataModelName")
        container.loadPersistentStores { (storeDescription, error) in
            if let error = error as NSError? {
                fatalError("Unresolved error \(error), \(error.userInfo)")
            }
        }
        return container
    }()
    
    // Context
    var context: NSManagedObjectContext {
        return persistentContainer.viewContext
    }

    // Save Context
    func saveContext() {
        let context = persistentContainer.viewContext
        if context.hasChanges {
            do {
                try context.save()
            } catch {
                let nserror = error as NSError
                fatalError("Unresolved error \(nserror), \(nserror.userInfo)")
            }
        }
    }
    
    // MARK: - Create
    func createMemo(url: URL, text: String?, createdDate: Date?, modifiedDate: Date?) {
        let memo = Memo(context: context)
        memo.url = url
        memo.text = text
        memo.createdDate = createdDate
        memo.modifiedDate = modifiedDate
        
        saveContext() // 저장
    }
    
    // MARK: - Read
    func fetchAllMemos() -> [Memo] {
        let fetchRequest: NSFetchRequest<Memo> = Memo.fetchRequest()
        
        do {
            let memos = try context.fetch(fetchRequest)
            return memos
        } catch let error as NSError {
            print("Could not fetch. \(error), \(error.userInfo)")
            return []
        }
    }

    // MARK: - Update
    func updateMemo(memo: Memo, newText: String?, newModifiedDate: Date?) {
        memo.text = newText
        memo.modifiedDate = newModifiedDate
        
        saveContext() // 저장
    }
    
    // MARK: - Delete
    func deleteMemo(memo: Memo) {
        context.delete(memo)
        
        saveContext() // 저장
    }
}
```

**사용 예시**

생략 (CRUD 상황별로 적절한 예시의 코드를 잘 알려주었습니다.)

 

**요약**

이 코드는 `Memo` 엔티티에 대해 Create, Read, Update, Delete 작업을 수행하는 예시입니다. `CoreDataManager`를 사용하여 데이터 관리를 쉽게 할 수 있습니다.

 

**_특정 URL을 가진 Memo만 조회하는 메서드 만들어._**

특정 URL을 가진 `Memo`만 조회하는 메서드를 만들기 위해서는 `NSPredicate`를 사용하여 `fetchRequest`에 조건을 추가할 수 있습니다. 아래에 특정 URL을 기반으로 `Memo`를 조회하는 메서드를 추가한 코드를 보여드리겠습니다.

**특정 URL을 가진 Memo 조회 메서드**

```
// Core Data Manager
class CoreDataManager {
    // 기존 코드...
    
    // MARK: - Fetch Memo by URL
    func fetchMemo(by url: URL) -> [Memo] {
        let fetchRequest: NSFetchRequest<Memo> = Memo.fetchRequest()
        
        // URL을 조건으로 추가
        fetchRequest.predicate = NSPredicate(format: "url == %@", url as CVarArg)
        
        do {
            let memos = try context.fetch(fetchRequest)
            return memos
        } catch let error as NSError {
            print("Could not fetch. \(error), \(error.userInfo)")
            return []
        }
    }
}
```

**사용 예시**

특정 URL을 가진 `Memo`를 조회할 때는 아래처럼 사용할 수 있습니다.

```
let url = URL(string: "https://example.com")!
let memos = CoreDataManager.shared.fetchMemo(by: url)

for memo in memos {
    print("Memo Text: \(memo.text ?? "No text")")
    print("Created Date: \(memo.createdDate)")
    print("Modified Date: \(memo.modifiedDate)")
}
```

**설명**

- `fetchMemo(by url: URL)` 메서드는 특정 URL을 기반으로 `Memo` 엔티티를 조회합니다.
- `NSPredicate`는 `fetch request`에 조건을 추가하는 데 사용되며, 여기서는 `url == %@`로 URL이 일치하는 Memo를 찾습니다.

 

\[rcblock id="6686"\]
