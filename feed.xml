<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" hreflang="ko" /><updated>2025-10-23T08:03:29+09:00</updated><id>/feed.xml</id><title type="html">BGSMM</title><subtitle>A minimal, responsive and feature-rich Jekyll theme for technical writing.</subtitle><entry><title type="html">유튜브 ’채널 추천 안함‘ 기능이 적용된 특정 채널에 대해 취소 방법</title><link href="/posts/%EC%9C%A0%ED%8A%9C%EB%B8%8C-%EC%B1%84%EB%84%90-%EC%B6%94%EC%B2%9C-%EC%95%88%ED%95%A8-%EA%B8%B0%EB%8A%A5%EC%9D%B4-%EC%A0%81%EC%9A%A9%EB%90%9C-%ED%8A%B9%EC%A0%95-%EC%B1%84%EB%84%90/" rel="alternate" type="text/html" title="유튜브 ’채널 추천 안함‘ 기능이 적용된 특정 채널에 대해 취소 방법" /><published>2025-09-21T00:00:00+09:00</published><updated>2025-09-21T00:00:00+09:00</updated><id>/posts/%EC%9C%A0%ED%8A%9C%EB%B8%8C-%EC%B1%84%EB%84%90-%EC%B6%94%EC%B2%9C-%EC%95%88%ED%95%A8-%EA%B8%B0%EB%8A%A5%EC%9D%B4-%EC%A0%81%EC%9A%A9%EB%90%9C-%ED%8A%B9%EC%A0%95-%EC%B1%84%EB%84%90</id><content type="html" xml:base="/posts/%EC%9C%A0%ED%8A%9C%EB%B8%8C-%EC%B1%84%EB%84%90-%EC%B6%94%EC%B2%9C-%EC%95%88%ED%95%A8-%EA%B8%B0%EB%8A%A5%EC%9D%B4-%EC%A0%81%EC%9A%A9%EB%90%9C-%ED%8A%B9%EC%A0%95-%EC%B1%84%EB%84%90/"><![CDATA[<h4 id="소개"><strong>소개</strong></h4>

<p>유튜브를 이용하다 보면, 보고 싶지 않은 채널에 대해 ‘채널 추천 안함’ 기능을 사용하게 됩니다. 이 기능을 사용하게 되면 홈(타임라인)에서만 해당 채널의 영상이 추천되지 않으며, 검색 및 구독 탭에서는 표시가 됩니다.</p>

<p><img src="./assets/img/wp-content/uploads/2025/09/스크린샷-2025-09-21-오후-6.52.05-복사본.jpeg" alt="" /></p>

<p> </p>

<p>하지만 시간이 지나면서 다시 그 채널의 영상을 보고 싶을 때가 있습니다. 문제는 이 기능을 적용한 뒤에는 어디서 취소해야 하는지 찾기 어렵다는 점입니다.</p>

<p> </p>

<p>유튜브 앱에서 특정 채널의 관심 없음 설정을 해제하는 방법을 단계별로 안내드리겠습니다. 또한 이 방법으로 ‘관심 없음’을 설정한 영상도 취소할 수 있습니다.</p>

<p> </p>

<h4 id="방법"><strong>방법</strong></h4>

<p><strong>1) 유튜브 앱 [내 페이지]에서 우측 상단의 설정(톱니바퀴) 아이콘을 클릭합니다.</strong></p>

<p><img src="./assets/img/wp-content/uploads/2025/09/y1.jpg" alt="" /></p>

<p> </p>

<p><strong>2) 설정 메뉴에서 [전체 기록 관리]를 선택합니다.</strong></p>

<p><img src="./assets/img/wp-content/uploads/2025/09/y2.jpg" alt="" /></p>

<p> </p>

<p><strong>3) 상단 탭에서 [상호작용]을 클릭합니다.</strong></p>

<p><img src="./assets/img/wp-content/uploads/2025/09/y3.jpg" alt="" /></p>

<p> </p>

<p><strong>화면을 아래로 스크롤해 [사용자 의견(’관심 없음‘ 포함)] 항목을 찾습니다.</strong></p>

<p><img src="./assets/img/wp-content/uploads/2025/09/y4.jpg" alt="" /></p>

<p> </p>

<p><strong>여기에서 취소 기록을 확인할 수 있습니다. 취소하고 싶은 채널을 확인한 뒤, 해당 셀 오른쪽에 있는 <code class="language-plaintext highlighter-rouge">(x)</code> 버튼을 눌러줍니다.</strong></p>

<p><img src="./assets/img/wp-content/uploads/2025/09/y5.jpg" alt="" /></p>

<p> </p>

<p><strong>마지막으로 홈(타임라인) 탭으로 돌아가면, 해당 채널이 다시 보이기 시작하는 것을 바로 확인할 수 있습니다.</strong></p>

<p><img src="./assets/img/wp-content/uploads/2025/09/y6.jpg" alt="" /></p>

<p> </p>

<p>[rcblock id=”6686”]</p>]]></content><author><name></name></author><category term="Blog" /><category term="정보글" /><summary type="html"><![CDATA[소개]]></summary></entry><entry><title type="html">Swift: @dynamicMemberLookup 사용법 및 @Published 와 결합 가능 여부</title><link href="/posts/swift-dynamicmemberlookup-%EC%82%AC%EC%9A%A9%EB%B2%95-%EB%B0%8F-published-%EC%99%80-%EA%B2%B0%ED%95%A9-%EA%B0%80%EB%8A%A5-%EC%97%AC%EB%B6%80/" rel="alternate" type="text/html" title="Swift: @dynamicMemberLookup 사용법 및 @Published 와 결합 가능 여부" /><published>2025-09-20T00:00:00+09:00</published><updated>2025-09-20T00:00:00+09:00</updated><id>/posts/swift-dynamicmemberlookup-%EC%82%AC%EC%9A%A9%EB%B2%95-%EB%B0%8F-published-%EC%99%80-%EA%B2%B0%ED%95%A9-%EA%B0%80%EB%8A%A5-%EC%97%AC%EB%B6%80</id><content type="html" xml:base="/posts/swift-dynamicmemberlookup-%EC%82%AC%EC%9A%A9%EB%B2%95-%EB%B0%8F-published-%EC%99%80-%EA%B2%B0%ED%95%A9-%EA%B0%80%EB%8A%A5-%EC%97%AC%EB%B6%80/"><![CDATA[<h3 id="개요--dynamicmemberlookup이란"><strong>개요 — <code class="language-plaintext highlighter-rouge">@dynamicMemberLookup</code>이란</strong></h3>

<p><code class="language-plaintext highlighter-rouge">@dynamicMemberLookup</code>은 **컴파일러에게 “점(<code class="language-plaintext highlighter-rouge">.</code>) 접근을 보낼 때 <code class="language-plaintext highlighter-rouge">subscript(dynamicMember:)</code>로 재해석해라”**고 지시하는 어노테이션입니다. 즉 <code class="language-plaintext highlighter-rouge">obj.foo</code>를 호출하면 컴파일러는 <code class="language-plaintext highlighter-rouge">obj[dynamicMember: "foo"]</code> 형태의 서브스크립트 호출로 바꿔줍니다. 주로 내부에 <code class="language-plaintext highlighter-rouge">[String: Any]</code> 같은 딕셔너리를 두고 JSON/동적 프로퍼티처럼 보이게 할 때 유용합니다.</p>

<p> </p>

<h4 id="간단한-동작-원리"><strong>간단한 동작 원리</strong></h4>

<ul>
  <li>선언: <code class="language-plaintext highlighter-rouge">@dynamicMemberLookup</code>을 타입 앞에 붙입니다.</li>
  <li>필수: <code class="language-plaintext highlighter-rouge">subscript(dynamicMember:)</code> 구현(여러 오버로드 허용).</li>
  <li>장점: 문법이 깔끔하고 JS 스타일 접근 가능.</li>
  <li>단점: 컴파일타임 타입 안정성·자동완성 손실(또는 약화).</li>
</ul>

<p> </p>

<h3 id="dynamicmemberlookup-기본-예제"><strong><code class="language-plaintext highlighter-rouge">@dynamicMemberLookup</code> 기본 예제</strong></h3>

<p>아래는 가장 단순한 형태입니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre><span class="kd">@dynamicMemberLookup</span>
<span class="kd">struct</span> <span class="kt">DynamicDict</span> <span class="p">{</span>
  <span class="kd">private</span> <span class="k">var</span> <span class="nv">storage</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">[:]</span>

  <span class="nf">subscript</span><span class="p">(</span><span class="n">dynamicMember</span> <span class="nv">member</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Any</span><span class="p">?</span> <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span> <span class="n">storage</span><span class="p">[</span><span class="n">member</span><span class="p">]</span> <span class="p">}</span>
    <span class="k">set</span> <span class="p">{</span> <span class="n">storage</span><span class="p">[</span><span class="n">member</span><span class="p">]</span> <span class="o">=</span> <span class="n">newValue</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">var</span> <span class="nv">d</span> <span class="o">=</span> <span class="kt">DynamicDict</span><span class="p">()</span>
<span class="c1">// title이라는 변수가 없음에도 점(.)을 찍어 있던 변수인 것처럼 작성할 수 있음</span>
<span class="n">d</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="s">"Hello"</span>            <span class="c1">// storage["title"] = "Hello"</span>
<span class="nf">print</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">title</span> <span class="k">as?</span> <span class="kt">String</span><span class="p">)</span>    <span class="c1">// "Hello"</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p> </p>

<p>타입 안전성을 조금 더 주고 싶으면 제네릭(generic) 서브스크립트를 씁니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="kd">@dynamicMemberLookup</span>
<span class="kd">struct</span> <span class="kt">DynamicTyped</span> <span class="p">{</span>
  <span class="kd">private</span> <span class="k">var</span> <span class="nv">storage</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">[:]</span>

  <span class="kd">subscript</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">dynamicMember</span> <span class="nv">member</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">T</span><span class="p">?</span> <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span> <span class="n">storage</span><span class="p">[</span><span class="n">member</span><span class="p">]</span> <span class="k">as?</span> <span class="kt">T</span> <span class="p">}</span>
    <span class="k">set</span> <span class="p">{</span> <span class="n">storage</span><span class="p">[</span><span class="n">member</span><span class="p">]</span> <span class="o">=</span> <span class="n">newValue</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">var</span> <span class="nv">dt</span> <span class="o">=</span> <span class="kt">DynamicTyped</span><span class="p">()</span>
<span class="n">dt</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">10</span>                <span class="c1">// T 는 Int로 추론됨</span>
<span class="k">let</span> <span class="nv">c</span><span class="p">:</span> <span class="kt">Int</span><span class="p">?</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">count</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p> </p>

<h3 id="published와-결합가능불가능--구현-방식"><strong><code class="language-plaintext highlighter-rouge">@Published</code>와 결합(가능/불가능 &amp; 구현 방식)</strong></h3>

<p>직접적으로 <code class="language-plaintext highlighter-rouge">@Published</code>를 <strong>동적 멤버에 붙일 수는 없습니다</strong>. 이유는 <code class="language-plaintext highlighter-rouge">@Published</code>는 <strong><em>정적 저장 프로퍼티</em></strong>에 적용되는 property wrapper이기 때문입니다. 즉 컴파일 시점에 해당 프로퍼티가 존재해야 합니다.</p>

<p>하지만 다음과 같은 패턴으로 <strong>유사한 동작(변경 알림)을 구현</strong>할 수 있습니다.</p>

<p> </p>

<h4 id="방법-a--내부에-published-var-storage-string-any-두기-권장"><strong>방법 A — 내부에 <code class="language-plaintext highlighter-rouge">@Published var storage: [String: Any]</code> 두기 (권장)</strong></h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">storage</code>를 <code class="language-plaintext highlighter-rouge">@Published</code>로 두고, dynamic subscript는 <code class="language-plaintext highlighter-rouge">storage</code>를 읽고 씁니다.</li>
  <li><code class="language-plaintext highlighter-rouge">storage</code>가 바뀌면 Combine이 발행하므로 <code class="language-plaintext highlighter-rouge">ObservableObject</code> 구독자(SwiftUI 등)는 갱신됩니다.</li>
</ul>

<p>예:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre><span class="kd">@dynamicMemberLookup</span>
<span class="kd">final</span> <span class="kd">class</span> <span class="kt">DynamicObservable</span><span class="p">:</span> <span class="kt">ObservableObject</span> <span class="p">{</span>
  <span class="kd">@Published</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">storage</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">[:]</span>

  <span class="kd">subscript</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">dynamicMember</span> <span class="nv">member</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">T</span><span class="p">?</span> <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span> <span class="n">storage</span><span class="p">[</span><span class="n">member</span><span class="p">]</span> <span class="k">as?</span> <span class="kt">T</span> <span class="p">}</span>
    <span class="k">set</span> <span class="p">{</span>
      <span class="n">storage</span><span class="p">[</span><span class="n">member</span><span class="p">]</span> <span class="o">=</span> <span class="n">newValue</span>
      <span class="c1">// 일반적으로 @Published가 storage 변경을 발행하므로 추가 호출 불필요.</span>
      <span class="c1">// 필요시 objectWillChange.send()를 직접 호출할 수도 있음.</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// 특정 키의 Combine 퍼블리셔가 필요하면 노출</span>
  <span class="kd">func</span> <span class="n">publisher</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="k">for</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">AnyPublisher</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">?,</span> <span class="kt">Never</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">$storage</span>
      <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">as?</span> <span class="kt">T</span> <span class="p">}</span>
      <span class="o">.</span><span class="nf">eraseToAnyPublisher</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>사용예:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">let</span> <span class="nv">dyn</span> <span class="o">=</span> <span class="kt">DynamicObservable</span><span class="p">()</span>
<span class="n">dyn</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="s">"Hi"</span>                    <span class="c1">// storage["title"] = "Hi"</span>
<span class="k">let</span> <span class="nv">title</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span> <span class="o">=</span> <span class="n">dyn</span><span class="o">.</span><span class="n">title</span>
<span class="c1">// SwiftUI View는 dyn의 objectWillChange를 구독하므로 바뀌면 뷰 갱신됨</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>주의: <code class="language-plaintext highlighter-rouge">storage</code>에 대한 “부분 수정”(예: <code class="language-plaintext highlighter-rouge">storage["a"] = x</code>)도 <code class="language-plaintext highlighter-rouge">@Published</code>에서 발행되는 게 일반적으로 작동하지만, 안전하게 만들고 싶으면 <code class="language-plaintext highlighter-rouge">objectWillChange.send()</code>를 직접 호출해 명시적으로 알릴 수 있습니다.</p>
</blockquote>

<p> </p>

<h4 id="방법-b--objectwillchangesend를-수동으로-호출"><strong>방법 B — <code class="language-plaintext highlighter-rouge">objectWillChange.send()</code>를 수동으로 호출</strong></h4>

<p><code class="language-plaintext highlighter-rouge">@Published</code> 대신 <code class="language-plaintext highlighter-rouge">ObservableObject</code>의 <code class="language-plaintext highlighter-rouge">objectWillChange</code>를 직접 제어할 수도 있습니다. (더 유연하지만 수동 호출 책임이 증가)</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="kd">@dynamicMemberLookup</span>
<span class="kd">final</span> <span class="kd">class</span> <span class="kt">DynamicManualObservable</span><span class="p">:</span> <span class="kt">ObservableObject</span> <span class="p">{</span>
  <span class="kd">private</span> <span class="k">var</span> <span class="nv">storage</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">[:]</span>

  <span class="nf">subscript</span><span class="p">(</span><span class="n">dynamicMember</span> <span class="nv">member</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Any</span><span class="p">?</span> <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span> <span class="n">storage</span><span class="p">[</span><span class="n">member</span><span class="p">]</span> <span class="p">}</span>
    <span class="k">set</span> <span class="p">{</span>
      <span class="n">objectWillChange</span><span class="o">.</span><span class="nf">send</span><span class="p">()</span>
      <span class="n">storage</span><span class="p">[</span><span class="n">member</span><span class="p">]</span> <span class="o">=</span> <span class="n">newValue</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p> </p>

<h3 id="wkwebview-속성예-cangoback-등을-한꺼번에-다루려는-경우-권장-패턴"><strong>WKWebView 속성(예: canGoBack 등)을 한꺼번에 다루려는 경우 권장 패턴</strong></h3>

<p><code class="language-plaintext highlighter-rouge">@dynamicMemberLookup</code>만으로 KVO/Subscribers를 자동 생성해주는 건 불가능합니다. 왜냐하면 <code class="language-plaintext highlighter-rouge">publisher(for:)</code>는 <strong>각 KeyPath마다</strong> 퍼블리셔를 만들어 주기 때문입니다. 하지만 반복 코드를 줄이는 구조는 만들 수 있습니다:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">bind(_:to:)</code> 헬퍼로 <code class="language-plaintext highlighter-rouge">KeyPath</code> → <code class="language-plaintext highlighter-rouge">storage[name]</code> 매핑을 한 번에 등록</li>
  <li>내부는 <code class="language-plaintext highlighter-rouge">webView.publisher(for: keyPath).sink { storage[name] = $0 }</code></li>
</ul>

<p> </p>

<h4 id="예시컨덕터에-적용"><strong>예시(컨덕터에 적용):</strong></h4>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="rouge-code"><pre><span class="kd">@dynamicMemberLookup</span>
<span class="kd">final</span> <span class="kd">class</span> <span class="kt">WKWebViewConductor</span><span class="p">:</span> <span class="kt">ObservableObject</span> <span class="p">{</span>
  <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">webView</span><span class="p">:</span> <span class="kt">WKWebView</span>
  <span class="kd">@Published</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">storage</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">[:]</span>
  <span class="kd">private</span> <span class="k">var</span> <span class="nv">cancellables</span> <span class="o">=</span> <span class="kt">Set</span><span class="o">&lt;</span><span class="kt">AnyCancellable</span><span class="o">&gt;</span><span class="p">()</span> <span class="c1">// Combine 퍼블리셔 구독(subscription)을 보관하는 저장소</span>

  <span class="nf">init</span><span class="p">(</span><span class="nv">webView</span><span class="p">:</span> <span class="kt">WKWebView</span> <span class="o">=</span> <span class="kt">WKWebView</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">self</span><span class="o">.</span><span class="n">webView</span> <span class="o">=</span> <span class="n">webView</span>

    <span class="c1">// 반복을 줄이는 bind 헬퍼 사용</span>
    <span class="nf">bind</span><span class="p">(</span><span class="o">.</span><span class="n">canGoBack</span><span class="p">,</span> <span class="nv">to</span><span class="p">:</span> <span class="s">"canGoBack"</span><span class="p">)</span>
    <span class="nf">bind</span><span class="p">(</span><span class="o">.</span><span class="n">canGoForward</span><span class="p">,</span> <span class="nv">to</span><span class="p">:</span> <span class="s">"canGoForward"</span><span class="p">)</span>
    <span class="nf">bind</span><span class="p">(</span><span class="o">.</span><span class="n">estimatedProgress</span><span class="p">,</span> <span class="nv">to</span><span class="p">:</span> <span class="s">"estimatedProgress"</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="kd">private</span> <span class="kd">func</span> <span class="n">bind</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">keyPath</span><span class="p">:</span> <span class="kt">KeyPath</span><span class="o">&lt;</span><span class="kt">WKWebView</span><span class="p">,</span> <span class="kt">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">to</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">webView</span><span class="o">.</span><span class="nf">publisher</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="n">keyPath</span><span class="p">)</span>
      <span class="o">.</span><span class="nf">receive</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="kt">DispatchQueue</span><span class="o">.</span><span class="n">main</span><span class="p">)</span>
      <span class="o">.</span><span class="n">sink</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="n">value</span> <span class="k">in</span>
        <span class="k">self</span><span class="p">?</span><span class="o">.</span><span class="n">storage</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
      <span class="p">}</span>
      <span class="o">.</span><span class="nf">store</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">cancellables</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="kd">subscript</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">dynamicMember</span> <span class="nv">member</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">T</span><span class="p">?</span> <span class="p">{</span>
    <span class="n">storage</span><span class="p">[</span><span class="n">member</span><span class="p">]</span> <span class="k">as?</span> <span class="kt">T</span>
  <span class="p">}</span>

  <span class="kd">func</span> <span class="n">publisher</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="k">for</span> <span class="nv">member</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">AnyPublisher</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">?,</span> <span class="kt">Never</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">$storage</span>
      <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="p">[</span><span class="n">member</span><span class="p">]</span> <span class="k">as?</span> <span class="kt">T</span> <span class="p">}</span>
      <span class="o">.</span><span class="nf">eraseToAnyPublisher</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p> </p>

<h5 id="이-패턴의-장점"><strong>이 패턴의 장점</strong></h5>

<ul>
  <li><code class="language-plaintext highlighter-rouge">conductor.canGoBack</code> 형태로 접근 가능(옵셔널 반환).</li>
  <li><code class="language-plaintext highlighter-rouge">publisher(for:)</code>로 각 키에 대한 Combine 스트림도 얻어 쓸 수 있음.</li>
  <li>바인딩 등록은 <code class="language-plaintext highlighter-rouge">bind</code> 호출만으로 줄일 수 있음.</li>
</ul>

<p> </p>

<h5 id="단점--유의사항"><strong>단점 / 유의사항</strong></h5>

<ul>
  <li>타입 안전성은 약해짐(<code class="language-plaintext highlighter-rouge">Any</code> 캐스팅 필요).</li>
  <li>자동완성 및 문서화 이점이 줄어듦(동적 키는 컴파일타임 검사가 안 됨).</li>
  <li><strong>여전히</strong> 어떤 속성을 구독할지는 코드에서 명시해야 함(완전 자동화 불가).</li>
  <li>KVO 대상의 타입별로 <code class="language-plaintext highlighter-rouge">bind</code> 호출은 필요(서로 다른 타입을 하나의 컬렉션으로 일괄 처리하려면 제너릭/추상화 조금 더 필요).</li>
</ul>

<p> </p>

<h3 id="결론"><strong>결론</strong></h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">@dynamicMemberLookup</code>은 <strong>동적 접근 문법</strong>을 제공하지만, <code class="language-plaintext highlighter-rouge">@Published</code>를 동적 멤버에 직접 붙일 수는 없습니다.</li>
  <li>실무에서는 <code class="language-plaintext highlighter-rouge">@Published private var storage: [String: Any]</code> + <code class="language-plaintext highlighter-rouge">subscript(dynamicMember:)</code> 패턴이 가장 현실적이고 실용적입니다.</li>
  <li>WKWebView 같은 경우 <strong>구독할 속성 목록(예: canGoBack, estimatedProgress 등)을 한 곳에 나열하고</strong> <code class="language-plaintext highlighter-rouge">bind</code> 헬퍼로 등록하면 반복을 많이 줄일 수 있습니다.</li>
  <li>하지만 타입 안전성과 코드 가독성을 중시한다면, 핵심 프로퍼티만 명시적 <code class="language-plaintext highlighter-rouge">@Published var canGoBack: Bool = false</code> 처럼 선언하는 쪽이 유지보수에 유리합니다.</li>
</ul>

<p> </p>

<h5 id="참고-핵심-프로퍼티만-명시적으로-선언하는-방법"><strong>참고: 핵심 프로퍼티만 명시적으로 선언하는 방법</strong></h5>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre><span class="c1">// Combine으로 Publish 되는 변수들</span>
<span class="kd">@Published</span> <span class="k">var</span> <span class="nv">estimatedProgress</span><span class="p">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">0.0</span> 
<span class="kd">@Published</span> <span class="k">var</span> <span class="nv">canGoBack</span> <span class="o">=</span> <span class="kc">false</span>
<span class="kd">@Published</span> <span class="k">var</span> <span class="nv">canGoForward</span> <span class="o">=</span> <span class="kc">false</span>

<span class="c1">// ... //</span>

<span class="kd">private</span> <span class="kd">func</span> <span class="n">bind</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">keyPath</span><span class="p">:</span> <span class="kt">KeyPath</span><span class="o">&lt;</span><span class="kt">WKWebView</span><span class="p">,</span> <span class="kt">T</span><span class="o">&gt;</span><span class="p">,</span>
                     <span class="n">to</span> <span class="nv">publishedKeyPath</span><span class="p">:</span> <span class="kt">ReferenceWritableKeyPath</span><span class="o">&lt;</span><span class="kt">WKWebViewReprConductor</span><span class="p">,</span> <span class="kt">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">webView</span><span class="o">.</span><span class="nf">publisher</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="n">keyPath</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">receive</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="kt">DispatchQueue</span><span class="o">.</span><span class="n">main</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">assign</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="n">publishedKeyPath</span><span class="p">,</span> <span class="nv">on</span><span class="p">:</span> <span class="k">self</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">store</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">cancellables</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">init</span><span class="p">(</span><span class="nv">webView</span><span class="p">:</span> <span class="kt">WKWebView</span> <span class="o">=</span> <span class="kt">WKWebView</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">self</span><span class="o">.</span><span class="n">webView</span> <span class="o">=</span> <span class="n">webView</span>
  <span class="nf">bind</span><span class="p">(\</span><span class="o">.</span><span class="n">canGoBack</span><span class="p">,</span> <span class="nv">to</span><span class="p">:</span> <span class="p">\</span><span class="o">.</span><span class="n">canGoBack</span><span class="p">)</span>
  <span class="nf">bind</span><span class="p">(\</span><span class="o">.</span><span class="n">canGoForward</span><span class="p">,</span> <span class="nv">to</span><span class="p">:</span> <span class="p">\</span><span class="o">.</span><span class="n">canGoForward</span><span class="p">)</span>
  <span class="nf">bind</span><span class="p">(\</span><span class="o">.</span><span class="n">estimatedProgress</span><span class="p">,</span> <span class="nv">to</span><span class="p">:</span> <span class="p">\</span><span class="o">.</span><span class="n">estimatedProgress</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>[rcblock id=”6686”]</p>]]></content><author><name></name></author><category term="DevLog" /><category term="Swift" /><summary type="html"><![CDATA[개요 — @dynamicMemberLookup이란]]></summary></entry><entry><title type="html">SwiftUI: 목록 행(row) 및 헤더(header) 높이 변경</title><link href="/posts/swiftui-%EB%AA%A9%EB%A1%9D-%ED%96%89row-%EB%B0%8F-%ED%97%A4%EB%8D%94header-%EB%86%92%EC%9D%B4-%EB%B3%80%EA%B2%BD/" rel="alternate" type="text/html" title="SwiftUI: 목록 행(row) 및 헤더(header) 높이 변경" /><published>2025-09-08T00:00:00+09:00</published><updated>2025-09-08T00:00:00+09:00</updated><id>/posts/swiftui-%EB%AA%A9%EB%A1%9D-%ED%96%89row-%EB%B0%8F-%ED%97%A4%EB%8D%94header-%EB%86%92%EC%9D%B4-%EB%B3%80%EA%B2%BD</id><content type="html" xml:base="/posts/swiftui-%EB%AA%A9%EB%A1%9D-%ED%96%89row-%EB%B0%8F-%ED%97%A4%EB%8D%94header-%EB%86%92%EC%9D%B4-%EB%B3%80%EA%B2%BD/"><![CDATA[<h4 id="소개"><strong>소개</strong></h4>

<p>이 예제는 SwiftUI List에서 행(row)과 헤더(header) 높이를 변경하는 방법을 보여줍니다.</p>

<p>최종 결과는 다음과 같습니다:</p>

<iframe width="271" height="480" src="https://giphy.com/embed/0O9Qt64wazqLCFKkFF" frameborder="0" class="giphy-embed" allowfullscreen="allowfullscreen"></iframe>

<p> </p>

<h4 id="설명"><strong>설명</strong></h4>

<p><code class="language-plaintext highlighter-rouge">defaultMinListRowHeight</code> 라는 <code class="language-plaintext highlighter-rouge">EnvironmentValue</code>를 사용해서 기본 최소 행 높이를 설정할 수 있습니다. 마찬가지로 <code class="language-plaintext highlighter-rouge">defaultMinListHeaderHeight</code>를 사용하면 섹션 헤더의 높이를 지정할 수 있습니다.</p>

<p>아래 코드는 그룹화된 리스트에서 슬라이더로 두 값을 조절하는 예시입니다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="rouge-code"><pre>// ...SwiftUI View에서 작성...

@State private var rowHeight: CGFloat = 40
@State private var headerHeight: CGFloat = 60

var body: some View {
  VStack {
    HStack {
      Text("Row height")
      Slider(value: $rowHeight, in: 40.0...80.0)
    }
    HStack {
      Text("Header height")
      Slider(value: $headerHeight, in: 60.0...80.0)
    }
    List(1..&lt;5) { section in
      Section("Section \(section)") {
        ForEach(1..&lt;3) { row in
          Text("Row \(row) of section \(section)")
        }
      }
    }
  }
  .padding()
  .environment(\.defaultMinListRowHeight, rowHeight) // 행 높이 지정
  .environment(\.defaultMinListHeaderHeight, headerHeight) // 헤더 높이 지정
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p> </p>

<h4 id="추가-ios-16-이하-버전에서-리스트-섹션-간-간격-조절"><strong>추가: iOS 16 이하 버전에서 리스트 섹션 간 간격 조절</strong></h4>

<p><img src="./assets/img/wp-content/uploads/2025/09/스크린샷-2025-09-09-오전-1.07.11.png" alt="" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre>import SwiftUI

struct ContentView: View {
  init() {
    // 섹션간 높이 조절
    var layoutConfig = UICollectionLayoutListConfiguration(appearance: .plain) // 주의: 우선하여 적용됨
    layoutConfig.headerMode = .supplementary
    layoutConfig.headerTopPadding = 10
    let listLayout = UICollectionViewCompositionalLayout.list(using: layoutConfig)
    UICollectionView.appearance().collectionViewLayout = listLayout
  }

  ...
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p> </p>

<h4 id="출처"><strong>출처</strong></h4>

<ul>
  <li><a href="https://swiftuirecipes.com/blog/swiftui-list-change-row-and-header-height">SwiftUI List Change Row and Header Height</a></li>
  <li><a href="https://stackoverflow.com/questions/68488891/swiftui-list-set-section-header-height">SwiftUI List: set section header height?</a></li>
</ul>]]></content><author><name></name></author><category term="DevLog" /><category term="Swift" /><summary type="html"><![CDATA[소개]]></summary></entry><entry><title type="html">[영어 학습] 30만 달러를 들여 헬스케어 앱을 만들었지만 아무도 사용하지 않음</title><link href="/posts/%ED%8E%8C-%EB%B2%88%EC%97%AD-30%EB%A7%8C-%EB%8B%AC%EB%9F%AC%EB%A5%BC-%EB%93%A4%EC%97%AC-%ED%97%AC%EC%8A%A4%EC%BC%80%EC%96%B4-%EC%95%B1%EC%9D%84-%EB%A7%8C%EB%93%A4%EC%97%88%EC%A7%80%EB%A7%8C/" rel="alternate" type="text/html" title="[영어 학습] 30만 달러를 들여 헬스케어 앱을 만들었지만 아무도 사용하지 않음" /><published>2025-08-20T00:00:00+09:00</published><updated>2025-08-20T00:00:00+09:00</updated><id>/posts/%ED%8E%8C-%EB%B2%88%EC%97%AD-30%EB%A7%8C-%EB%8B%AC%EB%9F%AC%EB%A5%BC-%EB%93%A4%EC%97%AC-%ED%97%AC%EC%8A%A4%EC%BC%80%EC%96%B4-%EC%95%B1%EC%9D%84-%EB%A7%8C%EB%93%A4%EC%97%88%EC%A7%80%EB%A7%8C</id><content type="html" xml:base="/posts/%ED%8E%8C-%EB%B2%88%EC%97%AD-30%EB%A7%8C-%EB%8B%AC%EB%9F%AC%EB%A5%BC-%EB%93%A4%EC%97%AC-%ED%97%AC%EC%8A%A4%EC%BC%80%EC%96%B4-%EC%95%B1%EC%9D%84-%EB%A7%8C%EB%93%A4%EC%97%88%EC%A7%80%EB%A7%8C/"><![CDATA[<h3 id="소개"><strong>소개</strong></h3>

<p>이 글은 30만 달러(약 4.2억원)와 18개월을 들여 기술적으로 완벽한 헬스케어 앱을 만들었지만, 정작 의사들이 실제 업무에 맞지 않아 사용하지 않는 상황을 다룹니다.</p>

<p><img src="./assets/img/wp-content/uploads/2025/08/JPEG-이미지-4322-8AD8-11-0.jpeg" alt="" /></p>

<p> </p>

<h4 id="출처"><strong>출처</strong></h4>

<ul>
  <li><a href="https://x.com/austen/status/1955126456238944371">https://x.com/austen/status/1955126456238944371</a></li>
</ul>

<p> </p>

<h4 id="이-글의-교훈"><strong>이 글의 교훈</strong></h4>

<p>이 글의 교훈은 기술적으로 완벽한 제품을 만드는 것보다 실제 사용자의 문제를 해결하는 제품을 만드는 것이 더 중요하다는 점입니다.</p>

<p>아무리 많은 시간과 돈을 투자해 완성도를 높였더라도, 사용자의 필요와 맞지 않으면 그 제품은 외면받을 수밖에 없습니다. 결국 성공적인 서비스나 제품은 개발자의 관점이 아니라 사용자의 관점에서 유용함과 편리함을 제공해야 한다는 사실을 일깨워 줍니다.</p>

<p> </p>

<h3 id="본문"><strong>본문</strong></h3>

<p>영어 원문 감추기</p>

<script>document.querySelector("#btn-english-text").addEventListener("click", function (e) { const englishText = document.querySelectorAll(".english-text"); const button = document.getElementById("btn-english-text"); englishText.forEach(span => { span.style.display = span.style.display === "none" ? "inline" : "none"; }); button.textContent = button.textContent === "영어 원문 감추기" ? "영어 원문 보기" : "영어 원문 감추기"; })</script>

<p>Spent $300k on a healthcare app that nobody uses. 30만 달러를 들여 헬스케어 앱을 만들었지만 아무도 사용하지 않습니다.</p>

<p>I’m about to lose my mind and my investor’s money. 저는 곧 제정신을 잃고 투자자분의 돈까지 날리게 생겼습니다.</p>

<p>Developer swears it’s ‘technically perfect’ but I can’t get a single doctor to adopt it. 개발자는 ‘기술적으로 완벽하다’고 장담하지만, 단 한 분의 의사도 사용하려 하지 않습니다.</p>

<p>Two years ago, we raised a seed round to build a patient management app for primary care doctors. 2년 전, 1차 진료 의사들을 위한 환자 관리 앱을 만들고자 시드 투자를 유치했습니다.</p>

<p>We hired a boutique dev shop and spent 18 months and $300,000 building what they call a “technically superior solution.” 저희는 소규모 개발사를 고용해 18개월 동안 30만 달러를 들여 그들이 “기술적으로 우수한 솔루션”이라고 부르는 앱을 개발했습니다.</p>

<p><img src="./assets/img/wp-content/uploads/2025/08/D839BE38-47A8-4801-A9AB-E6317A9FE8D5.jpg" alt="" /></p>

<p>The app works flawlessly. 그 앱은 완벽하게 작동합니다.</p>

<p>It has zero bugs, a clean UI, integrates with major EHRs, and is HIPAA compliant—the whole nine yards. 버그도 전혀 없고, 깔끔한 UI를 갖추었으며, 주요 전자의무기록(EHR)과도 통합되고, HIPAA 규정도 준수합니다.</p>

<blockquote>
  <p><strong>EHR:</strong> 전자 의무 기록 (Electronic Health Record) <strong>HIPAA:</strong> 미국 건강 보험 양도 및 책임에 관한 법률(Health Insurance Portability and Accountability Act)</p>
</blockquote>

<p>Our developers are genuinely proud of it. 저희 개발자들은 이에 대해 진심으로 자부심을 느끼고 있습니다.</p>

<p>But here’s the problem: doctors hate it. 하지만 문제는 의사분들이 이 앱을 싫어하신다는 점입니다.</p>

<p>We’ve demoed it to over 50 practices. 저희는 50곳이 넘는 병원에 시연을 했습니다.</p>

<p>We get the same feedback every time: 매번 같은 피드백을 받았습니다.</p>

<p>“It’s nice, but it doesn’t fit our workflow.” “좋긴 하지만, 저희 업무 흐름과는 맞지 않네요.”</p>

<p>“Too many clicks.” “클릭이 너무 많습니다.”</p>

<p>“We already have a system that works.” “저희는 이미 잘 작동하는 시스템을 사용하고 있습니다.”</p>

<p>Meanwhile, I see basic-looking apps with terrible UIs getting massive adoption because they solve one specific pain point really well. 한편, 겉보기에 단순하고 UI도 형편없는 앱들이 특정 문제 하나를 매우 잘 해결한다는 이유만으로 폭넓게 채택되는 것을 보고 있습니다.</p>

<p>I’m starting to think we built the app we wanted to build instead of what doctors actually needed. 저희가 만든 것은 의사분들이 실제로 필요로 하는 앱이 아니라, 저희가 만들고 싶었던 앱이었다는 생각이 듭니다.</p>

<p>It feels like we got so caught up in making it technically impressive that we forgot to make it useful. 기술적으로 인상적인 앱을 만드는 데에만 몰두하다 보니 정작 유용하게 만드는 것을 잊은 것 같습니다.</p>

<p> </p>

<h4 id="댓글"><strong>댓글</strong></h4>

<h5 id="의사의-의견"><strong>의사의 의견</strong></h5>

<p>As an MD, i can confirm that “too many clicks” is a real problem. 의사로서 저는 “클릭이 너무 많다”는 것이 실제 문제라는 것을 확실히 말씀드릴 수 있습니다.</p>

<p>An ER doctor will click his/her mouse 4,000 times in a shift when they could be seeing patients. 응급실 의사는 환자를 진찰할 수 있는 시간에 교대로 마우스를 4,000번 클릭합니다.</p>

<p>Any new product for doctors should lower this number not raise it. 의사를 위한 새로운 제품은 이 숫자를 높여서는 안 되며 낮춰야 합니다.</p>

<p> </p>

<h5 id="익명-사용자의-의견"><strong>익명 사용자의 의견</strong></h5>

<p>Maybe he should have spoken with a single doctor during development. 아마 그는 개발 과정에서 단 한 명의 의사와라도 대화를 나눴어야 했을 것입니다.</p>

<p>Also people tend not to adopt things unless they are significantly better rather than just better. 또한 사람들은 단순히 조금 더 나은 것이 아니라, 훨씬 더 나은 것이 아니면 새로운 것을 채택하지 않는 경향이 있습니다.</p>

<p>Adoption carries costs. 새로운 것을 받아들이는 데에는 비용이 따릅니다.</p>

<p>People need to get used to a new system. 사람들은 새로운 시스템에 익숙해져야 합니다.</p>

<p>And in a hospital that might mean that someone dies <a href="https://en.dict.naver.com/#/entry/enko/d7bb135ae859434e8a259c1ce8f1b5c4">in the interim</a>. 그리고 병원에서는 그 과정에서 누군가의 생명이 위태로워질 수도 있습니다.</p>

<p> </p>

<h5 id="전-x트위터-직원의-의견"><strong>전 X(트위터) 직원의 의견</strong></h5>

<p>I’m tired of every business requiring an app. 앱을 요구하는 모든 사업에 지쳤습니다.</p>

<p>Offer services without forcing me to take precious time to install junk. 소중한 시간을 낭비하지 않고도 서비스를 제공해주세요.</p>

<p>Simple transactions are gone. 간단한 거래는 사라졌습니다.</p>

<p>App downloads are annoying, with pushy businesses taking phone storage and time, possibly tracking other activities across your phone. 앱 다운로드는 귀찮고, 강압적인 사업체들이 휴대폰 저장 공간과 시간을 빼앗고, 휴대폰의 다른 활동 내역을 추적할 수도 있습니다.</p>

<p>I’ve always resisted these apps, but it’s getting harder. 저는 항상 이런 앱들을 거부해왔지만, 점점 어려워지고 있어요.</p>

<p>[rcblock id=”6686”]</p>]]></content><author><name></name></author><category term="StudyLog" /><category term="영어" /><summary type="html"><![CDATA[소개]]></summary></entry><entry><title type="html">Grok의 생각: 자녀에게 ‘고의적 가난(경제적 결핍)’을 물려주는 것이 성장에 도움이 되는가?</title><link href="/posts/grok%EC%9D%98-%EC%83%9D%EA%B0%81-%EC%9E%90%EB%85%80%EC%97%90%EA%B2%8C-%EA%B3%A0%EC%9D%98%EC%A0%81-%EA%B0%80%EB%82%9C%EA%B2%BD%EC%A0%9C%EC%A0%81-%EA%B2%B0%ED%95%8D%EC%9D%84-%EB%AC%BC%EB%A0%A4/" rel="alternate" type="text/html" title="Grok의 생각: 자녀에게 ‘고의적 가난(경제적 결핍)’을 물려주는 것이 성장에 도움이 되는가?" /><published>2025-08-19T00:00:00+09:00</published><updated>2025-08-19T00:00:00+09:00</updated><id>/posts/grok%EC%9D%98-%EC%83%9D%EA%B0%81-%EC%9E%90%EB%85%80%EC%97%90%EA%B2%8C-%EA%B3%A0%EC%9D%98%EC%A0%81-%EA%B0%80%EB%82%9C%EA%B2%BD%EC%A0%9C%EC%A0%81-%EA%B2%B0%ED%95%8D%EC%9D%84-%EB%AC%BC%EB%A0%A4</id><content type="html" xml:base="/posts/grok%EC%9D%98-%EC%83%9D%EA%B0%81-%EC%9E%90%EB%85%80%EC%97%90%EA%B2%8C-%EA%B3%A0%EC%9D%98%EC%A0%81-%EA%B0%80%EB%82%9C%EA%B2%BD%EC%A0%9C%EC%A0%81-%EA%B2%B0%ED%95%8D%EC%9D%84-%EB%AC%BC%EB%A0%A4/"><![CDATA[<p>아래 인터넷의 한 글에 대한 <a href="https://grok.com/">Grok</a>(생성형 인공지능)이 생성한 의견입니다.</p>

<p><img src="./assets/img/wp-content/uploads/2025/08/스크린샷-2025-08-20-오전-12.05.54.png" alt="" /></p>

<p> </p>

<h3 id="grok의-의견"><strong>Grok의 의견</strong></h3>

<p>저는 귀하의 의견을 존중하며, 자녀 교육에 대한 깊은 고민이 느껴집니다. 부모로서 자녀의 성장을 최우선으로 생각하시는 점이 인상적입니다. 그러나 저는 이 문제에 대해 조금 다른 관점을 가지고 있습니다. 특히, 현재 한국 경제의 침체와 저성장 상황을 고려할 때, 자녀에게 성장을 위해 ‘고의적 가난, 경제적 결핍’을 물려주는 것은 치명적인 선택이 될 수 있으며 그 대신에 자녀에게 일정한 경제적 기반을 제공하는 것이 오히려 그들의 장기적인 발전에 도움이 될 수 있다고 믿습니다. 아래에서 제 생각을 정중히 설명드리겠습니다.</p>

<p> </p>

<h4 id="한국의-어두운-미래-경제-상황"><strong>한국의 어두운 미래 경제 상황</strong></h4>

<p>먼저, 자력으로는 더 이상 버티기 힘들어지는 한국 경제의 현실을 감안해야 합니다. 2025년 한국 경제는 내수 경기 회복 지연과 높은 외수 불확실성으로 인해 성장률이 0.8% 정도로 전망되며, 이는 잠재성장률을 크게 하회하는 수준입니다. 또한, KDI와 KIF 등의 전망처럼 GDP 성장률이 0.8%까지 떨어질 가능성이 제기되고 있으며, 자본 조달 비용 상승과 투자 여력 취약으로 인해 젊은 세대가 경제적으로 독립하기 어려운 환경입니다.</p>

<p>이러한 저성장 국면에서 앞으로 장기적인 경기 침체가 예상되는 가운데, 정부의 반기업적 정책은 상황을 더욱 악화시키고 있습니다. 정책 기조가 현재와 같이 유지된다면 창업 기회와 일자리가 더욱 줄어들 것으로 보입니다. 예를 들어, 규제 강화와 세제 개편 등으로 기업 해외 유출이 가속화되고, 중소기업 몰락 및 자영업자 폐업이 증가할 전망입니다.</p>

<p>이처럼 불확실한 시대에서, 0에서 시작하여 최소한으로는 경제적 안정, 나아가 경제적 부를 추구하는 것은 거의 불가능해지고 있습니다. 무턱대고 ‘고의적으로’ 경제적 결핍을 물려준다면, 자녀에게 회복하기 어려운 치명적인 상처를 남길 수 있으며, 결국 가난의 굴레에서 영원히 벗어나지 못하게 될 가능성이 높아집니다. 초기 자본, 예를 들어 주식 계좌를 통해 쌓인 자산은 이런 불확실한 경제 환경에서 안정적인 출발점을 제공해, 더 큰 꿈을 추구할 수 있는 기반이 될 수 있습니다. 이에 대한 근거는 다음 섹션에서 상세하게 설명하겠습니다.</p>

<p> </p>

<h4 id="성장의-의미와-경제적-결핍의-상관관계"><strong>성장의 의미와 경제적 결핍의 상관관계</strong></h4>

<p>‘성장’이라는 개념이 정확히 무엇을 의미하는지 모호합니다. 귀하께서는 “스스로 성장을 멈추는 경우”를 언급하시며, 경제적 여유가 노력의 동기를 약화시킨다고 보시는 듯합니다. 그러나 성장의 정의는 사람마다 다를 수 있으며, 반드시 경제적 결핍에서만 비롯되는 것은 아닙니다. 가난한 사람이 반드시 성장을 이루리라는 보장이 없으며, 성장의 원동력과 가난의 여부는 특별한 상관관계가 없다는 것을 고려해야 합니다.</p>

<p>오히려 일반적인 통념과 다르게, 경제적 밑바탕이 있으면 안정적으로 도전할 수 있는 기회가 많아지는 것이 사실입니다. 예를 들어, 엔비디아 창업자 젠슨 황의 경우처럼 가난한 배경에서 성공한 사례도 있지만, 이는 예외적일 수 있으며, 실제로 많은 성공한 창업자들은 부유한 가정의 지원을 바탕으로 출발했습니다.</p>

<p>실제로, 부자 집안 출신이 새로운 창업 등에서 성공한 사례가 훨씬 더 많습니다. 마크 주커버그는 페이스북(현 메타)을 시작할 때 아버지로부터 10만 달러의 대출을 받았으며, 빌 게이츠는 부유하고 성공적인 부모님의 배경에서 자라 마이크로소프트를 창업했습니다. 일론 머스크 역시 부유한 가정에서 성장하며 테슬라와 스페이스X를 이끌었습니다. 한국에서도 카카오의 김범수 의장은 가난한 배경에서 성공했지만, 많은 스타트업 창업자들이 학벌이 좋고 중상층 이상의 안정된 환경에서 출발해 성공을 거두는 경우가 일반적입니다. 이러한 사례들은 경제적 여유가 성장을 방해하기보다는, 오히려 더 큰 성취를 가능하게 한다는 점을 보여줍니다.</p>

<p> </p>

<h4 id="굳이-경제적-궁핍은-물려주는-것은-불필요"><strong>굳이 ‘경제적 궁핍’은 물려주는 것은 불필요</strong></h4>

<p>부모의 역할은 자녀가 세상에 홀로 설 힘을 기르도록 돕는 것이라는 귀하의 말씀에 동의합니다. 다만, 이를 위해 경제적 결핍을 ‘선물’하는 대신, 적절한 자산과 장기적으로 인생에서 도움이 될만한 경제적인 안목을 제공하는 것을 우선으로 하여 책임감과 투자 교육을 병행하는 접근이 더 균형적일 수 있습니다. 투자 행위도 결국에는 밑천이 있어야 가능한 것입니다. 밑천이 없으면 빚을 내서 투자를 시작할 수 밖에 없으며, 이에 더해 경제적 관념이 부재된 상태라면 어떠한 투자를 해도 빚더미에 앉은 채 실패하게 될지도 모릅니다. 40대 이후에 돈이 필요하다는 점도 이해하지만, 앞서 언급한 사례들을 종합해 볼 때 20대부터의 최소한의 경제적 안정 및 자산에 대한 안목이 장기적으로 더 건강한 성장을 촉진할 가능성이 큽니다.</p>

<p>이 의견이 귀하의 생각에 도움이 되기를 바랍니다. 자녀 교육은 정답이 없으니, 각자의 가치관에 따라 최선을 다하는 것이 중요하다고 믿습니다.</p>

<p> </p>

<p>[rcblock id=”6686”]</p>]]></content><author><name></name></author><category term="Blog" /><category term="정보글" /><summary type="html"><![CDATA[아래 인터넷의 한 글에 대한 Grok(생성형 인공지능)이 생성한 의견입니다.]]></summary></entry><entry><title type="html">음악 오케스트라 악보 스코어 용어 의미 (1)</title><link href="/posts/%EC%9D%8C%EC%95%85-%EC%98%A4%EC%BC%80%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%95%85%EB%B3%B4-%EC%8A%A4%EC%BD%94%EC%96%B4-%EC%9A%A9%EC%96%B4-%EC%9D%98%EB%AF%B8-1/" rel="alternate" type="text/html" title="음악 오케스트라 악보 스코어 용어 의미 (1)" /><published>2025-07-03T00:00:00+09:00</published><updated>2025-07-03T00:00:00+09:00</updated><id>/posts/%EC%9D%8C%EC%95%85-%EC%98%A4%EC%BC%80%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%95%85%EB%B3%B4-%EC%8A%A4%EC%BD%94%EC%96%B4-%EC%9A%A9%EC%96%B4-%EC%9D%98%EB%AF%B8-1</id><content type="html" xml:base="/posts/%EC%9D%8C%EC%95%85-%EC%98%A4%EC%BC%80%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%95%85%EB%B3%B4-%EC%8A%A4%EC%BD%94%EC%96%B4-%EC%9A%A9%EC%96%B4-%EC%9D%98%EB%AF%B8-1/"><![CDATA[<h4 id="bring-out"><strong>Bring Out</strong></h4>

<p><img src="./assets/img/wp-content/uploads/2025/07/스크린샷-2025-07-04-오전-2.22.58.jpeg" alt="" /></p>

<p>“Bring out”은 음악에서 _<strong>“부각시키다”, “두드러지게 연주하다”</strong>_라는 의미입니다.</p>

<p>베이스 클라리넷과 바순에 이 표시가 있다면, 해당 악기들이 연주하는 선율이나 리듬을 다른 악기들보다 더 명확하고 두드러지게 들리도록 연주하라는 지시입니다.</p>

<p>구체적으로는:</p>

<ul>
  <li>음량을 조금 더 크게 연주하여 다른 성부들 위로 선율이 떠오르도록 하기</li>
  <li>표현을 더 명확하게 하여 청중이 그 선율을 잘 들을 수 있도록 하기</li>
  <li>반주나 다른 성부들은 상대적으로 배경으로 물러나도록 조절하기</li>
</ul>

<p>베이스 클라리넷과 바순은 중저음역 악기들이라서, 때때로 다른 악기들에 묻혀서 잘 안 들릴 수 있는데, “bring out” 표시는 이런 상황에서 해당 악기의 역할을 청중에게 명확히 전달하라는 지휘자나 작곡가의 의도를 나타냅니다.</p>

<p> </p>

<h4 id="martellato-martell">martellato (martell.)</h4>

<p>이는 이탈리어 음악 용어로 <strong>“망치로 치듯이”</strong>라는 뜻입니다.</p>

<h5 id="피아노의-연주법상으로는"><strong>피아노의 연주법상으로는:</strong></h5>

<ul>
  <li>각 음을 강하고 명확하게 타격하듯이 연주</li>
  <li>손가락을 망치처럼 사용해서 건반을 단호하게 누름</li>
  <li>음과 음 사이를 분리해서 연주 (레가토의 반대)</li>
  <li>강조되고 날카로운 터치로 연주</li>
</ul>

<p>주로 강렬한 표현이 필요한 부분이나 리듬감을 살려야 하는 구간에서 사용되는 연주법입니다. 특히 행진곡풍의 음악이나 드라마틱한 클라이맥스 부분에서 자주 볼 수 있는 지시어입니다.</p>

<h5 id="목관악기에서-martellato는"><strong>목관악기에서 martellato는:</strong></h5>

<ul>
  <li><strong>텅잉을 강하고 명확하게</strong> - 혀로 리드나 마우스피스를 단호하게 끊어줌</li>
  <li><strong>각 음의 시작을 날카롭게</strong> - 마치 스타카토처럼 음의 어택을 강조</li>
  <li><strong>음과 음 사이를 분리</strong> - 레가토 없이 끊어서 연주</li>
  <li><strong>다이나믹을 강하게</strong> - 보통 forte나 fortissimo와 함께 사용</li>
</ul>

<p>피아노처럼 “망치로 치듯이”는 물리적으로 불가능하지만, 그와 같은 강렬하고 단호한 느낌을 텅잉과 호흡으로 표현하는 거죠.</p>

<p>특히 클라리넷이나 오보에 같은 리드 악기에서는 텅잉을 더 강하게 하고, 플루트에서는 공기를 더 집중적으로 불어넣어서 음의 시작을 날카롭게 만듭니다.</p>

<p>결국 “날카롭고 강렬하게”라는 음악적 의도는 같되, 악기 특성에 맞는 주법으로 표현하면 됩니다.</p>

<p> </p>

<h4 id="bell-tones-호른-트롬본에서"><strong>bell tones (호른, 트롬본에서)</strong></h4>

<p><img src="./assets/img/wp-content/uploads/2025/07/스크린샷-2025-07-04-오전-2.25.50.jpeg" alt="" /></p>

<p>“Bell tones”는 호른과 트롬본에서 사용하는 특수 주법입니다.</p>

<p><strong>호른의 bell tones:</strong></p>

<ul>
  <li>벨(나팔 부분) 안에 <strong>손을 완전히 막아서</strong> 연주</li>
  <li>일반적인 핸드호른 주법(손으로 음정 조절)과는 다름</li>
  <li>손으로 벨을 완전히 막으면 특별한 <strong>금속성의 울림</strong>이 나옴</li>
  <li>음정이 약간 변하고 음색이 매우 독특해짐</li>
  <li>보통 <strong>+ 기호</strong>나 <strong>“stopped”</strong>와 함께 표기되기도 함</li>
</ul>

<p><strong>트롬본의 bell tones:</strong></p>

<ul>
  <li>벨 끝부분을 <strong>손이나 뮤트로 막아서</strong> 연주</li>
  <li>또는 벨을 <strong>악보대나 다른 물체에 대고</strong> 연주하기도 함</li>
  <li>소리가 막혀서 <strong>뚫린 소리가 아닌 막힌 소리</strong>가 남</li>
  <li>음량이 줄어들고 음색이 어둡고 무겁게 변함</li>
</ul>

<p>두 악기 모두 벨을 막음으로써 평소와 다른 특별한 음색 효과를 만들어내는 기법입니다. 현대 음악이나 효과음이 필요한 곡에서 자주 사용됩니다.</p>

<p> </p>

<h4 id="risoluto"><strong>Risoluto</strong></h4>

<p>Risoluto는 음악 용어로 “결연하게”, “단호하게”라는 뜻의 이탈리아어 표현 지시어입니다.</p>

<p><strong>음악적 의미:</strong></p>

<ul>
  <li>연주자에게 확고하고 결단력 있는 표현으로 연주하라고 지시</li>
  <li>망설임 없이 명확하고 단호한 음향을 만들어내야 함</li>
  <li>보통 강한 다이내믹과 명확한 아티큘레이션을 동반</li>
</ul>

<p><strong>사용 예시:</strong></p>

<ul>
  <li>“Allegro risoluto” - 빠르고 결연하게</li>
  <li>“Andante risoluto” - 보통 빠르기로 단호하게</li>
  <li>베토벤, 브람스 등의 작품에서 자주 볼 수 있는 표현</li>
</ul>

<p><strong>연주상의 특징:</strong></p>

<ul>
  <li>음의 시작을 명확하게 공격</li>
  <li>프레이징이 확실하고 방향성이 뚜렷</li>
  <li>감정적으로는 의지적이고 남성적인 성격</li>
  <li>템포 루바토나 과도한 표현보다는 안정적이고 견고한 연주</li>
</ul>

<p>클래식 음악에서 작곡가가 특정한 감정이나 성격을 표현하고자 할 때 사용하는 중요한 음악적 지시어 중 하나입니다.</p>

<p> </p>

<h4 id="poco-조금-약간"><strong>poco (조금, 약간)</strong></h4>

<p>“Poco”는 이탈리아어로 “조금”, “약간”이라는 뜻입니다. 음악에서는 템포나 표현 기호와 함께 사용되어 “조금 더”, “약간 더”라는 의미로 쓰입니다.</p>

<p>음악에서 자주 사용되는 poco의 예시들:</p>

<ul>
  <li><strong>Poco a poco</strong> - 점진적으로, 조금씩</li>
  <li><strong>Poco ritardando (poco rit.)</strong> - 조금씩 느리게</li>
  <li><strong>Poco accelerando</strong> - 조금씩 빠르게</li>
  <li><strong>Poco forte</strong> - 조금 강하게</li>
  <li><strong>Poco più mosso</strong> - 조금 더 빠르게</li>
  <li><strong>Poco meno mosso</strong> - 조금 더 느리게</li>
</ul>

<p>이처럼 poco는 음악적 변화를 점진적이고 미묘하게 만들어 주는 역할을 합니다. 갑작스러운 변화가 아닌 자연스러운 흐름을 만들 때 사용하는 중요한 음악 용어입니다.</p>

<p> </p>

<h4 id="mosso-움직인-동요된"><strong>mosso (움직인, 동요된)</strong></h4>

<p>“Mosso”는 이탈리아어로 “움직인”, “동요된”이라는 뜻으로, 음악에서는 <strong>“빠르게”, “활발하게”</strong>라는 의미로 사용됩니다.</p>

<p>음악에서 mosso가 사용되는 주요 표현들:</p>

<ul>
  <li><strong>Più mosso</strong> - 더 빠르게, 더 활발하게</li>
  <li><strong>Meno mosso</strong> - 덜 빠르게, 더 느리게</li>
  <li><strong>Poco più mosso</strong> - 조금 더 빠르게</li>
  <li><strong>Poco meno mosso</strong> - 조금 더 느리게</li>
  <li><strong>Mosso</strong> (단독 사용) - 빠르게, 활발하게</li>
</ul>

<p>Mosso는 단순히 빠른 속도만을 의미하는 것이 아니라, 음악에 생동감과 움직임을 부여하는 표현입니다. 연주자에게 음악을 더 활기차고 역동적으로 연주하라는 지시를 나타냅니다.</p>

<p>특히 템포 변화를 나타낼 때 자주 사용되며, 악곡의 흐름에서 긴장감이나 에너지를 높이고 싶을 때 작곡가들이 사용하는 중요한 음악 용어입니다.</p>

<p> </p>

<h4 id="laissez-vibrer-lv"><strong>laissez vibrer (l.v.)</strong></h4>

<p><img src="./assets/img/wp-content/uploads/2025/07/스크린샷-2025-07-04-오전-2.28.40-복사본.jpg" alt="" /></p>

<p>타악기 악보에서 <strong>l.v.</strong>는 <strong>“laissez vibrer”</strong>(레세 비브레)의 줄임말입니다.</p>

<p><strong>의미:</strong></p>

<ul>
  <li>프랑스어로 “진동하게 두다”, “울림을 그대로 두다”라는 뜻</li>
  <li>영어로는 <strong>“let vibrate”</strong> 또는 <strong>“let ring”</strong></li>
</ul>

<p><strong>연주법:</strong></p>

<ul>
  <li>타악기(특히 심벌, 탐탐, 팀파니 등)를 친 후 <strong>소리를 억제하지 말고 자연스럽게 울리게 둔다</strong></li>
  <li>손이나 다른 방법으로 소리를 멈추지 않고 자연스럽게 소멸되도록 한다</li>
  <li>반대 개념은 <strong>“sec”</strong>(세크) 또는 <strong>“stopped”</strong>로, 이는 소리를 즉시 멈추라는 의미</li>
</ul>

<p><strong>주로 사용되는 악기:</strong></p>

<ul>
  <li>심벌(Cymbals)</li>
  <li>탐탐(Tam-tam)</li>
  <li>팀파니(Timpani)</li>
  <li>트라이앵글(Triangle)</li>
  <li>공(Gong)</li>
</ul>

<p>이 표시가 있으면 악기를 친 후 여운을 자연스럽게 흘려보내며 연주하시면 됩니다.</p>

<p> </p>

<h4 id="dampen-퍼커션"><strong>dampen (퍼커션)</strong></h4>

<p><img src="./assets/img/wp-content/uploads/2025/07/스크린샷-2025-07-04-오전-2.30.21.jpeg" alt="" /></p>

<p>퍼커션에서 <strong>dampen</strong>은 <strong>소리를 죽이다/막다</strong>는 뜻입니다.</p>

<p>구체적으로:</p>

<ul>
  <li>악기가 울리고 있는 소리를 손이나 몸으로 막아서 갑자기 끊어버리는 것</li>
  <li>진동을 멈춰서 여운을 없애는 기법</li>
</ul>

<p><strong>예시:</strong></p>

<ul>
  <li>심벌: 치고 난 후 손으로 심벌을 잡아서 울림을 멈춤</li>
  <li>팀파니: 손으로 드럼헤드를 살짝 눌러서 소리를 죽임</li>
  <li>공: 치고 난 후 손으로 공을 잡아서 진동을 멈춤</li>
</ul>

<p>악보에서는 보통 <strong>”+”</strong> 기호나 <strong>“damp”</strong>, <strong>“choke”</strong> 같은 표시로 나타냅니다. 연주자가 소리의 길이를 정확히 컨트롤할 수 있게 해주는 중요한 기법입니다.</p>

<p> </p>

<h4 id="loco"><strong>loco</strong></h4>

<p><img src="./assets/img/wp-content/uploads/2025/07/스크린샷-2025-07-04-오전-2.31.56.png" alt="" /></p>

<p>음악 용어에서 <strong>loco</strong>는 <strong>“원래 자리로”</strong>라는 뜻입니다.</p>

<p><strong>사용 상황:</strong></p>

<ul>
  <li>8va (옥타브 위로) 또는 8vb (옥타브 아래로) 표시가 있었던 부분이 끝나고 원래 음높이로 돌아갈 때 사용</li>
  <li>“이제 악보에 쓰여진 그대로 연주하세요”라는 의미</li>
</ul>

<p><strong>예시:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>[일반 연주] → 8va → [한 옥타브 위로 연주] → loco → [다시 원래 음높이로 연주]
</pre></td></tr></tbody></table></code></pre></div></div>

<p>라틴어에서 온 말로 “제자리에서, 본래 위치에서”라는 뜻입니다.</p>

<p> </p>

<h5 id="marcato"><strong>Marcato</strong></h5>

<p><img src="./assets/img/wp-content/uploads/2025/07/스크린샷-2025-07-04-오전-2.34.06.jpeg" alt="" /></p>

<p><strong>Marcato</strong>는 “강조하여, 힘있게”라는 뜻의 음악 용어입니다.</p>

<p><strong>의미:</strong></p>

<ul>
  <li>각 음을 명확하게 구분하여 강조해서 연주</li>
  <li>단순히 큰 소리가 아니라 “뚜렷하고 힘있게” 연주하는 것</li>
</ul>

<p><strong>악보 표기:</strong></p>

<ul>
  <li><strong>&gt;</strong> 또는 <strong>^</strong> 기호로 표시</li>
  <li><strong>marc.</strong> 또는 <strong>marcato</strong>로 문자 표기</li>
</ul>

<p><strong>연주법:</strong></p>

<ul>
  <li>각 음의 시작 부분을 특히 강조</li>
  <li>음들 사이를 명확히 구분</li>
  <li>날카롭고 결단력 있는 느낌으로 연주</li>
</ul>

<p><strong>다른 아티큘레이션과의 차이:</strong></p>

<ul>
  <li><strong>Accent(&gt;)</strong>: 단순히 그 음만 강하게</li>
  <li><strong>Marcato</strong>: 강조하면서도 각 음을 뚜렷하게 분리</li>
  <li><strong>Staccato</strong>: 짧게 끊어서</li>
  <li><strong>Legato</strong>: 부드럽게 연결해서</li>
</ul>

<p>이탈리아어로 “표시된, 강조된”이라는 뜻에서 왔습니다.</p>

<p>[rcblock id=”6686”]</p>]]></content><author><name></name></author><category term="StudyLog" /><category term="음악이론" /><summary type="html"><![CDATA[Bring Out]]></summary></entry><entry><title type="html">[악곡 분석] 요한 데 메이 (Johan de Meij): 교향곡 1번 “반지의 제왕”</title><link href="/posts/%EC%95%85%EA%B3%A1-%EB%B6%84%EC%84%9D-%EC%9A%94%ED%95%9C-%EB%8D%B0-%EB%A9%94%EC%9D%B4-johan-de-meij-%EA%B5%90%ED%96%A5%EA%B3%A1-1%EB%B2%88-%EB%B0%98%EC%A7%80%EC%9D%98-%EC%A0%9C%EC%99%95/" rel="alternate" type="text/html" title="[악곡 분석] 요한 데 메이 (Johan de Meij): 교향곡 1번 “반지의 제왕”" /><published>2025-06-29T00:00:00+09:00</published><updated>2025-06-29T00:00:00+09:00</updated><id>/posts/%EC%95%85%EA%B3%A1-%EB%B6%84%EC%84%9D-%EC%9A%94%ED%95%9C-%EB%8D%B0-%EB%A9%94%EC%9D%B4-johan-de-meij-%EA%B5%90%ED%96%A5%EA%B3%A1-1%EB%B2%88-%EB%B0%98%EC%A7%80%EC%9D%98-%EC%A0%9C%EC%99%95</id><content type="html" xml:base="/posts/%EC%95%85%EA%B3%A1-%EB%B6%84%EC%84%9D-%EC%9A%94%ED%95%9C-%EB%8D%B0-%EB%A9%94%EC%9D%B4-johan-de-meij-%EA%B5%90%ED%96%A5%EA%B3%A1-1%EB%B2%88-%EB%B0%98%EC%A7%80%EC%9D%98-%EC%A0%9C%EC%99%95/"><![CDATA[<h3 id="요한-데-메이johan-de-meij의-교향곡-1번-반지의-제왕-symphony-no1-the-lord-of-the-rings"><strong>요한 데 메이(Johan de Meij)의 교향곡 1번 “반지의 제왕”</strong> <strong>Symphony No.1 “The Lord of the Rings”</strong></h3>

<p>https://www.youtube.com/watch?v=nLmA42rH7wo</p>

<p>Amsterdam Wind Orchestra, 지휘 Arie van Beek 연주 전악장</p>

<h4 id="핵심-내용"><strong>핵심 내용</strong></h4>

<ul>
  <li>이 교향곡은 J.R.R. 톨킨의 소설 “반지의 제왕”을 바탕으로 한 5악장 작품으로, 1984~1987년 (당시 작곡가의 나이 30대)에 작곡되었습니다.</li>
  <li>각 악장은 소설의 주요 등장인물이나 에피소드를 음악적으로 표현하며, 관악 합주단(윈드 오케스트라, 콘서트 밴드 등)를 위한 독창적인 작품입니다.</li>
  <li>1988년 초연 후 1989년 Sudler Composition Award를 수상했으며, 2001년 오케스트라 버전도 발표되었습니다.</li>
</ul>

<p> </p>

<h4 id="소개"><strong>소개</strong></h4>

<p>요한 데 메이의 교향곡 1번 “반지의 제왕”은 톨킨의 동명 문학을 관악 합주단을 위한 음악으로 재해석한 대표적인 작품으로, 각 악장이 간달프(Gandalf), 로스로리엔(Lothlorien), 골룸(Gollum), 모리아 광산 여정, 호빗(Hobbits) 등 소설의 핵심 요소를 담고 있습니다. 이 교향곡은 관악기의 풍부한 음색을 활용해 소설의 분위기를 생생하게 전달하며, 문학적 해석과 음악적 창의성을 결합한 예술 작품으로 평가받습니다.</p>

<p>2001년 풀 오케스트라 버전(Henk de Vlieger 편곡) 출시를 비롯하여 팡파르 밴드, 영국식 브라스 밴드 등 다양한 악단을 위한 에디션이 출시되었습니다. 2013년 출간 25주년을 맞이해 <a href="http://www.symphony1-lordoftherings.com/">웹사이트 및 서적</a>이 출간되었습니다. 2023년 <a href="https://johandemeij.com/post/305">개정 버전</a>이 출간되었습니다.</p>

<p>참고로 영화 “반지의 제왕”과 해당 사운드트랙(하워드 쇼어 작곡)과는 관련이 없으며, 출판연도도 1988-1989년으로 영화 시리즈보다 약 12년 먼저 나온 별개의 작품입니다.</p>

<p> </p>

<h4 id="악장별-설명"><strong>악장별 설명</strong></h4>

<p>아래는 각 악장의 간략한 설명과 음악적 특징입니다:</p>

<ul>
  <li><strong>I. GANDALF (The Wizard)</strong>: 간달프의 지혜와 활기를 장엄한 모티프로 표현, 간달프의 강인한 성격을 보여줍니다. 중간 새도우팍스(Shadowfax)를 타는 부분은 Allegro vivace로 시작해 장면을 표현합니다.</li>
  <li><strong>II. LOTHLORIEN (The Elvenwood)</strong>: 엘프의 숲인 로스로리엔의 자연을 목관악기로 묘사합니다, 중간 부분 프로도와 갈라드리엘의 만남을 섬뜩하게 묘사합니다.</li>
  <li><strong>III. GOLLUM (Sméagol)</strong>: 골룸의 복잡하고 이중적인 성격을 소프라노 색소폰으로 표현합니다, 중얼거림과 사악함을 강조합니다.</li>
  <li><strong>IV. JOURNEY IN THE DARK (어둠 속의 여정)</strong>: 모리아 광산의 긴장감과 공포를 저음 금관과 타악기로 묘사, 간달프의 희생을 서사적으로 표현함으로써 악장이 마무리됩니다.</li>
  <li><strong>V. HOBBITS</strong>: 전반부는 호빗들의 낙관적 성격을 민속적인 멜로디로 묘사하며 결의를 찬송가(Hymn)로 표현합니다. 마지막은 “회색 항구(The Grey Havens)”를 묘사하며 평화로운 마무리로 끝납니다.</li>
</ul>

<p> </p>

<p> </p>

<h3 id="요한-데-메이의-교향곡-1번-반지의-제왕-분석"><strong>요한 데 메이의 교향곡 1번 “반지의 제왕” 분석</strong></h3>

<p>요한 데 메이(Johan de Meij)의 교향곡 1번 “반지의 제왕”(Symphony No. 1 “The Lord of the Rings”)은 J.R.R. 톨킨의 동명 소설을 음악적으로 재해석한 작품으로, 1984년부터 1987년 사이에 작곡되었습니다. 이 교향곡은 원래 관악 합주단을 위한 작품으로, 1988년 3월 15일 브뤼셀에서 Groot Harmonieorkest van de Belgische Gidsen에 의해 초연되었으며, Norbert Nozy가 지휘했습니다. 1989년 Sudler Composition Award를 수상하며 국제적인 주목을 받았으며, 2001년 헨크 데 플리허(Henk de Vlieger)에 의해 오케스트라 버전으로 편곡되어 런던 심포니 오케스트라(London Symphony Orchestra)에 의해 녹음되었습니다.</p>

<p> </p>

<h4 id="배경-및-구성"><strong>배경 및 구성</strong></h4>

<p><a href="https://johandemeij.com/">요한 데 메이(Johan de Meij)</a>는 네덜란드의 작곡가, 지휘자, 트롬본 연주자로, 1953년 네덜란드 Voorburg에서 태어났습니다. 그는 헤이그 왕립 음악원에서 트롬본과 지휘를 공부했으며, 이 교향곡은 그의 초기 대표작 중 하나로, 톨킨의 소설에 깊은 영감을 받아 창작되었습니다. 이 작품은 총 5개의 악장으로 구성되며, 각 악장은 소설의 주요 인물이나 에피소드를 음악적으로 표현합니다. 아래 표는 각 악장의 제목과 대략적인 지속 시간을 보여줍니다:</p>

<table>
  <thead>
    <tr>
      <th>악장 번호</th>
      <th>제목</th>
      <th>지속 시간</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>I</td>
      <td>GANDALF (The Wizard)</td>
      <td>5:50</td>
    </tr>
    <tr>
      <td>II</td>
      <td>LOTHLORIEN (The Elvenwood)</td>
      <td>7:50</td>
    </tr>
    <tr>
      <td>III</td>
      <td>GOLLUM (Sméagol)</td>
      <td>10:20</td>
    </tr>
    <tr>
      <td>IV</td>
      <td>JOURNEY IN THE DARK</td>
      <td>8:05</td>
    </tr>
    <tr>
      <td>V</td>
      <td>HOBBITS</td>
      <td>9:00</td>
    </tr>
  </tbody>
</table>

<p>총 연주 시간은 약 43분 35초로, 난이도는 악장에 따라 약간씩 차이가 있으나 전반적으로 VI(최상급)로 평가됩니다. 특히 3악장 “골룸”은 복잡한 리듬과 잦은 변박, 넓은 음역 등으로 상급 프로의 연주 실력을 요구합니다.</p>

<p> </p>

<h4 id="악장별-상세-분석"><strong>악장별 상세 분석</strong></h4>

<h5 id="i-gandalf-the-wizard---마법사-간달프"><strong>I. GANDALF (The Wizard) - 마법사 간달프</strong> </h5>

<p>https://www.youtube.com/watch?v=9MAf3K0SYfs&amp;pp=ygUYam9oYW4gZGUgbWVpaiBzeW1waG9ueSAx</p>

<p><img src="./assets/img/wp-content/uploads/2025/06/gandalf.jpeg" alt="" /></p>

<ul>
  <li>
    <p><strong>설명</strong>: 이 악장은 <a href="https://ko.wikipedia.org/wiki/%EA%B0%84%EB%8B%AC%ED%94%84">간달프</a>의 음악적 초상화로, 그의 지혜롭고 고귀한 성격을 표현하기 위해 장엄한 모티프가 사용됩니다. 이 모티프는 4악장과 5악장에서도 재등장하며, 교향곡의 구조적 통일성을 강화합니다. 악장은 “풍부하며 장엄한 테마”로 시작하며, 간달프의 강인한 성격을 보여줍니다. 이후 “섀도우팍스(Shadowfax)” 위에서의 야생적인 달리기를 묘사하는 부분이 이어집니다.</p>

    <p>[caption id=”attachment_7145” align=”alignnone” width=”346”]<img src="./assets/img/wp-content/uploads/2025/06/shadowfax.jpeg" alt="" /> 영화에 등장하는 Shadowfax[/caption]</p>
  </li>
  <li>간달프는 지혜롭고 강력한 지도자로, 반지 원정대 (Fellowship)라 불리는 그룹의 여정을 이끌며 마법과 지혜를 구사하는 핵심 인물입니다.</li>
  <li>간달프의 성격은 장엄한 모티프를 통해 표현되며, 이는 금관악기의 팬파레로 시작됩니다. Allegro vivace 부분은 그의 활발하고 예측 불가능한 면을 음악적으로 구현한 것으로, 빠른 템포와 복잡한 리듬이 특징입니다. 이 악장은 간달프의 마법사로서의 위대함과 동시에 그의 인간적인 면을 동시에 담고 있습니다. <a href="https://windliterature.org/2010/10/19/symphony-no-1-lord-of-the-rings-by-johan-de-meij/">Symphony no. 1 “Lord of the Rings” by Johan de Meij</a>에 따르면, 이 악장은 그의 지도적 역할과 동료들에 대한 헌신을 강조합니다.</li>
</ul>

<p> </p>

<h5 id="ii-lothlorien-the-elvenwood---엘프의-숲-로스로리엔"><strong>II. LOTHLORIEN (The Elvenwood) - 엘프의 숲 로스로리엔</strong></h5>

<p>https://www.youtube.com/watch?v=060j5MQgv4Y</p>

<p><img src="./assets/img/wp-content/uploads/2025/06/ae051076b6e3469e98152f9bf2d832af83e77696_hq.jpg" alt="" /></p>

<ul>
  <li><strong>설명</strong>: 로스로리엔의 분위기를 음악적으로 표현한 악장으로, 나무, 식물, 그리고 이국적인 새들의 소리로 가득 찬 엘프의 숲을 묘사합니다. 로스로리엔은 반지 원정대가 잠시 쉬고 회복하는 안전한 장소로, 엘프의 숲, 엘프의 영역으로 묘사됩니다.</li>
  <li>Allegretto 부분은 프로도가 갈라드리엘 여왕을 만나는 장면을 담고 있으며, 갈라드리엘의 거울에서 보는 세 가지 비전, 그중에서도 마지막으로 나타나는 거대한 섬뜩한 눈(사우론의 눈)이 프로도를 혼란스럽게 만드는 장면으로 마무리됩니다.</li>
  <li>이 악장은 목관악기의 솔로를 통해 로스로리엔의 아름다운 자연을 생생하게 묘사합니다. Allegretto 부분은 부드럽고 매력적인 멜로디로 프로도와 갈라드리엘의 만남을 표현하며, 갈라드리엘의 거울에서의 비전은 음악적으로 점차 긴장감을 높여 마지막에 이르러 섬뜩한 분위기를 자아냅니다.</li>
</ul>

<p> </p>

<h5 id="iii-gollum-sméagol---골룸-스메아골-스미골"><strong>III. GOLLUM (Sméagol) - 골룸 (스메아골, 스미골)</strong></h5>

<p>https://www.youtube.com/watch?v=jbptS62Az_c</p>

<p><img src="./assets/img/wp-content/uploads/2025/06/Gollum_s_journey_commences_by_Frederic_Bennett_detail.jpg" alt="" /></p>

<ul>
  <li><strong>설명</strong>: <a href="https://ko.wikipedia.org/wiki/%EA%B3%A8%EB%A3%B8">골룸</a>의 음악적 표현으로, 그의 비굴하고 사악한 성격을 담고 있습니다. 골룸은 반지의 이전 소유자로, 반지의 힘에 사로잡혀 스메아골(그의 이중 인격)과 골룸의 갈등을 가진 슬픈 존재입니다. 이 악장은 그의 괴물 같은 본성을 소프라노 색소폰을 통해 표현됩니다.</li>
  <li>골룸은 소프라노 색소폰으로 표현되며, 중얼거림, 쉿거림, 울음, 그리고 히죽거림 등 다양한 음색을 통해 그의 복잡한 성격을 묘사합니다. 그는 항상 반지를 찾는 모습으로 그려집니다.</li>
  <li><strong>음악적 분석</strong>: 골룸의 음악은 그의 불안정하고 이중적인 성격을 반영하며, 소프라노 색소폰의 독특한 음색을 활용해 그의 목소리와 같은 효과를 내는 것이 특징입니다. 이 악장은 골룸의 비굴함과 사악함 사이의 균형을 음악적으로 잘 표현하고 있습니다.</li>
</ul>

<p> </p>

<h5 id="iv-journey-in-the-dark---어둠-속의-여정"><strong>IV. JOURNEY IN THE DARK - 어둠 속의 여정</strong></h5>

<p>https://www.youtube.com/watch?v=gzyV1sJjDis</p>

<p><img src="./assets/img/wp-content/uploads/2025/06/images.jpeg" alt="" /></p>

<ul>
  <li><strong>설명</strong>: <a href="https://en.wikipedia.org/wiki/Moria,_Middle-earth">모리아 광산</a>(Mines of Moria)을 통과하는 동료들의 위험한 여정을 묘사한 악장입니다.  시간대의 표현이 애매모호한 다른 악장과 달리 확실한 시간대와 사건을 묘사하고 있는 것이 특징입니다.</li>
  <li>하위 악장 a - 모리아 광산, b - 카자드 둠 다리 로 나뉘어져 있습니다. 모리아 광산은 반지 원정대가 겪는 가장 위험한 장소입니다.</li>
  <li>느린 걸음걸이의 cadence와 어두운 분위기의 저음 금관, 피아노, 타악기의 단조로운 리듬을 통해 공포를 표현합니다. 오크들의 추격, 간달프와 발로그의 전투, 그리고 카자드-둠 다리에서의 간달프의 추락이 포함됩니다. 간달프의 희생이 음악적으로 극적인 클라이맥스로 표현됩니다. 이윽고 악장은 동료들이 모리아의 동문(East Gate of Moria)을 찾는 장면으로 마무리되며, Marcia funèbre(장례 행진)로 끝납니다.</li>
  <li>이 악장은 음악적으로 긴장감과 공포를 극대화하며, 원정대 동료들의 절망과 간달프의 희생을 강렬하게 표현합니다. Marcia funèbre는 간달프의 죽음을 애도하는 듯한 분위기를 더합니다. 소설의 긴장감을 음악적으로 반영되었습니다.</li>
</ul>

<p> </p>

<h5 id="v-hobbits-호빗들"><strong>V. HOBBITS (호빗들)</strong></h5>

<p>https://www.youtube.com/watch?v=W0KLTU5vrxw</p>

<p><img src="./assets/img/wp-content/uploads/2025/06/dara-kostromova-unicorngunter-razvorot-gnomy2-복사본.jpg" alt="" /></p>

<ul>
  <li><strong>설명</strong>: 호빗들의 천진난만하고 낙관적인 성격을 표현한 악장으로, 행복한 민속춤으로 시작됩니다. 이후 찬송가 같은 부분이 등장하며, 호빗들의 결의와 고귀함을 보여줍니다. 악장은 “회색 항구(The Grey Havens)”의 분위기를 반영하며, 프로도와 간달프가 배를 타고 떠나는 평화로운 장면으로 마무리됩니다.</li>
  <li><a href="https://tonaldiversions.com/2014/07/31/sym1-mvt5-hobbits-demeij/">Learn About the Hobbits Through de Meij’s Famous Symphony</a>에 따르면, 이 악장은 호빗들의 삶을 “일상(slice of life)”으로 묘사하며, 1악장 간달프의 테마가 금관악기의 호른 콜과 팡파레의 형태를 통해 다시 시작됩니다.</li>
  <li>호빗들의 밝고 경쾌한 성격은 민속춤을 통해 생동감 있게 표현되며, 찬송가(Hymn) 부분은 그들의 깊은 감정과 결의를 담고 있습니다. 마지막 부분은 전체 교향곡의 여정과 감정을 정리하며, 평온하고 수려한 분위기로 끝맺습니다.</li>
</ul>

<p> </p>

<h4 id="음악적-특징-및-의의"><strong>음악적 특징 및 의의</strong></h4>

<p>이 교향곡은 관악 합주단을 위한 작품으로, 관악기의 다양한 음색과 표현력을 활용해 톨킨의 세계를 생생하게 묘사합니다. 각 악장은 독립적이지만, 간달프의 모티프와 같은 연결된 테마를 통해 통일성을 유지합니다. 예를 들어 1악장의 간달프의 테마는 4, 5악장에서 재등장하며 교향곡의 서사적 통일성을 강화합니다.</p>

<p>[caption id=”attachment_7151” align=”alignnone” width=”980”]<img src="./assets/img/wp-content/uploads/2025/06/스크린샷-2025-06-29-오후-10.45.24.png" alt="" /> 1악장 “The Gandalf” 테마의 일부[/caption]</p>

<p>반지의 제왕의 세계관과 서사를 묘사한 것이 특징이지만 악장의 순서는 반드시 소설의 순서와 일치하지는 않습니다. 4악장의 경우를 제외하면 구체적인 시간대와 사건에 대한 묘사보다는 인물이나 장소의 묘사에 중점을 두고 있습니다.</p>

<p>관악 합주단을 위한 45분 분량의 대형 교향곡이라는 점도 매우 큰 특징입니다. 일반적으로 정통 교향곡의 연주보다는 팝 콘서트, 군악대, 학교의 아마추어 밴드 등에서 활약한다고 인식되고 있던 관악 합주단의 특징과 강점을 전면으로 활용한 작품으로 금관, 목관, 타악기 등 다양한 관악 합주단의 악기를 활용하여 풍부한 음색과 표현력을 구사합니다. 특히, 3악장의 소프라노 색소폰의 사용은 골룸의 독특한 성격을 선명하게 묘사하고 강조한 것으로 이름이 높습니다.</p>

<blockquote>
  <p>_“_45분짜리 관악 오케스트라를 위한 교향곡을 작업한다고요? 아무도 그런 곡을 연주하지 않을 겁니다.” 약 30년 전, 요한 데 메이가 첫 교향곡을 작곡하기로 마음먹었을 때 많은 사람들이 반대했습니다. 작품 번호 1번이라는 사실 또한 그에게 큰 자신감을 주지 못했습니다. 25년 동안 수천 번의 연주와 수십 번의 녹음을 거치면서 우리는 이제 그러한 친절한 경고가 완전히 틀렸음을 알게 되었습니다. 교향곡 1번, 반지의 제왕은 단번에 데 메이를 관악 오케스트라 최고의 작곡가로 세계적인 명성을 얻게 해 주었고, 그는 이후 교향곡과 다른 작품들을 통해 오늘날까지도 그 지위를 유지하고 있습니다.</p>
</blockquote>

<p>특히, 이 작품은 소설의 문학적 요소를 음악적으로 해석하며, 독자들에게 새로운 감상 경험을 제공합니다. 2001년 영화 “반지의 제왕”의 음악(하워드 쇼어 작곡)과 비교할 때, 데 메이의 작품이 약 12년 먼저 출판되었으며 데 메이의 교향곡이 소설의 본질을 더 직접적으로 음악적으로 표현한다는 평가를 받기도 합니다.</p>

<p> </p>

<h4 id="문화적-및-역사적-맥락"><strong>문화적 및 역사적 맥락</strong></h4>

<p>이 교향곡은 톨킨의 소설이 음악적으로 어떻게 해석될 수 있는지를 보여주는 중요한 사례로, 1980년대 후반부터 1990년대 초반의 밴드 및 현대 음악계에서 큰 주목을 받았습니다. 특히, 이 작품은 관악 합주단 레퍼토리에서 중요한 위치를 차지하며, 교육과 공연에서 자주 사용됩니다. <a href="https://en.wikipedia.org/wiki/Symphony_No._1_The_Lord_of_the_Rings">Symphony No. 1 The Lord of the Rings - Wikipedia</a>와 <a href="https://www.windrep.org/Symphony_I_%28de_Meij%29">Symphony I (de Meij) - Wind Repertory Project</a>에 따르면, 이 교향곡은 다양한 오케스트라와 밴드에 의해 녹음되었으며, 국제적인 명성을 얻었습니다.</p>

<ul>
  <li><a href="https://classical.music.apple.com/kr/work/johan-de-meij-1953-pp41?l=ko-KR">애플뮤직 클래식에서 레코딩 살펴보기</a></li>
</ul>

<p> </p>

<h4 id="결론"><strong>결론</strong></h4>

<p>요한 데 메이의 교향곡 1번 “반지의 제왕”은 톨킨의 소설을 음악적으로 탁월하게 해석한 작품으로, 각 악장은 소설의 인물과 에피소드를 생생하게 묘사합니다. 음악적으로는 관악기의 다양한 가능성을 활용해 톨킨의 세계를 표현하며, 톨킨의 문학 세계를 비롯한 문화적으로도 중요한 의미를 가집니다. 이 작품은 단순히 소설의 음악적 해석을 넘어, 독창적이고 감동적인 음악적 경험을 제공합니다.</p>

<p> </p>

<h4 id="주요-인용"><strong>주요 인용</strong></h4>

<ul>
  <li><a href="https://en.wikipedia.org/wiki/Symphony_No._1_The_Lord_of_the_Rings">Symphony No. 1 The Lord of the Rings - Wikipedia</a></li>
  <li><a href="https://windliterature.org/2010/10/19/symphony-no-1-lord-of-the-rings-by-johan-de-meij/">Symphony no. 1 “Lord of the Rings” by Johan de Meij</a></li>
  <li><a href="https://tonaldiversions.com/2014/07/31/sym1-mvt5-hobbits-demeij/">Learn About the Hobbits Through de Meij’s Famous Symphony</a></li>
  <li><a href="https://www.windrep.org/Symphony_I_%28de_Meij%29">Symphony I (de Meij) - Wind Repertory Project</a></li>
</ul>]]></content><author><name></name></author><category term="Favorite Music" /><category term="Band Music" /><summary type="html"><![CDATA[요한 데 메이(Johan de Meij)의 교향곡 1번 “반지의 제왕” Symphony No.1 “The Lord of the Rings”]]></summary></entry><entry><title type="html">[악곡 상세 분석] 로버트 W. 스미스 (Robert W. Smith): 인천 (Inchon)</title><link href="/posts/%EC%95%85%EA%B3%A1-%EC%83%81%EC%84%B8-%EB%B6%84%EC%84%9D-%EB%A1%9C%EB%B2%84%ED%8A%B8-w-%EC%8A%A4%EB%AF%B8%EC%8A%A4-robert-w-smith-%EC%9D%B8%EC%B2%9C-inchon/" rel="alternate" type="text/html" title="[악곡 상세 분석] 로버트 W. 스미스 (Robert W. Smith): 인천 (Inchon)" /><published>2025-06-25T00:00:00+09:00</published><updated>2025-06-25T00:00:00+09:00</updated><id>/posts/%EC%95%85%EA%B3%A1-%EC%83%81%EC%84%B8-%EB%B6%84%EC%84%9D-%EB%A1%9C%EB%B2%84%ED%8A%B8-w-%EC%8A%A4%EB%AF%B8%EC%8A%A4-robert-w-smith-%EC%9D%B8%EC%B2%9C-inchon</id><content type="html" xml:base="/posts/%EC%95%85%EA%B3%A1-%EC%83%81%EC%84%B8-%EB%B6%84%EC%84%9D-%EB%A1%9C%EB%B2%84%ED%8A%B8-w-%EC%8A%A4%EB%AF%B8%EC%8A%A4-robert-w-smith-%EC%9D%B8%EC%B2%9C-inchon/"><![CDATA[<p>[caption id=”attachment_7133” align=”aligncenter” width=”484”]<img src="./assets/img/wp-content/uploads/2025/06/inchoen_ayaysir0.jpg" alt="" /> 로버트 W 스미스 Robert W. Smith - 인천 Inchon (2001)[/caption]</p>

<blockquote>
  <p>작곡가 로버트 스미스의 아버지는 한국 625 전쟁에 참가한 참전용사라고 합니다. 이 음악은 한국전쟁 당시 인천 상륙 작전을 묘사하고 있으며, 음악 곳곳에 한국적인 요소들이 들어있습니다. 중간의 헬리콥터 소리는 헬리콥터 실제 소리가 아닌 타악기로 헬리콥터 소리를 흉내를 낸 것입니다. [작곡가의 코멘트 중]</p>
</blockquote>

<iframe width="560" height="315" src="https://www.youtube.com/embed/37VxcASEASo" frameborder="0" allowfullscreen="allowfullscreen"></iframe>

<p>https://www.youtube.com/watch?v=9n8byjQ2ku4</p>

<p> </p>

<h3 id="악보-일부-번역"><strong>악보 일부 번역</strong></h3>

<h4 id="헬리콥터-사운드를-연주하는-퍼커션percussions"><strong>헬리콥터 사운드를 연주하는 퍼커션(Percussions)</strong></h4>

<h5 id="헬리콥터-효과의-위치-설정"><strong>헬리콥터 효과의 위치 설정</strong></h5>

<p>헬리콥터 효과는 6명의 무대 밖 타악기 연주자를 추가로 배치할 때 가장 효과적으로 구현됩니다. 이들은 공연장 곳곳에 흩어져 배치되어야 하며, 각 위치는 다음과 같이 설정합니다 (도면 참조).</p>

<p><img src="./assets/img/wp-content/uploads/2025/06/Inchon-Percussion-Cue.png" alt="" /></p>

<ul>
  <li>스테이션 1: 공연장 뒤쪽 구석, 가능하면 발코니 구역에 1명 배치</li>
  <li>스테이션 2: 스테이션 1과 대각선 방향으로 15~20피트(약 4.5~6미터) 전방, 반대편 발코니 쪽에 1명 배치</li>
  <li>스테이션 3: 1층 맨 뒤, 양쪽 구석에 2명 배치</li>
  <li>스테이션 4: 무대 전방에서 약 10피트(약 3미터) 떨어진 좌우 구석에 2명 배치</li>
  <li>스테이션 5: 무대 위 타악기 파트(battery percussion) 담당</li>
</ul>

<p> </p>

<h5 id="헬리콥터-효과에-필요한-악기-및-연주-방식"><strong>헬리콥터 효과에 필요한 악기 및 연주 방식</strong></h5>

<p>이 효과에 참여하는 모든 타악기 연주자는 단일 베이스드럼 헤드(marching bass drum에서 분리한 오래된 헤드도 무방)를 하나씩 사용합니다. 드럼 헤드의 크기는 26~34인치 범위로 다양하게 준비합니다.</p>

<p>(* 단일 베이스 드럼 헤드: 베이스드럼의 앞·뒷면을 덮는 투명하거나 흰색의 플라스틱 막(헤드) 중 하나만 떼어내어, 별도의 드럼 쉘 없이 그 자체를 바닥에 두고 연주, detached drum head)</p>

<p>헬리콥터의 회전 날개 소리는, 스네어드럼 스틱의 뒷부분이나 나무 재질의 베이스드럼 말렛을 사용하여 느린 16분음표로 드럼헤드를 두드리며 표현됩니다 (행진용 스네어 스틱이 적합).</p>

<h5 id="연주-시-유의-사항"><strong>연주 시 유의 사항</strong></h5>

<ul>
  <li>16분음표는 더블 스트로크 없이 단타로 연주해야 합니다.</li>
  <li>각 스테이션에서는 일관되고 균일한 리듬으로 16분음표를 유지해야 합니다.</li>
</ul>

<h5 id="음색-개선-팁"><strong>음색 개선 팁</strong></h5>

<ul>
  <li>보다 현실적인 헬리콥터 음색을 위해, 6명의 타악기 연주자 중 3명은 드럼헤드를 대형 행진용 베이스드럼 위에 올려놓고 연주하는 방식이 효과적이었습니다.</li>
  <li> 드럼헤드 위에 타월을 덮어 종이 같은 얇은 소리를 방지하는 실험도 했지만, 소리가 지나치게 뭉개지지 않도록 주의해야 합니다.</li>
</ul>

<p>https://www.youtube.com/watch?v=U-G-Dkw0SGA</p>

<h5 id="악곡-초반부---헬리콥터의-등장"><strong>악곡 초반부 - 헬리콥터의 등장</strong></h5>

<p>13마디에서 총 다섯 개의 페르마타(fermatas)가 표시되어 있으며, 이는 헬리콥터가 “공연장 안으로 날아 들어오는” 연출을 위한 구간입니다. 각 스테이션은 지시에 따라 피아니시모(pianissimo)에서 시작하여 메조 포르테(mezzo forte) 및 포르티시모(fortissimo)로 크레셴도(crescendo)한 뒤, 점차 멀어지는 듯 사라지도록 연주합니다.</p>

<p> </p>

<p><strong>지시에 따른 음악적 진행:</strong></p>

<ul>
  <li>지시 #1: 스테이션 1이 피아니시모에서 메조 포르테까지 크레셴도를 시작합니다. 해당 다이내믹에 도달하면, 지휘자는 스테이션 2에 신호를 줍니다.</li>
  <li>지시 #2: 스테이션 1은 포르티시모까지 강하게 크레셴도하며, 스테이션 2는 메조 포르테까지 크레셴도합니다.</li>
  <li>지시 #3: 스테이션 1은 긴 디크레셴도(decrescendo)를 시작하고, 스테이션 2는 크레셴도를 마무리하며 포르티시모에 도달합니다. 이와 동시에, 스테이션 3은 피아니시모로 입장하여 메조 포르테까지 크레셴도를 시작합니다.</li>
  <li> 지시 #4: 스테이션 1은 완전히 소멸하고, 스테이션 2는 메조 포르테까지 디크레셴도합니다. 스테이션 3은 포르티시모까지 크레셴도합니다.</li>
  <li>지시 #5: 스테이션 5가 입장하여 크레셴도를 시작하며, 스테이션 3, 4, 5가 함께 18마디에서의 강렬한 임팩트로 동시에 크레셴도합니다.</li>
</ul>

<p> </p>

<h5 id="악곡-중반부"><strong>악곡 중반부</strong></h5>

<p>135마디에서 헬리콥터는 세 개의 페르마타와 함께 다시 돌아옵니다.</p>

<ul>
  <li>첫 번째 페르마타: 스테이션 1, 2, 3, 4는 메조 피아노(mezzo piano)로 동시에 연주를 시작합니다.</li>
  <li>두 번째 페르마타: 무대 위 스테이션 5의 타악기 연주자를 위한 신호입니다. 이 동안 스테이션 1~4는 메조 포르테 또는 포르테까지 크레셴도합니다.</li>
  <li>세 번째 페르마타: 모든 스테이션이 다음 137마디에서의 강한 임팩트를 향해 크레셴도합니다.</li>
</ul>

<p> </p>

<h5 id="악곡-후반부---헬리콥터의-퇴장"><strong>악곡 후반부 - 헬리콥터의 퇴장</strong></h5>

<p>지휘자의 마지막 세 신호는 헬리콥터가 “공연장 밖으로 날아가는” 연출을 위한 것입니다.</p>

<ul>
  <li>187마디에서 모든 스테이션은 강력한 크레셴도를 시작합니다.</li>
  <li>188마디의 페르마타는 관악 파트의 음 해방(wind release)과 모든 타악 스테이션이 가장 강하게 연주하는 시점을 나타냅니다.</li>
</ul>

<h5 id="퇴장-지시"><strong>퇴장 지시:</strong></h5>

<ul>
  <li>지시 #1: 스테이션 5는 디크레셴도, 스테이션 1~4는 여전히 최대 음량으로 연주합니다.</li>
  <li>지시 #2: 스테이션 5는 완전히 소멸, 스테이션 3과 4는 디크레셴도 시작, 스테이션 1과 2는 계속 강하게 유지</li>
  <li> 지시 #3: 스테이션 3과 4는 완전히 사라지고, 스테이션 1과 2는 디크레셴도 시작. 스테이션 1과 2는 오션드럼(ocean drum)의 신호가 들어간 후 점차 멀어지듯 소멸해야 합니다.</li>
</ul>

<p>※ 헬리콥터 사운드와 오션드럼 사운드가 겹치게 하여, 두 효과 사이에 무음 상태가 생기지 않도록 주의해야 합니다.</p>

<p><em>토드 맨슨 (Todd Manson)</em> <em>수석 타악기 주자 / 팀파니스트</em> <em>트로이 주립대학교 (Troy State University)</em> <em>앨라배마, 트로이</em> <em>2000년 11월</em></p>

<p>https://www.youtube.com/watch?v=abalX-ozTFw</p>

<h3 id="악곡-분석"><strong>악곡 분석</strong></h3>

<h4 id="핵심-요약"><strong>핵심 요약</strong></h4>

<p>“인천 (Inchon)”은 <a href="https://en.wikipedia.org/wiki/Robert_W._Smith_\(musician\)">로버트 W. 스미스</a>가 2001년에 작곡한 콘서트 밴드 곡으로, 한국전쟁의 인천 상륙작전을 기념하며 섬세한 동양적 멜로디와 격정적인 전투 장면을 조화롭게 표현합니다. 연구에 따르면, 이 곡은 전쟁의 비극과 용사의 희생을 기리며 교육적, 문화적 가치를 지닌 것으로 여겨지고 있습니다.</p>

<p> </p>

<h4 id="배경과-영감"><strong>배경과 영감</strong></h4>

<p>이 곡은 1950년 인천 상륙작전, 특히 헬리콥터 상륙 장면을 음악적으로 묘사하며, 작곡가의 아버지인 한국전쟁 참전 용사에게 헌정되었습니다. 한국전쟁 50주년을 기념하기 위해 작곡되었으며, “잊혀진 전쟁”을 재조명하려는 의도가 담겨 있습니다.</p>

<p> </p>

<h4 id="음악적-특징"><strong>음악적 특징</strong></h4>

<p>곡은 약 10분 15초 길이로, 동양적인 멜로디와 전투를 묘사하는 격정적인 부분이 조화를 이룹니다. 퍼커션을 통해 헬리콥터 착륙 소리를 흉내내는 독특한 효과가 있으며, 피아노와 알토 플루트가 사용됩니다. 구조는 전쟁 전 평화로운 분위기, 상륙 장면, 전투의 절정, 그리고 성찰적인 마무리로 전개됩니다.</p>

<p> </p>

<h4 id="수상과-영향"><strong>수상과 영향</strong></h4>

<p>다양한 밴드, 예를 들어 중부 텍사스 주립대학교와 포르투갈 해군 밴드에서 공연되었으며, 교육적 레퍼토리로 높이 평가받고 있습니다. 초연 시 큰 찬사를 받았으며, 존 W. 슈미트 대령(미 해군 예비역)의 서문이 포함되어 있습니다.</p>

<p>https://www.youtube.com/watch?v=5DcGatw9qO0</p>

<p> </p>

<h3 id="상세-분석"><strong>상세 분석</strong></h3>

<h4 id="1-곡의-개요와-배경"><strong>1. 곡의 개요와 배경</strong></h4>

<p>“인천 (Inchon)”은 2001년에 작곡된 콘서트 밴드 곡으로, 한국전쟁 중 1950년 9월 15일 인천 상륙작전을 기념합니다. 이 작전은 유엔군이 미 해군 제1사단의 지휘 아래 북한군을 상대로 전략적 상륙을 수행한 것으로, 5일 만에 서울 탈환에 성공한 전환점으로 평가됩니다. 곡은 특히 헬리콥터를 이용한 최초의 대규모 상륙작전을 음악적으로 묘사하며, 작곡가의 아버지인 벤자민 F. 스미스 (Benjamin F. Smith) 대원, 한국전쟁과 베트남전쟁 참전 용사에게 헌정되었습니다. 이 곡은 한국전쟁 50주년을 기념하기 위해 작곡되었으며, “잊혀진 전쟁”이라 불리는 이 전쟁의 중요성을 재조명하려는 의도가 담겨 있습니다. 출처에 따르면, 곡은 동양과 서양의 문화적 충돌을 음악적으로 표현하며, 한국의 전통적 요소와 서양의 군사적 긴장을 조화롭게 반영합니다 (<a href="https://www.windrep.org/Inchon">Wind Repertory Project - Inchon</a>).</p>

<p> </p>

<h4 id="2-음악적-요소와-특징"><strong>2. 음악적 요소와 특징</strong></h4>

<p>이 곡은 약 10분 15초의 길이로, 중급에서 고급 수준의 콘서트 밴드를 위한 난이도 IV로 분류됩니다. 음악적으로는 다음과 같은 특징을 보입니다:</p>

<ul>
  <li><strong>멜로디와 조화</strong>: 곡 초반에는 섬세하고 평화로운 동양적 멜로디가 나타나며, 전쟁 이전의 분위기를 암시합니다. 이는 한국의 전통 음악적 요소를 반영한 것으로 보이며, 출처에서 “한국의 기도가 서양의 선언으로 답한다”고 묘사됩니다 (<a href="https://www.jwpepper.com/inchon-2700137-983448/p">J.W. Pepper - Inchon</a>).</li>
  <li><strong>격정적인 부분</strong>: 전투 장면을 묘사하는 부분에서는 강렬하고 격정적인 음악이 사용되며, 특히 퍼커션을 통해 헬리콥터 착륙 소리를 흉내내는 효과가 돋보입니다. 이는 곡의 극적 긴장을 높이는 데 기여합니다.</li>
  <li><strong>악기 구성</strong>: 피아노와 알토 플루트(또는 C 플루트 대체 파트)가 포함되며, 퍼커션의 역할이 매우 중요합니다. 출처에 따르면, 색채감 있게 오케스트레이션되어 다양한 악기의 음색을 활용합니다 (<a href="https://www.alfred.com/inchon/p/00-BDM01012/">Alfred Music - Inchon</a>).</li>
  <li><strong>오류와 주의점</strong>: 오보에 I/잉글리시 혼 부분에서 전조 오류가 보고되었으며, m.130-134에서 솔로 잉글리시 혼으로 연주할 경우 5도 위로 전조해야 합니다 (<a href="https://www.windrep.org/Inchon">Wind Repertory Project - Inchon</a>).</li>
</ul>

<p> </p>

<h4 id="3-구조와-전개"><strong>3. 구조와 전개</strong></h4>

<p>이 곡은 프로그램 음악의 특징을 보이며, 특정 사건을 음악적으로 서술합니다. 출처에 따르면, 다음과 같은 구조로 전개될 가능성이 높습니다:</p>

<ul>
  <li><strong>서두</strong>: 전쟁 이전의 평화로운 분위기와 한국의 전통적 요소를 암시하는 섬세한 멜로디로 시작.</li>
  <li><strong>중간부</strong>: 인천 상륙작전의 긴장감과 헬리콥터 착륙 장면을 묘사하며, 퍼커션 효과가 두드러짐.</li>
  <li><strong>클라이맥스</strong>: 전투의 절정과 서울 탈환을 향한 진군을 표현하는 강렬한 부분.</li>
  <li><strong>결말</strong>: 전쟁의 비극과 기념의 의미를 담은 성찰적인 마무리로 마무리. 이 구조는 역사적 사건의 흐름을 음악적으로 반영하며, 청중에게 생생한 이미지를 전달하려는 의도가 엿보입니다.</li>
</ul>

<p> </p>

<h4 id="4-공연-기록과-평가"><strong>4. 공연 기록과 평가</strong></h4>

<p>이 곡은 다양한 밴드에서 공연되었으며, 교육적 레퍼토리로 높은 평가를 받았습니다. 출처에 따르면, 다음과 같은 공연 기록이 있습니다:</p>

<table>
  <thead>
    <tr>
      <th><strong>공연 단체</strong></th>
      <th><strong>날짜</strong></th>
      <th><strong>장소</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>중부 텍사스 주립대학교</td>
      <td>2023년 11월 16일</td>
      <td>미상</td>
    </tr>
    <tr>
      <td>노스웨스턴 일리노이 대학교</td>
      <td>2022년 10월 21일</td>
      <td>미상</td>
    </tr>
    <tr>
      <td>우스터 고등학교</td>
      <td>2022년 1월 30일</td>
      <td>세버런스 음악 센터, 클리블랜드</td>
    </tr>
    <tr>
      <td>SUNY 오스위고</td>
      <td>2021년 12월 1일</td>
      <td>미상</td>
    </tr>
    <tr>
      <td>브리지워터 칼리지</td>
      <td>2021년 11월 7일</td>
      <td>미상</td>
    </tr>
    <tr>
      <td>프랭클린 고등학교</td>
      <td>2019년 12월 10일</td>
      <td>미상</td>
    </tr>
    <tr>
      <td>베델 칼리지</td>
      <td>2017년 11월 16일</td>
      <td>미상</td>
    </tr>
    <tr>
      <td>킨 스테이트 칼리지</td>
      <td>2015년 4월 23일</td>
      <td>미상</td>
    </tr>
    <tr>
      <td>포르투갈 해군 밴드</td>
      <td>2014년</td>
      <td>미상</td>
    </tr>
  </tbody>
</table>

<p>이 곡은 경험 많은 콘서트 밴드의 표준 레퍼토리로 자리 잡았으며, 초연 시 큰 찬사를 받았습니다. 존 W. 슈미트 (John W. Schmidt) 대령(미 해군 예비역)의 서문이 포함되어 있으며, 그는 실제 전투 경험을 바탕으로 이 작품의 정확성과 감정적 깊이를 높이 평가했습니다 (<a href="https://www.alfred.com/inchon/p/00-BFOM03007/">Alfred Music - Inchon</a>).</p>

<p> </p>

<h4 id="5-문화적-및-사회적-의미"><strong>5. 문화적 및 사회적 의미</strong></h4>

<p>“인천”은 단순히 전쟁의 역사를 기록하는 데 그치지 않고, 전쟁의 비극과 용사의 희생을 통해 평화와 기념의 메시지를 전달합니다. 동양과 서양의 음악적 요소를 결합하여 문화적 교류와 이해의 가능성을 암시하며, 특히 한국전쟁의 중요성을 재조명하는 데 기여합니다. 교육적으로도 이 곡은 학생들에게 역사적 사건을 음악적으로 이해하고 표현하는 기회를 제공하며, 콘서트 밴드의 표준 레퍼토리로 자리 잡았습니다.</p>

<p> </p>

<h4 id="결론"><strong>결론</strong></h4>

<p>로버트 W. 스미스의 “인천 (Inchon)”은 한국전쟁의 중요한 전투를 음악적으로 기념하는 작품으로, 섬세한 동양적 멜로디와 격정적인 전투 장면 묘사가 조화롭게 어우러진 독창적인 작품입니다. 이 곡은 역사적, 음악적, 문화적 가치를 지니며, 전쟁의 비극과 용사의 희생을 기리며 평화의 메시지를 전달합니다.</p>

<p> </p>

<p>https://www.youtube.com/watch?v=YU3rdGWw2Yw&amp;pp=ygUWaW5jaGVvbiByb2JlcnQgdyBzbWl0aA%3D%3D</p>

<p> </p>

<h4 id="주요-인용"><strong>주요 인용</strong></h4>

<ul>
  <li><a href="https://www.windrep.org/Inchon">Wind Repertory Project - Inchon 분석</a></li>
  <li><a href="https://www.alfred.com/inchon/p/00-BDM01012/">Alfred Music - Inchon 악보</a></li>
  <li><a href="https://www.jwpepper.com/inchon-2700137-983448/p">J.W. Pepper - Inchon 공연 정보</a></li>
  <li><a href="https://www.alfred.com/inchon/p/00-BFOM03007/">Alfred Music - Inchon 오케스트라 버전</a></li>
</ul>

<p>[rcblock id=”6686”]</p>]]></content><author><name></name></author><category term="Favorite Music" /><category term="Band Music" /><summary type="html"><![CDATA[[caption id=”attachment_7133” align=”aligncenter” width=”484”] 로버트 W 스미스 Robert W. Smith - 인천 Inchon (2001)[/caption]]]></summary></entry><entry><title type="html">AudioKit으로 만드는 다중트랙 미디 재생기 (MultiTrack MIDI Player)</title><link href="/posts/MultiTrackMIDIPlayer/" rel="alternate" type="text/html" title="AudioKit으로 만드는 다중트랙 미디 재생기 (MultiTrack MIDI Player)" /><published>2025-06-23T17:16:31+09:00</published><updated>2025-06-23T17:16:31+09:00</updated><id>/posts/MultiTrackMIDIPlayer</id><content type="html" xml:base="/posts/MultiTrackMIDIPlayer/"><![CDATA[<h1 id="multitrack-midi-player">Multitrack MIDI Player</h1>

<ul>
  <li><a href="https://github.com/ayaysir/Swift-Playgrounds/blob/main/AudioKit%20Cookbook%20Copy/AudioKit%20Cookbook%20Copy/Recipe/Labs/MultitrackMIDIPlayer.swift">코드 보기</a></li>
</ul>

<p>이 코드는 AudioKit을 사용하여 여러 트랙과 악기를 포함한 <strong>MIDI 파일을 재생할 수 있는 SwiftUI 기반의 멀티트랙 MIDI 플레이어</strong>입니다.
구성은 크게 <code class="language-plaintext highlighter-rouge">MultitrackMIDIPlayerConductor</code>(오디오 및 MIDI 처리 로직)와 <code class="language-plaintext highlighter-rouge">MultitrackMIDIPlayerView</code>(UI)로 나뉘며, 아래와 같이 작동합니다.</p>

<hr />

<h2 id="multitrackmidiplayerconductor-오디오-및-midi-제어-클래스"><code class="language-plaintext highlighter-rouge">MultitrackMIDIPlayerConductor</code>: 오디오 및 MIDI 제어 클래스</h2>

<h3 id="주요-프로퍼티">주요 프로퍼티</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">let</span> <span class="nv">engine</span> <span class="o">=</span> <span class="kt">AudioEngine</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">sampler</span> <span class="o">=</span> <span class="kt">MIDISampler</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">sequencer</span> <span class="o">=</span> <span class="kt">AppleSequencer</span><span class="p">()</span>
<span class="k">var</span> <span class="nv">samplers</span><span class="p">:</span> <span class="p">[</span><span class="kt">MIDISampler</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">var</span> <span class="nv">mixer</span><span class="p">:</span> <span class="kt">Mixer</span><span class="o">!</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">AudioEngine</code>: 오디오 출력의 핵심 객체</li>
  <li><code class="language-plaintext highlighter-rouge">AppleSequencer</code>: MIDI 트랙을 다루기 위한 시퀀서</li>
  <li><code class="language-plaintext highlighter-rouge">samplers</code>: 트랙별 악기(MIDISampler) 배열</li>
  <li><code class="language-plaintext highlighter-rouge">mixer</code>: 여러 sampler를 하나로 합쳐 출력</li>
</ul>

<hr />

<h3 id="init"><code class="language-plaintext highlighter-rouge">init()</code></h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="n">sequencer</span><span class="o">.</span><span class="nf">loadMIDIFile</span><span class="p">(</span><span class="s">"MIDI Files/Horde3"</span><span class="p">)</span>
<span class="nf">setTracks</span><span class="p">()</span>
<span class="nf">setMixerOutput</span><span class="p">()</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>앱 시작 시 기본 MIDI 파일(<code class="language-plaintext highlighter-rouge">Horde3</code>)을 불러오고, 트랙 구성 및 믹서 설정을 실행합니다.</p>

<hr />

<h3 id="loadmidifileurl"><code class="language-plaintext highlighter-rouge">loadMIDIFile(url:)</code></h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="n">sequencer</span><span class="o">.</span><span class="nf">loadMIDIFile</span><span class="p">(</span><span class="nv">fromURL</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span>
<span class="n">samplers</span><span class="o">.</span><span class="nf">removeAll</span><span class="p">()</span>
<span class="nf">setTracks</span><span class="p">()</span>
<span class="nf">setMixerOutput</span><span class="p">()</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.fileImporter</code>를 통해 선택한 MIDI 파일을 로드</li>
  <li>새로운 MIDI 트랙에 맞게 sampler를 재구성하고 믹서도 다시 설정</li>
</ul>

<p>※ <code class="language-plaintext highlighter-rouge">engine.output = mixer</code>가 <code class="language-plaintext highlighter-rouge">setMixerOutput()</code> 안에서 설정되므로 이 라인 이후 오디오 출력이 재설정됨</p>

<hr />

<h3 id="settracks"><code class="language-plaintext highlighter-rouge">setTracks()</code></h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">let</span> <span class="nv">tracks</span> <span class="o">=</span> <span class="n">sequencer</span><span class="o">.</span><span class="n">tracks</span>
<span class="o">...</span>
<span class="k">let</span> <span class="nv">sampler</span> <span class="o">=</span> <span class="kt">MIDISampler</span><span class="p">()</span>
<span class="k">try</span> <span class="n">sampler</span><span class="o">.</span><span class="nf">loadSoundFont</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">track</span><span class="o">.</span><span class="nf">setMIDIOutput</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">midiIn</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>각 트랙에 대해:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">channel == 9</code>인지 판단하여 드럼인지 구분</li>
  <li><code class="language-plaintext highlighter-rouge">bank</code> 값을 일반(0) 또는 드럼용(128)으로 설정</li>
  <li><code class="language-plaintext highlighter-rouge">programChangeEvents</code>에서 preset 번호 추출</li>
  <li>해당 사운드폰트 로딩</li>
  <li>트랙과 sampler 연결 → <code class="language-plaintext highlighter-rouge">track.setMIDIOutput(...)</code></li>
</ol>

<p>로그는 <code class="language-plaintext highlighter-rouge">conductor.midiLog</code>에 텍스트로 기록됨</p>

<hr />

<h3 id="sequencerplay--sequencerstop"><code class="language-plaintext highlighter-rouge">sequencerPlay()</code> / <code class="language-plaintext highlighter-rouge">sequencerStop()</code></h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="n">sequencer</span><span class="o">.</span><span class="nf">play</span><span class="p">()</span>
<span class="n">sequencer</span><span class="o">.</span><span class="nf">stop</span><span class="p">()</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>플레이/스톱 버튼에 대응하여 시퀀서를 재생 또는 정지합니다.</p>

<hr />

<h2 id="multitrackmidiplayerview-사용자-인터페이스"><code class="language-plaintext highlighter-rouge">MultitrackMIDIPlayerView</code>: 사용자 인터페이스</h2>

<h3 id="상태-바인딩">상태 바인딩</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="kd">@StateObject</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">conductor</span> <span class="o">=</span> <span class="kt">MultitrackMIDIPlayerConductor</span><span class="p">()</span>
<span class="kd">@State</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">showFileImporter</span> <span class="o">=</span> <span class="kc">false</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">conductor</code>: 로직을 담당하는 ViewModel</li>
  <li><code class="language-plaintext highlighter-rouge">showFileImporter</code>: 파일 가져오기 창 제어용</li>
</ul>

<hr />

<h3 id="ui-구성-요약">UI 구성 요약</h3>

<ul>
  <li>MIDI 파일명 표시</li>
  <li>[Load MIDI File], [PLAY / STOP] 버튼</li>
  <li>MIDI 분석 로그 스크롤 출력</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="kt">Text</span><span class="p">(</span><span class="n">conductor</span><span class="o">.</span><span class="n">fileName</span><span class="p">)</span>
<span class="o">...</span>
<span class="kt">ScrollView</span> <span class="p">{</span>
  <span class="kt">Text</span><span class="p">(</span><span class="n">conductor</span><span class="o">.</span><span class="n">midiLog</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<hr />

<h3 id="파일-가져오기-midi">파일 가져오기 (.midi)</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="o">.</span><span class="nf">fileImporter</span><span class="p">(</span><span class="nv">isPresented</span><span class="p">:</span> <span class="n">$showFileImporter</span><span class="p">,</span> <span class="nv">allowedContentTypes</span><span class="p">:</span> <span class="p">[</span><span class="o">.</span><span class="n">midi</span><span class="p">])</span> <span class="p">{</span> <span class="n">result</span> <span class="k">in</span>
  <span class="o">...</span>
  <span class="n">conductor</span><span class="o">.</span><span class="nf">loadMIDIFile</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>유저가 파일을 선택하면 MIDI 파일을 <code class="language-plaintext highlighter-rouge">Conductor</code>에 전달하여 새롭게 로드합니다.
<strong>보안 스코프 리소스 접근 권한</strong>도 자동으로 획득함 (<code class="language-plaintext highlighter-rouge">startAccessingSecurityScopedResource()</code>)</p>

<hr />

<h3 id="오디오-엔진-관리">오디오 엔진 관리</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="o">.</span><span class="n">onAppear</span> <span class="p">{</span> <span class="n">conductor</span><span class="o">.</span><span class="nf">start</span><span class="p">()</span> <span class="p">}</span>
<span class="o">.</span><span class="n">onDisappear</span> <span class="p">{</span> <span class="n">conductor</span><span class="o">.</span><span class="nf">stop</span><span class="p">()</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>뷰가 등장할 때 AudioKit 엔진 시작, 사라질 때 정지</p>

<hr />

<h2 id="-핵심-특징-요약">✅ 핵심 특징 요약</h2>

<table>
  <thead>
    <tr>
      <th>기능</th>
      <th>구현 방식</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>트랙별 악기 설정</td>
      <td><code class="language-plaintext highlighter-rouge">programChangeEvents</code> 기반으로 <code class="language-plaintext highlighter-rouge">MIDISampler</code> 생성 및 연결</td>
    </tr>
    <tr>
      <td>퍼커션 채널 감지</td>
      <td><code class="language-plaintext highlighter-rouge">channel == 9</code>이면 <code class="language-plaintext highlighter-rouge">bank: 128</code>로 로딩</td>
    </tr>
    <tr>
      <td>MIDI 분석 출력</td>
      <td>로그 텍스트를 <code class="language-plaintext highlighter-rouge">ScrollView</code>에 표시</td>
    </tr>
    <tr>
      <td>파일 가져오기</td>
      <td><code class="language-plaintext highlighter-rouge">.fileImporter</code>를 통해 .mid 파일 로딩</td>
    </tr>
    <tr>
      <td>실시간 재생 제어</td>
      <td><code class="language-plaintext highlighter-rouge">sequencer.play()</code> / <code class="language-plaintext highlighter-rouge">sequencer.stop()</code> 호출</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-확장-아이디어">📦 확장 아이디어</h2>

<ul>
  <li>트랙별 볼륨/음소거 슬라이더 추가</li>
  <li>ProgramChange 다중 처리 (중간 악기 변경)</li>
</ul>]]></content><author><name>ayaysir(BGSMM)</name><email>your-email@example.com</email></author><category term="StudyLog" /><category term="AudioKit" /><category term="AudioKit" /><category term="음향이론" /><summary type="html"><![CDATA[Multitrack MIDI Player]]></summary></entry><entry><title type="html">AudioKit: MIDISampler+AppleSequencer를 이용한 미디 멀티트랙 재생 중 트랙 중간에 프로그램 체인지가 있는 경우 대응 방법</title><link href="/posts/%EB%AF%B8%EB%94%94_%ED%8A%B8%EB%9E%99%EC%A4%91%EA%B0%84_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%B2%B4%EC%9D%B8%EC%A7%80_%EB%8C%80%EC%9D%91%EB%B2%95/" rel="alternate" type="text/html" title="AudioKit: MIDISampler+AppleSequencer를 이용한 미디 멀티트랙 재생 중 트랙 중간에 프로그램 체인지가 있는 경우 대응 방법" /><published>2025-06-23T15:22:38+09:00</published><updated>2025-06-23T15:22:38+09:00</updated><id>/posts/%EB%AF%B8%EB%94%94_%ED%8A%B8%EB%9E%99%EC%A4%91%EA%B0%84_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%B2%B4%EC%9D%B8%EC%A7%80_%EB%8C%80%EC%9D%91%EB%B2%95</id><content type="html" xml:base="/posts/%EB%AF%B8%EB%94%94_%ED%8A%B8%EB%9E%99%EC%A4%91%EA%B0%84_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%B2%B4%EC%9D%B8%EC%A7%80_%EB%8C%80%EC%9D%91%EB%B2%95/"><![CDATA[<h1 id="midisamplerapplesequencer를-이용한-미디-멀티트랙-재생-중-트랙-중간에-프로그램-체인지가-있는-경우-대응-방법">MIDISampler+AppleSequencer를 이용한 미디 멀티트랙 재생 중 트랙 중간에 프로그램 체인지가 있는 경우 대응 방법</h1>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>track 2: [
  AudioKit.MIDIProgramChangeEvent(time: 0.0, channel: 2, number: 57),
  AudioKit.MIDIProgramChangeEvent(time: 64.0, channel: 2, number: 60),
  AudioKit.MIDIProgramChangeEvent(time: 119.98697916666667, channel: 2, number: 57)
]
</pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">track 2</code>처럼 <strong>트랙 중간에 Program Change 메시지로 악기가 바뀌는 경우</strong>,
AudioKit의 <code class="language-plaintext highlighter-rouge">AppleSequencer</code>와 <code class="language-plaintext highlighter-rouge">MIDISampler</code> 조합만으로는 <strong>정확한 사운드 전환을 구현하기 어렵습니다.</strong></p>

<p>기본적으로 <code class="language-plaintext highlighter-rouge">track.setMIDIOutput(sampler.midiIn)</code>으로 연결된 <code class="language-plaintext highlighter-rouge">MIDISampler</code>는 <strong>트랙 전체를 하나의 악기로만 재생</strong>합니다.
중간에 악기를 바꾸는 기능은 직접 처리해주지 않으면 반영되지 않습니다.</p>

<hr />

<h2 id="문제-상황-요약">문제 상황 요약</h2>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="n">track</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span>
  <span class="kt">ProgramChange</span><span class="p">(</span><span class="nv">channel</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nv">number</span><span class="p">:</span> <span class="mi">57</span><span class="p">)</span> <span class="c1">// 시작 시</span>
  <span class="kt">ProgramChange</span><span class="p">(</span><span class="nv">channel</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nv">number</span><span class="p">:</span> <span class="mi">60</span><span class="p">)</span> <span class="c1">// 64초쯤</span>
  <span class="kt">ProgramChange</span><span class="p">(</span><span class="nv">channel</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nv">number</span><span class="p">:</span> <span class="mi">57</span><span class="p">)</span> <span class="c1">// 120초쯤 복귀</span>
<span class="p">]</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>표준 MIDI에서는 이런 식으로 Program Change 메시지를 트랙 내에 삽입하여 <strong>동일 채널에 악기 전환</strong>을 수행</li>
  <li>AudioKit의 기본 Sequencer 처리 방식에서는 이를 자동 인식하거나 대응하지 않음</li>
</ul>

<hr />

<h2 id="-해결-방향">🎯 해결 방향</h2>

<h3 id="-program-change-이벤트를-파싱해서">① Program Change 이벤트를 파싱해서</h3>

<ul>
  <li>시점별로 <strong>악기(프리셋) 변경 정보</strong>를 추출</li>
</ul>

<h3 id="-해당-채널의-midi-이벤트를-악기-구간별로-나눠서">② 해당 채널의 MIDI 이벤트를 <strong>악기 구간별로 나눠서</strong></h3>

<ul>
  <li><strong>구간별 <code class="language-plaintext highlighter-rouge">MIDISampler</code>를 생성</strong>하거나</li>
  <li>하나의 Sampler에 <strong>프리셋을 실시간으로 변경 요청</strong>
(단, 대부분의 <code class="language-plaintext highlighter-rouge">MIDISampler</code>는 실행 중 preset 변경을 안정적으로 지원하지 않음)</li>
</ul>

<hr />

<h2 id="실현-가능한-접근-방법">실현 가능한 접근 방법</h2>

<h3 id="방법-a-트랙을-구간별로-분할하여-각각-sampler에-할당">방법 A: 트랙을 구간별로 분할하여 각각 sampler에 할당</h3>

<blockquote>
  <p>1개 트랙을 Program Change 기준으로 여러 개로 나누고,
구간마다 MIDISampler와 연결 → Mixer에 병합</p>
</blockquote>

<p>단점:</p>

<ul>
  <li>구현 복잡도 있음</li>
  <li>MIDI 이벤트 재구성이 필요</li>
</ul>

<h3 id="방법-b-programchange-메시지-수신-시-sampler의-preset을-변경">방법 B: ProgramChange 메시지 수신 시 sampler의 preset을 변경</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">if</span> <span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="nf">programChange</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">number</span><span class="p">)</span> <span class="o">=</span> <span class="n">event</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">channel</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">{</span>
    <span class="k">try</span><span class="p">?</span> <span class="n">sampler</span><span class="o">.</span><span class="nf">loadSoundFont</span><span class="p">(</span><span class="s">"CT8MGM"</span><span class="p">,</span> <span class="nv">preset</span><span class="p">:</span> <span class="n">number</span><span class="p">,</span> <span class="nv">bank</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>MIDI 이벤트를 수신하는 커스텀 <code class="language-plaintext highlighter-rouge">MIDIListener</code> 구현 필요</li>
  <li>실행 중 preset을 바꾸면 버퍼 끊김이나 글리치 발생 가능</li>
</ul>

<blockquote>
  <p><strong>실행 중 preset 변경은 대부분 권장되지 않음</strong></p>
</blockquote>

<hr />

<h2 id="권장-방식-현실적-대안">권장 방식 (현실적 대안)</h2>

<h3 id="-트랙-중간에-program-change가-있는-경우">🎯 트랙 중간에 Program Change가 있는 경우:</h3>

<ol>
  <li><strong>MIDI 파일을 외부에서 미리 분할</strong>하거나</li>
  <li><strong>DAW에서 동일 채널에 Program Change를 쓰지 않도록 재구성</strong></li>
  <li>또는 <strong>AudioKit으로 다룰 경우, 중간 ProgramChange를 무시하고 시작 preset만 사용</strong></li>
</ol>

<hr />

<h2 id="요약">요약</h2>

<table>
  <thead>
    <tr>
      <th>상황</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>트랙에 ProgramChange가 여러 개 있음</td>
      <td>MIDI 채널의 악기가 재생 중에 바뀜</td>
    </tr>
    <tr>
      <td>AudioKit <code class="language-plaintext highlighter-rouge">AppleSequencer</code></td>
      <td>한 트랙당 하나의 sampler만 연결됨</td>
    </tr>
    <tr>
      <td>실시간 preset 변경</td>
      <td>가능은 하지만 glitch 발생 가능</td>
    </tr>
    <tr>
      <td>현실적인 방법</td>
      <td>ProgramChange 기준으로 트랙을 사전 분할 또는 첫 preset만 사용</td>
    </tr>
  </tbody>
</table>]]></content><author><name>ayaysir(BGSMM)</name><email>your-email@example.com</email></author><category term="StudyLog" /><category term="AudioKit" /><category term="AudioKit" /><category term="음향이론" /><summary type="html"><![CDATA[MIDISampler+AppleSequencer를 이용한 미디 멀티트랙 재생 중 트랙 중간에 프로그램 체인지가 있는 경우 대응 방법]]></summary></entry></feed>