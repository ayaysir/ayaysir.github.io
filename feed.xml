<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" hreflang="ko" /><updated>2025-10-20T20:43:08+09:00</updated><id>/feed.xml</id><title type="html">BGSMM</title><subtitle>A minimal, responsive and feature-rich Jekyll theme for technical writing.</subtitle><entry><title type="html">AudioKit으로 만드는 다중트랙 미디 재생기 (MultiTrack MIDI Player)</title><link href="/posts/MultiTrackMIDIPlayer/" rel="alternate" type="text/html" title="AudioKit으로 만드는 다중트랙 미디 재생기 (MultiTrack MIDI Player)" /><published>2025-06-23T17:16:31+09:00</published><updated>2025-06-23T17:16:31+09:00</updated><id>/posts/MultiTrackMIDIPlayer</id><content type="html" xml:base="/posts/MultiTrackMIDIPlayer/"><![CDATA[<h1 id="multitrack-midi-player">Multitrack MIDI Player</h1>

<ul>
  <li><a href="https://github.com/ayaysir/Swift-Playgrounds/blob/main/AudioKit%20Cookbook%20Copy/AudioKit%20Cookbook%20Copy/Recipe/Labs/MultitrackMIDIPlayer.swift">코드 보기</a></li>
</ul>

<p>이 코드는 AudioKit을 사용하여 여러 트랙과 악기를 포함한 <strong>MIDI 파일을 재생할 수 있는 SwiftUI 기반의 멀티트랙 MIDI 플레이어</strong>입니다.
구성은 크게 <code class="language-plaintext highlighter-rouge">MultitrackMIDIPlayerConductor</code>(오디오 및 MIDI 처리 로직)와 <code class="language-plaintext highlighter-rouge">MultitrackMIDIPlayerView</code>(UI)로 나뉘며, 아래와 같이 작동합니다.</p>

<hr />

<h2 id="multitrackmidiplayerconductor-오디오-및-midi-제어-클래스"><code class="language-plaintext highlighter-rouge">MultitrackMIDIPlayerConductor</code>: 오디오 및 MIDI 제어 클래스</h2>

<h3 id="주요-프로퍼티">주요 프로퍼티</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">let</span> <span class="nv">engine</span> <span class="o">=</span> <span class="kt">AudioEngine</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">sampler</span> <span class="o">=</span> <span class="kt">MIDISampler</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">sequencer</span> <span class="o">=</span> <span class="kt">AppleSequencer</span><span class="p">()</span>
<span class="k">var</span> <span class="nv">samplers</span><span class="p">:</span> <span class="p">[</span><span class="kt">MIDISampler</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">var</span> <span class="nv">mixer</span><span class="p">:</span> <span class="kt">Mixer</span><span class="o">!</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">AudioEngine</code>: 오디오 출력의 핵심 객체</li>
  <li><code class="language-plaintext highlighter-rouge">AppleSequencer</code>: MIDI 트랙을 다루기 위한 시퀀서</li>
  <li><code class="language-plaintext highlighter-rouge">samplers</code>: 트랙별 악기(MIDISampler) 배열</li>
  <li><code class="language-plaintext highlighter-rouge">mixer</code>: 여러 sampler를 하나로 합쳐 출력</li>
</ul>

<hr />

<h3 id="init"><code class="language-plaintext highlighter-rouge">init()</code></h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="n">sequencer</span><span class="o">.</span><span class="nf">loadMIDIFile</span><span class="p">(</span><span class="s">"MIDI Files/Horde3"</span><span class="p">)</span>
<span class="nf">setTracks</span><span class="p">()</span>
<span class="nf">setMixerOutput</span><span class="p">()</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>앱 시작 시 기본 MIDI 파일(<code class="language-plaintext highlighter-rouge">Horde3</code>)을 불러오고, 트랙 구성 및 믹서 설정을 실행합니다.</p>

<hr />

<h3 id="loadmidifileurl"><code class="language-plaintext highlighter-rouge">loadMIDIFile(url:)</code></h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="n">sequencer</span><span class="o">.</span><span class="nf">loadMIDIFile</span><span class="p">(</span><span class="nv">fromURL</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span>
<span class="n">samplers</span><span class="o">.</span><span class="nf">removeAll</span><span class="p">()</span>
<span class="nf">setTracks</span><span class="p">()</span>
<span class="nf">setMixerOutput</span><span class="p">()</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.fileImporter</code>를 통해 선택한 MIDI 파일을 로드</li>
  <li>새로운 MIDI 트랙에 맞게 sampler를 재구성하고 믹서도 다시 설정</li>
</ul>

<p>※ <code class="language-plaintext highlighter-rouge">engine.output = mixer</code>가 <code class="language-plaintext highlighter-rouge">setMixerOutput()</code> 안에서 설정되므로 이 라인 이후 오디오 출력이 재설정됨</p>

<hr />

<h3 id="settracks"><code class="language-plaintext highlighter-rouge">setTracks()</code></h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">let</span> <span class="nv">tracks</span> <span class="o">=</span> <span class="n">sequencer</span><span class="o">.</span><span class="n">tracks</span>
<span class="o">...</span>
<span class="k">let</span> <span class="nv">sampler</span> <span class="o">=</span> <span class="kt">MIDISampler</span><span class="p">()</span>
<span class="k">try</span> <span class="n">sampler</span><span class="o">.</span><span class="nf">loadSoundFont</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">track</span><span class="o">.</span><span class="nf">setMIDIOutput</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">midiIn</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>각 트랙에 대해:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">channel == 9</code>인지 판단하여 드럼인지 구분</li>
  <li><code class="language-plaintext highlighter-rouge">bank</code> 값을 일반(0) 또는 드럼용(128)으로 설정</li>
  <li><code class="language-plaintext highlighter-rouge">programChangeEvents</code>에서 preset 번호 추출</li>
  <li>해당 사운드폰트 로딩</li>
  <li>트랙과 sampler 연결 → <code class="language-plaintext highlighter-rouge">track.setMIDIOutput(...)</code></li>
</ol>

<p>로그는 <code class="language-plaintext highlighter-rouge">conductor.midiLog</code>에 텍스트로 기록됨</p>

<hr />

<h3 id="sequencerplay--sequencerstop"><code class="language-plaintext highlighter-rouge">sequencerPlay()</code> / <code class="language-plaintext highlighter-rouge">sequencerStop()</code></h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="n">sequencer</span><span class="o">.</span><span class="nf">play</span><span class="p">()</span>
<span class="n">sequencer</span><span class="o">.</span><span class="nf">stop</span><span class="p">()</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>플레이/스톱 버튼에 대응하여 시퀀서를 재생 또는 정지합니다.</p>

<hr />

<h2 id="multitrackmidiplayerview-사용자-인터페이스"><code class="language-plaintext highlighter-rouge">MultitrackMIDIPlayerView</code>: 사용자 인터페이스</h2>

<h3 id="상태-바인딩">상태 바인딩</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="kd">@StateObject</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">conductor</span> <span class="o">=</span> <span class="kt">MultitrackMIDIPlayerConductor</span><span class="p">()</span>
<span class="kd">@State</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">showFileImporter</span> <span class="o">=</span> <span class="kc">false</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">conductor</code>: 로직을 담당하는 ViewModel</li>
  <li><code class="language-plaintext highlighter-rouge">showFileImporter</code>: 파일 가져오기 창 제어용</li>
</ul>

<hr />

<h3 id="ui-구성-요약">UI 구성 요약</h3>

<ul>
  <li>MIDI 파일명 표시</li>
  <li>[Load MIDI File], [PLAY / STOP] 버튼</li>
  <li>MIDI 분석 로그 스크롤 출력</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="kt">Text</span><span class="p">(</span><span class="n">conductor</span><span class="o">.</span><span class="n">fileName</span><span class="p">)</span>
<span class="o">...</span>
<span class="kt">ScrollView</span> <span class="p">{</span>
  <span class="kt">Text</span><span class="p">(</span><span class="n">conductor</span><span class="o">.</span><span class="n">midiLog</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<hr />

<h3 id="파일-가져오기-midi">파일 가져오기 (.midi)</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="o">.</span><span class="nf">fileImporter</span><span class="p">(</span><span class="nv">isPresented</span><span class="p">:</span> <span class="n">$showFileImporter</span><span class="p">,</span> <span class="nv">allowedContentTypes</span><span class="p">:</span> <span class="p">[</span><span class="o">.</span><span class="n">midi</span><span class="p">])</span> <span class="p">{</span> <span class="n">result</span> <span class="k">in</span>
  <span class="o">...</span>
  <span class="n">conductor</span><span class="o">.</span><span class="nf">loadMIDIFile</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>유저가 파일을 선택하면 MIDI 파일을 <code class="language-plaintext highlighter-rouge">Conductor</code>에 전달하여 새롭게 로드합니다.
<strong>보안 스코프 리소스 접근 권한</strong>도 자동으로 획득함 (<code class="language-plaintext highlighter-rouge">startAccessingSecurityScopedResource()</code>)</p>

<hr />

<h3 id="오디오-엔진-관리">오디오 엔진 관리</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="o">.</span><span class="n">onAppear</span> <span class="p">{</span> <span class="n">conductor</span><span class="o">.</span><span class="nf">start</span><span class="p">()</span> <span class="p">}</span>
<span class="o">.</span><span class="n">onDisappear</span> <span class="p">{</span> <span class="n">conductor</span><span class="o">.</span><span class="nf">stop</span><span class="p">()</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>뷰가 등장할 때 AudioKit 엔진 시작, 사라질 때 정지</p>

<hr />

<h2 id="-핵심-특징-요약">✅ 핵심 특징 요약</h2>

<table>
  <thead>
    <tr>
      <th>기능</th>
      <th>구현 방식</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>트랙별 악기 설정</td>
      <td><code class="language-plaintext highlighter-rouge">programChangeEvents</code> 기반으로 <code class="language-plaintext highlighter-rouge">MIDISampler</code> 생성 및 연결</td>
    </tr>
    <tr>
      <td>퍼커션 채널 감지</td>
      <td><code class="language-plaintext highlighter-rouge">channel == 9</code>이면 <code class="language-plaintext highlighter-rouge">bank: 128</code>로 로딩</td>
    </tr>
    <tr>
      <td>MIDI 분석 출력</td>
      <td>로그 텍스트를 <code class="language-plaintext highlighter-rouge">ScrollView</code>에 표시</td>
    </tr>
    <tr>
      <td>파일 가져오기</td>
      <td><code class="language-plaintext highlighter-rouge">.fileImporter</code>를 통해 .mid 파일 로딩</td>
    </tr>
    <tr>
      <td>실시간 재생 제어</td>
      <td><code class="language-plaintext highlighter-rouge">sequencer.play()</code> / <code class="language-plaintext highlighter-rouge">sequencer.stop()</code> 호출</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-확장-아이디어">📦 확장 아이디어</h2>

<ul>
  <li>트랙별 볼륨/음소거 슬라이더 추가</li>
  <li>ProgramChange 다중 처리 (중간 악기 변경)</li>
</ul>]]></content><author><name>ayaysir(BGSMM)</name><email>your-email@example.com</email></author><category term="StudyLog" /><category term="AudioKit" /><category term="AudioKit" /><category term="음향이론" /><summary type="html"><![CDATA[Multitrack MIDI Player]]></summary></entry><entry><title type="html">AudioKit: MIDISampler+AppleSequencer를 이용한 미디 멀티트랙 재생 중 트랙 중간에 프로그램 체인지가 있는 경우 대응 방법</title><link href="/posts/%EB%AF%B8%EB%94%94_%ED%8A%B8%EB%9E%99%EC%A4%91%EA%B0%84_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%B2%B4%EC%9D%B8%EC%A7%80_%EB%8C%80%EC%9D%91%EB%B2%95/" rel="alternate" type="text/html" title="AudioKit: MIDISampler+AppleSequencer를 이용한 미디 멀티트랙 재생 중 트랙 중간에 프로그램 체인지가 있는 경우 대응 방법" /><published>2025-06-23T15:22:38+09:00</published><updated>2025-06-23T15:22:38+09:00</updated><id>/posts/%EB%AF%B8%EB%94%94_%ED%8A%B8%EB%9E%99%EC%A4%91%EA%B0%84_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%B2%B4%EC%9D%B8%EC%A7%80_%EB%8C%80%EC%9D%91%EB%B2%95</id><content type="html" xml:base="/posts/%EB%AF%B8%EB%94%94_%ED%8A%B8%EB%9E%99%EC%A4%91%EA%B0%84_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%B2%B4%EC%9D%B8%EC%A7%80_%EB%8C%80%EC%9D%91%EB%B2%95/"><![CDATA[<h1 id="midisamplerapplesequencer를-이용한-미디-멀티트랙-재생-중-트랙-중간에-프로그램-체인지가-있는-경우-대응-방법">MIDISampler+AppleSequencer를 이용한 미디 멀티트랙 재생 중 트랙 중간에 프로그램 체인지가 있는 경우 대응 방법</h1>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>track 2: [
  AudioKit.MIDIProgramChangeEvent(time: 0.0, channel: 2, number: 57),
  AudioKit.MIDIProgramChangeEvent(time: 64.0, channel: 2, number: 60),
  AudioKit.MIDIProgramChangeEvent(time: 119.98697916666667, channel: 2, number: 57)
]
</pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">track 2</code>처럼 <strong>트랙 중간에 Program Change 메시지로 악기가 바뀌는 경우</strong>,
AudioKit의 <code class="language-plaintext highlighter-rouge">AppleSequencer</code>와 <code class="language-plaintext highlighter-rouge">MIDISampler</code> 조합만으로는 <strong>정확한 사운드 전환을 구현하기 어렵습니다.</strong></p>

<p>기본적으로 <code class="language-plaintext highlighter-rouge">track.setMIDIOutput(sampler.midiIn)</code>으로 연결된 <code class="language-plaintext highlighter-rouge">MIDISampler</code>는 <strong>트랙 전체를 하나의 악기로만 재생</strong>합니다.
중간에 악기를 바꾸는 기능은 직접 처리해주지 않으면 반영되지 않습니다.</p>

<hr />

<h2 id="문제-상황-요약">문제 상황 요약</h2>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="n">track</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span>
  <span class="kt">ProgramChange</span><span class="p">(</span><span class="nv">channel</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nv">number</span><span class="p">:</span> <span class="mi">57</span><span class="p">)</span> <span class="c1">// 시작 시</span>
  <span class="kt">ProgramChange</span><span class="p">(</span><span class="nv">channel</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nv">number</span><span class="p">:</span> <span class="mi">60</span><span class="p">)</span> <span class="c1">// 64초쯤</span>
  <span class="kt">ProgramChange</span><span class="p">(</span><span class="nv">channel</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nv">number</span><span class="p">:</span> <span class="mi">57</span><span class="p">)</span> <span class="c1">// 120초쯤 복귀</span>
<span class="p">]</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>표준 MIDI에서는 이런 식으로 Program Change 메시지를 트랙 내에 삽입하여 <strong>동일 채널에 악기 전환</strong>을 수행</li>
  <li>AudioKit의 기본 Sequencer 처리 방식에서는 이를 자동 인식하거나 대응하지 않음</li>
</ul>

<hr />

<h2 id="-해결-방향">🎯 해결 방향</h2>

<h3 id="-program-change-이벤트를-파싱해서">① Program Change 이벤트를 파싱해서</h3>

<ul>
  <li>시점별로 <strong>악기(프리셋) 변경 정보</strong>를 추출</li>
</ul>

<h3 id="-해당-채널의-midi-이벤트를-악기-구간별로-나눠서">② 해당 채널의 MIDI 이벤트를 <strong>악기 구간별로 나눠서</strong></h3>

<ul>
  <li><strong>구간별 <code class="language-plaintext highlighter-rouge">MIDISampler</code>를 생성</strong>하거나</li>
  <li>하나의 Sampler에 <strong>프리셋을 실시간으로 변경 요청</strong>
(단, 대부분의 <code class="language-plaintext highlighter-rouge">MIDISampler</code>는 실행 중 preset 변경을 안정적으로 지원하지 않음)</li>
</ul>

<hr />

<h2 id="실현-가능한-접근-방법">실현 가능한 접근 방법</h2>

<h3 id="방법-a-트랙을-구간별로-분할하여-각각-sampler에-할당">방법 A: 트랙을 구간별로 분할하여 각각 sampler에 할당</h3>

<blockquote>
  <p>1개 트랙을 Program Change 기준으로 여러 개로 나누고,
구간마다 MIDISampler와 연결 → Mixer에 병합</p>
</blockquote>

<p>단점:</p>

<ul>
  <li>구현 복잡도 있음</li>
  <li>MIDI 이벤트 재구성이 필요</li>
</ul>

<h3 id="방법-b-programchange-메시지-수신-시-sampler의-preset을-변경">방법 B: ProgramChange 메시지 수신 시 sampler의 preset을 변경</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">if</span> <span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="nf">programChange</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">number</span><span class="p">)</span> <span class="o">=</span> <span class="n">event</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">channel</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">{</span>
    <span class="k">try</span><span class="p">?</span> <span class="n">sampler</span><span class="o">.</span><span class="nf">loadSoundFont</span><span class="p">(</span><span class="s">"CT8MGM"</span><span class="p">,</span> <span class="nv">preset</span><span class="p">:</span> <span class="n">number</span><span class="p">,</span> <span class="nv">bank</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>MIDI 이벤트를 수신하는 커스텀 <code class="language-plaintext highlighter-rouge">MIDIListener</code> 구현 필요</li>
  <li>실행 중 preset을 바꾸면 버퍼 끊김이나 글리치 발생 가능</li>
</ul>

<blockquote>
  <p><strong>실행 중 preset 변경은 대부분 권장되지 않음</strong></p>
</blockquote>

<hr />

<h2 id="권장-방식-현실적-대안">권장 방식 (현실적 대안)</h2>

<h3 id="-트랙-중간에-program-change가-있는-경우">🎯 트랙 중간에 Program Change가 있는 경우:</h3>

<ol>
  <li><strong>MIDI 파일을 외부에서 미리 분할</strong>하거나</li>
  <li><strong>DAW에서 동일 채널에 Program Change를 쓰지 않도록 재구성</strong></li>
  <li>또는 <strong>AudioKit으로 다룰 경우, 중간 ProgramChange를 무시하고 시작 preset만 사용</strong></li>
</ol>

<hr />

<h2 id="요약">요약</h2>

<table>
  <thead>
    <tr>
      <th>상황</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>트랙에 ProgramChange가 여러 개 있음</td>
      <td>MIDI 채널의 악기가 재생 중에 바뀜</td>
    </tr>
    <tr>
      <td>AudioKit <code class="language-plaintext highlighter-rouge">AppleSequencer</code></td>
      <td>한 트랙당 하나의 sampler만 연결됨</td>
    </tr>
    <tr>
      <td>실시간 preset 변경</td>
      <td>가능은 하지만 glitch 발생 가능</td>
    </tr>
    <tr>
      <td>현실적인 방법</td>
      <td>ProgramChange 기준으로 트랙을 사전 분할 또는 첫 preset만 사용</td>
    </tr>
  </tbody>
</table>]]></content><author><name>ayaysir(BGSMM)</name><email>your-email@example.com</email></author><category term="StudyLog" /><category term="AudioKit" /><category term="AudioKit" /><category term="음향이론" /><summary type="html"><![CDATA[MIDISampler+AppleSequencer를 이용한 미디 멀티트랙 재생 중 트랙 중간에 프로그램 체인지가 있는 경우 대응 방법]]></summary></entry><entry><title type="html">AudioKit의 MID Port Test</title><link href="/posts/MIDIPortTest/" rel="alternate" type="text/html" title="AudioKit의 MID Port Test" /><published>2025-06-23T00:42:28+09:00</published><updated>2025-06-23T00:42:28+09:00</updated><id>/posts/MIDIPortTest</id><content type="html" xml:base="/posts/MIDIPortTest/"><![CDATA[<h1 id="midi-port-test-virtual-midi-host-포함">MIDI Port Test (Virtual MIDI Host 포함)</h1>

<ul>
  <li><a href="https://github.com/ayaysir/Swift-Playgrounds/tree/main/AudioKit%20Cookbook%20Copy/AudioKit%20Cookbook%20Copy/Recipe/WIP/MIDIPortTest">코드 보기</a></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">MIDIPortTestConductor</code>는 AudioKit과 MIDIKit을 이용해 MIDI 포트를 테스트하거나 MIDI 이벤트를 수신/전송할 수 있도록 설계된 <strong>MIDI 테스트 도구의 핵심 로직 클래스</strong>입니다. 가상 포트를 생성하고, 외부 장치와 통신하며, MIDI 로그를 저장하고, 포트 정보를 조회하는 기능을 포함합니다.</p>

<hr />

<h2 id="주요-목적">주요 목적</h2>

<ul>
  <li>가상 MIDI 입/출력 포트 생성 및 관리</li>
  <li>외부 MIDI 장치 연결 및 포트 열기/닫기</li>
  <li>MIDI 이벤트 실시간 수신 및 로그 기록</li>
  <li>특정 포트로 이벤트 전송</li>
  <li>테스트용 UI와의 연결을 위한 ObservableObject 구현</li>
</ul>

<hr />

<h2 id="주요-구성요소-설명">주요 구성요소 설명</h2>

<h3 id="고정-uid-정의">고정 UID 정의</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">let</span> <span class="nv">inputUIDDevelop</span><span class="p">:</span> <span class="kt">Int32</span> <span class="o">=</span> <span class="mi">1_200_000</span>
<span class="k">let</span> <span class="nv">outputUIDDevelop</span><span class="p">:</span> <span class="kt">Int32</span> <span class="o">=</span> <span class="mi">1_500_000</span>
<span class="k">let</span> <span class="nv">inputUIDMain</span><span class="p">:</span> <span class="kt">Int32</span> <span class="o">=</span> <span class="mi">2_200_000</span>
<span class="k">let</span> <span class="nv">outputUIDMain</span><span class="p">:</span> <span class="kt">Int32</span> <span class="o">=</span> <span class="mi">2_500_000</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>고정된 UID를 가진 가상 포트를 생성하기 위해 사용됨</li>
  <li>UID 기반으로 포트 교체(swap)하거나 구분 가능</li>
</ul>

<hr />

<h3 id="published-속성"><code class="language-plaintext highlighter-rouge">@Published</code> 속성</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="kd">@Published</span> <span class="k">var</span> <span class="nv">log</span> <span class="o">=</span> <span class="p">[</span><span class="kt">MIDIEvent</span><span class="p">]()</span>
<span class="kd">@Published</span> <span class="k">var</span> <span class="nv">outputIsOpen</span><span class="p">:</span> <span class="kt">Bool</span>
<span class="kd">@Published</span> <span class="k">var</span> <span class="nv">outputPortIsSwapped</span><span class="p">:</span> <span class="kt">Bool</span>
<span class="kd">@Published</span> <span class="k">var</span> <span class="nv">inputPortIsSwapped</span><span class="p">:</span> <span class="kt">Bool</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>UI에서 실시간으로 바뀌는 값을 추적할 수 있도록 상태 노출</li>
  <li>MIDI 이벤트 기록(log), 포트 스왑 여부, 출력 포트 오픈 여부 관리</li>
</ul>

<hr />

<h3 id="midi-초기화">MIDI 초기화</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="n">midi</span><span class="o">.</span><span class="nf">destroyAllVirtualPorts</span><span class="p">()</span>
<span class="n">midi</span><span class="o">.</span><span class="nf">createVirtualInputPorts</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">midi</span><span class="o">.</span><span class="nf">createVirtualOutputPorts</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">midi</span><span class="o">.</span><span class="nf">addListener</span><span class="p">(</span><span class="k">self</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>기존 포트를 제거하고, UID를 지정한 가상 포트 생성</li>
  <li><code class="language-plaintext highlighter-rouge">self</code>를 <code class="language-plaintext highlighter-rouge">MIDIListener</code>로 등록하여 수신 처리 가능</li>
</ul>

<hr />

<h3 id="로그-버퍼링-및-timer-처리">로그 버퍼링 및 Timer 처리</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="kd">private</span> <span class="k">var</span> <span class="nv">logBuffer</span> <span class="o">=</span> <span class="p">[</span><span class="kt">MIDIEvent</span><span class="p">]()</span>
<span class="kd">private</span> <span class="k">var</span> <span class="nv">logTimer</span><span class="p">:</span> <span class="kt">Timer</span><span class="p">?</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>MIDI 이벤트를 실시간으로 <code class="language-plaintext highlighter-rouge">logBuffer</code>에 임시 저장</li>
  <li>0.5초마다 한 번씩 <code class="language-plaintext highlighter-rouge">flushLogBuffer()</code>를 호출해 log에 삽입 → UI 성능 저하 방지</li>
</ul>

<hr />

<h3 id="포트-설명-캐싱">포트 설명 캐싱</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kd">private</span> <span class="k">var</span> <span class="nv">portDescriptionCache</span><span class="p">:</span> <span class="p">[</span><span class="kt">MIDIUniqueID</span> <span class="p">:</span> <span class="kt">PortDescription</span><span class="p">]</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">inputPortDescription(forUID:)</code> 함수에서 매번 조회하지 않고 캐싱</li>
  <li>초기화 시 백그라운드 스레드에서 inputInfos를 순회해 캐싱해둠</li>
</ul>

<hr />

<h3 id="포트-열기-및-닫기">포트 열기 및 닫기</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="kd">func</span> <span class="nf">didSetOutputIsOpen</span><span class="p">()</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nf">openOutputs</span><span class="p">()</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nf">start</span><span class="p">()</span> <span class="o">/</span> <span class="nf">stop</span><span class="p">()</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">outputIsOpen</code>이 바뀔 때 포트를 열거나 닫음</li>
  <li><code class="language-plaintext highlighter-rouge">start()</code>는 input 포트 열기, <code class="language-plaintext highlighter-rouge">stop()</code>은 모두 닫기</li>
</ul>

<hr />

<h3 id="이벤트-전송">이벤트 전송</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kd">func</span> <span class="nf">sendEvent</span><span class="p">(</span><span class="nv">eventToSend</span><span class="p">:</span><span class="n">event</span><span class="p">,</span> <span class="nv">portIDs</span><span class="p">:[</span><span class="kt">MIDIUniqueID</span><span class="p">]?)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>
    <p>MIDIEvent 객체를 보고 적절한 AudioKit 전송 함수 호출</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">.controllerChange</code> → <code class="language-plaintext highlighter-rouge">sendControllerMessage</code></li>
      <li><code class="language-plaintext highlighter-rouge">.programChange</code> → <code class="language-plaintext highlighter-rouge">sendEvent(...)</code></li>
      <li><code class="language-plaintext highlighter-rouge">.noteOn</code> / <code class="language-plaintext highlighter-rouge">.noteOff</code> → 각각 전송</li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">swapVirtualOutputPorts()</code>로 포트 교체 가능</p>
  </li>
</ul>

<hr />

<h3 id="포트-스왑-기능">포트 스왑 기능</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="kd">func</span> <span class="nf">swapVirtualInputPort</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="kd">func</span> <span class="nf">swapVirtualOutputPorts</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>개발용 포트와 메인 포트를 교체하여 라우팅 방식 변경 가능</li>
  <li>예: 출력 포트 UID가 <code class="language-plaintext highlighter-rouge">outputUIDDevelop</code>이면 → <code class="language-plaintext highlighter-rouge">inputUIDDevelop</code>로 바꿈</li>
</ul>

<hr />

<h3 id="midilistener-구현">MIDIListener 구현</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="nf">receivedMIDINoteOn</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="nf">receivedMIDIController</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="o">...</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>MIDIKit이 제공하는 이벤트 콜백</li>
  <li>수신된 이벤트를 <code class="language-plaintext highlighter-rouge">logBuffer</code>에 추가</li>
  <li>로그에 포트 ID 포함 → 어떤 포트에서 들어온 메시지인지 추적 가능</li>
</ul>

<hr />

<h2 id="요약">요약</h2>

<table>
  <thead>
    <tr>
      <th>기능</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>가상 포트 생성</td>
      <td>고정 UID로 input/output 포트 생성</td>
    </tr>
    <tr>
      <td>포트 상태 토글</td>
      <td>outputIsOpen으로 열고 닫음</td>
    </tr>
    <tr>
      <td>포트 스왑</td>
      <td>개발용/메인 포트를 상황에 따라 교체</td>
    </tr>
    <tr>
      <td>MIDI 이벤트 수신</td>
      <td>MIDIListener 프로토콜 구현</td>
    </tr>
    <tr>
      <td>이벤트 로그 기록</td>
      <td><code class="language-plaintext highlighter-rouge">logBuffer</code> + 타이머 → <code class="language-plaintext highlighter-rouge">@Published log</code></td>
    </tr>
    <tr>
      <td>포트 정보 조회</td>
      <td>UID → 제조사/장치 이름 조회 및 캐싱</td>
    </tr>
    <tr>
      <td>이벤트 전송</td>
      <td>noteOn/noteOff/controller/program 등 구분 전송</td>
    </tr>
  </tbody>
</table>

<hr />

<h1 id="midiporttestview">MIDIPortTestView</h1>

<p><code class="language-plaintext highlighter-rouge">MIDIPortTestView</code>는 AudioKit + MIDIKit 기반의 SwiftUI 뷰로,
<strong>가상 및 외부 MIDI 포트의 입출력 테스트, CC/노트 전송, 포트 선택 및 실시간 로그 확인</strong> 기능을 제공합니다.
앱 또는 MIDI 툴에서 <strong>MIDI 포트 동작 상태를 시각적으로 테스트하거나 디버그하는 데 유용</strong>한 구성입니다.</p>

<hr />

<h2 id="전체-구조-요약">전체 구조 요약</h2>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="kt">MIDIPortTestView</span>
 <span class="err">├─</span> <span class="kt">HeaderArea</span>                     <span class="err">←</span> <span class="n">포트</span> <span class="n">개수</span> <span class="n">및</span> <span class="n">이름</span> <span class="n">헤더</span> <span class="n">표시</span>
 <span class="err">├─</span> <span class="kt">TabView</span>                       <span class="err">←</span> <span class="n">포트1</span><span class="o">/</span><span class="n">포트2</span> <span class="n">전환</span> <span class="kt">UI</span>
 <span class="err">│</span>   <span class="err">├─</span> <span class="kt">Port1SelectArea</span>           <span class="err">←</span> <span class="kt">Destination</span> <span class="n">포트</span> <span class="n">선택</span>
 <span class="err">│</span>   <span class="err">├─</span> <span class="kt">Port2SelectArea</span>           <span class="err">←</span> <span class="kt">Virtual</span> <span class="kt">Output</span> <span class="n">포트</span> <span class="n">선택</span>
 <span class="err">│</span>   <span class="err">└─</span> <span class="kt">PortEventArea</span><span class="p">(</span><span class="n">portID</span><span class="p">)</span>     <span class="err">←</span> <span class="n">선택</span> <span class="n">포트로</span> <span class="kt">Note</span><span class="o">/</span><span class="kt">CC</span> <span class="n">전송</span> <span class="n">버튼들</span>
 <span class="err">├─</span> <span class="n">포트</span> <span class="n">스왑</span><span class="o">/</span><span class="n">출력</span> <span class="n">여부</span> <span class="kt">Toggle</span>
 <span class="err">├─</span> <span class="kt">LogResetButtonArea</span>            <span class="err">←</span> <span class="n">로그</span> <span class="n">초기화</span> <span class="n">버튼</span>
 <span class="err">├─</span> <span class="kt">LogHeaderArea</span>                 <span class="err">←</span> <span class="kt">MIDI</span> <span class="n">로그의</span> <span class="n">컬럼</span> <span class="n">헤더</span>
 <span class="err">└─</span> <span class="kt">LogDataArea</span>                   <span class="err">←</span> <span class="n">수신된</span> <span class="kt">MIDI</span> <span class="n">로그</span> <span class="n">목록</span> <span class="n">표시</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<hr />

<h2 id="주요-구성-요소-설명">주요 구성 요소 설명</h2>

<h3 id="headerarea"><code class="language-plaintext highlighter-rouge">HeaderArea</code></h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kt">HeaderCell</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="c1">// 4칸</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>현재 MIDI 시스템에 등록된 포트 정보(입력/출력/가상 등)의 개수, 이름, UID를 표시</li>
</ul>

<hr />

<h3 id="tabview--port12selectarea"><code class="language-plaintext highlighter-rouge">TabView</code> + <code class="language-plaintext highlighter-rouge">Port1/2SelectArea</code></h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kt">TabView</span> <span class="p">{</span> <span class="kt">VStack</span> <span class="p">{</span> <span class="kt">Port1SelectArea</span> <span class="o">...</span> <span class="p">}</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">PageTabViewStyle</code>로 구성</li>
  <li>첫 페이지: 외부 Destination 포트 선택 + 버튼 전송</li>
  <li>두 번째 페이지: Virtual Output 포트 선택 + 전송</li>
</ul>

<hr />

<h3 id="porteventareaportid"><code class="language-plaintext highlighter-rouge">PortEventArea(portID:)</code></h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kt">MIDIEventButton</span><span class="p">(</span><span class="nv">eventToSend</span><span class="p">:</span> <span class="o">.</span><span class="n">noteOn</span> <span class="o">/</span> <span class="o">.</span><span class="n">noteOff</span> <span class="o">...</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>하드코딩된 노트 번호([60, 62, 64, 67, 69] 등)로 NoteOn/NoteOff 전송 버튼</li>
  <li>ProgramChange(랜덤 악기 변경), CC 1 (Mod Wheel) 전송 버튼 포함</li>
  <li>버튼 클릭 시 <code class="language-plaintext highlighter-rouge">conductor.sendEvent(...)</code> 호출로 해당 포트에 MIDI 전송</li>
</ul>

<hr />

<h3 id="로그-관련-ui">로그 관련 UI</h3>

<h4 id="logheaderarea"><code class="language-plaintext highlighter-rouge">LogHeaderArea</code></h4>

<ul>
  <li>상태, 채널, 데이터1~2, 포트 UID, 장치명, 제조사명 등 컬럼 헤더 출력</li>
</ul>

<h4 id="logdataarea"><code class="language-plaintext highlighter-rouge">LogDataArea</code></h4>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kt">ForEach</span><span class="p">(</span><span class="n">conductor</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span> <span class="p">{</span> <span class="n">i</span> <span class="k">in</span> <span class="o">...</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>실시간 MIDI 이벤트 로그 출력</li>
  <li>한 줄당 <code class="language-plaintext highlighter-rouge">.LazyHStack</code>으로 7개 항목 출력</li>
  <li><code class="language-plaintext highlighter-rouge">conductor.inputPortDescription(forUID:)</code>를 통해 포트 UID → 이름/제조사 변환 (성능 저하 원인)</li>
</ul>

<hr />

<h3 id="포트-상태-전환-토글">포트 상태 전환 토글</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="kt">Toggle</span><span class="p">(</span><span class="nv">isOn</span><span class="p">:</span> <span class="n">$conductor</span><span class="o">.</span><span class="n">outputIsOpen</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="kt">Toggle</span><span class="p">(</span><span class="nv">isOn</span><span class="p">:</span> <span class="n">$conductor</span><span class="o">.</span><span class="n">inputPortIsSwapped</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="kt">Toggle</span><span class="p">(</span><span class="nv">isOn</span><span class="p">:</span> <span class="n">$conductor</span><span class="o">.</span><span class="n">outputPortIsSwapped</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">outputIsOpen</code>: <code class="language-plaintext highlighter-rouge">openOutputs()</code> 실행 여부</li>
  <li><code class="language-plaintext highlighter-rouge">inputPortIsSwapped</code>: 가상 입력 포트 UID 스왑 여부</li>
  <li><code class="language-plaintext highlighter-rouge">outputPortIsSwapped</code>: 가상 출력 포트 UID 스왑 여부
→ <code class="language-plaintext highlighter-rouge">conductor.swapVirtualInputPort(...)</code> 등의 포트 경로 제어에 영향</li>
</ul>

<hr />

<h2 id="기능-요약">기능 요약</h2>

<table>
  <thead>
    <tr>
      <th>기능</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>포트 선택</td>
      <td>외부 포트 및 가상 포트 드롭다운 선택</td>
    </tr>
    <tr>
      <td>MIDI 이벤트 전송</td>
      <td>NoteOn/Off, CC, ProgramChange 전송</td>
    </tr>
    <tr>
      <td>포트 스왑</td>
      <td>가상 포트 UID를 상황에 따라 교체</td>
    </tr>
    <tr>
      <td>로그 보기</td>
      <td>수신된 MIDI 이벤트 로그 실시간 표시</td>
    </tr>
    <tr>
      <td>로그 초기화</td>
      <td>버튼으로 로그 지우기</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="주의개선-포인트">주의/개선 포인트</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">LogDataArea</code>에서 <code class="language-plaintext highlighter-rouge">inputPortDescription()</code>은 성능 병목 → 캐싱 또는 비동기 평가 필요</li>
  <li>포트 수가 많을 경우 Picker나 log 처리 성능 저하 발생 가능</li>
  <li>각 포트별 상태나 활성화 여부도 추가 UI로 제공 가능</li>
</ul>

<hr />

<h2 id="요약-1">요약</h2>

<p><code class="language-plaintext highlighter-rouge">MIDIPortTestView</code>는:</p>

<ul>
  <li><strong>가상/외부 MIDI 포트를 선택하고</strong></li>
  <li><strong>테스트용 MIDI 이벤트를 보내며</strong></li>
  <li><strong>수신되는 MIDI 로그를 실시간으로 시각화</strong>하는 데 최적화된 SwiftUI 뷰입니다.</li>
</ul>

<p>테스트 도구, 디버깅 뷰, 또는 DAW 플러그인 개발자용 MIDI 유틸리티로 활용할 수 있습니다.</p>

<hr />]]></content><author><name>ayaysir(BGSMM)</name><email>your-email@example.com</email></author><category term="StudyLog" /><category term="AudioKit" /><category term="AudioKit" /><category term="음향이론" /><summary type="html"><![CDATA[MIDI Port Test (Virtual MIDI Host 포함)]]></summary></entry><entry><title type="html">AudioKit의 PolyphonicSTK+MIDIKit</title><link href="/posts/PolyphonicSTK+MIDIKit/" rel="alternate" type="text/html" title="AudioKit의 PolyphonicSTK+MIDIKit" /><published>2025-06-22T19:03:37+09:00</published><updated>2025-06-22T19:03:37+09:00</updated><id>/posts/PolyphonicSTK+MIDIKit</id><content type="html" xml:base="/posts/PolyphonicSTK+MIDIKit/"><![CDATA[<h1 id="polyphonic-stk--midikit">Polyphonic STK + MIDIKit</h1>

<ul>
  <li><a href="https://github.com/ayaysir/Swift-Playgrounds/blob/main/AudioKit%20Cookbook%20Copy/AudioKit%20Cookbook%20Copy/Recipe/WIP/PolyphonicSTK%2BMIDIKit.swift">코드 보기</a></li>
</ul>

<p>이 코드는 AudioKit과 <a href="https://github.com/orchetect/MIDIKit"><strong>MIDIKit</strong></a>을 함께 사용하여,
가상 또는 외부 MIDI 장치로부터 들어오는 MIDI 이벤트를 수신하고,
<code class="language-plaintext highlighter-rouge">RhodesPianoKey</code>(SoundpipeAudioKit) 기반으로 폴리포닉 연주를 가능하게 하는 구조입니다.</p>

<hr />

<h2 id="midikit-관련-설명">MIDIKit 관련 설명</h2>

<h3 id="midimanager-생성">MIDIManager 생성</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">let</span> <span class="nv">midiManager</span> <span class="o">=</span> <span class="kt">MIDIManager</span><span class="p">(</span>
  <span class="nv">clientName</span><span class="p">:</span> <span class="s">"CookbookAppMIDIManager"</span><span class="p">,</span>
  <span class="nv">model</span><span class="p">:</span> <span class="s">"CookbookApp"</span><span class="p">,</span>
  <span class="nv">manufacturer</span><span class="p">:</span> <span class="s">"BGSMM"</span>
<span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>MIDIKit의 <strong>핵심 객체</strong></li>
  <li>CoreMIDI 클라이언트를 만들고, 포트와 연결을 관리함</li>
  <li>iOS/macOS의 MIDI 시스템과 연동됨</li>
</ul>

<hr />

<h3 id="midi-연결-설정-midiconnect">MIDI 연결 설정: <code class="language-plaintext highlighter-rouge">MIDIConnect()</code></h3>

<h4 id="1-midi-서비스-시작">1. MIDI 서비스 시작</h4>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="k">try</span> <span class="n">midiManager</span><span class="o">.</span><span class="nf">start</span><span class="p">()</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>MIDI 시스템 접근을 시작하며, 장치 탐색 및 연결 가능 상태로 전환</li>
</ul>

<h4 id="2-입력-연결-설정">2. 입력 연결 설정</h4>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="k">try</span> <span class="n">midiManager</span><span class="o">.</span><span class="nf">addInputConnection</span><span class="p">(</span>
  <span class="nv">to</span><span class="p">:</span> <span class="o">.</span><span class="n">allOutputs</span><span class="p">,</span>
  <span class="nv">tag</span><span class="p">:</span> <span class="s">"Listener"</span><span class="p">,</span>
  <span class="nv">filter</span><span class="p">:</span> <span class="o">.</span><span class="nf">owned</span><span class="p">(),</span>
  <span class="nv">receiver</span><span class="p">:</span> <span class="o">.</span><span class="n">events</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.allOutputs</code>: 연결 가능한 <strong>모든 외부 출력 포트</strong>를 수신 대상으로 설정</li>
  <li><code class="language-plaintext highlighter-rouge">filter: .owned()</code>: 본 앱이 만든 가상 포트는 <strong>수신 대상에서 제외</strong></li>
  <li><code class="language-plaintext highlighter-rouge">receiver: .events</code>: 이벤트 수신 핸들러</li>
</ul>

<hr />

<h3 id="이벤트-수신-핸들러">이벤트 수신 핸들러</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="nv">receiver</span><span class="p">:</span> <span class="o">.</span><span class="n">events</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="n">events</span><span class="p">,</span> <span class="n">timeStamp</span><span class="p">,</span> <span class="n">source</span> <span class="k">in</span>
  <span class="kt">Task</span> <span class="p">{</span> <span class="kd">@MainActor</span> <span class="k">in</span>
    <span class="k">for</span> <span class="n">event</span> <span class="k">in</span> <span class="n">events</span> <span class="p">{</span>
      <span class="k">self</span><span class="p">?</span><span class="o">.</span><span class="nf">received</span><span class="p">(</span><span class="nv">midiEvent</span><span class="p">:</span> <span class="n">event</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li><strong>비동기 클로저</strong>이며 백그라운드 스레드에서 호출됨</li>
  <li><code class="language-plaintext highlighter-rouge">Task { @MainActor in ... }</code>으로 UI 안전하게 업데이트</li>
  <li><code class="language-plaintext highlighter-rouge">self</code>는 <code class="language-plaintext highlighter-rouge">weak</code>으로 캡처하여 메모리 누수 방지</li>
</ul>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">@Sendable</code> 제한을 피하기 위해 <code class="language-plaintext highlighter-rouge">DispatchQueue.main.async</code> 대신 <code class="language-plaintext highlighter-rouge">Task { @MainActor }</code> 사용</p>
</blockquote>

<hr />

<h3 id="수신된-midi-이벤트-처리">수신된 MIDI 이벤트 처리</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kd">private</span> <span class="kd">func</span> <span class="nf">received</span><span class="p">(</span><span class="nv">midiEvent</span><span class="p">:</span> <span class="kt">MIDIEvent</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>MIDI 이벤트 타입별로 분기 처리</li>
</ul>

<table>
  <thead>
    <tr>
      <th>타입</th>
      <th>처리 내용</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">.noteOn</code></td>
      <td>음을 재생 + NotificationCenter로 노트 정보 전달</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">.noteOff</code></td>
      <td>해당 음을 멈춤 + NotificationCenter로 노트 정보 전달</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">.cc</code></td>
      <td>콘트롤 체인지 정보 콘솔 출력</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">.programChange</code></td>
      <td>프로그램 체인지 이벤트 출력</td>
    </tr>
    <tr>
      <td>기타</td>
      <td>무시</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">NotificationCenter.default.post(...)</code>는 외부 UI에 키보드 상태 전파에 사용됨</p>
</blockquote>

<hr />

<h2 id="audiokit-관련-간단-요약">AudioKit 관련 (간단 요약)</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">RhodesPianoKey</code> → 기본 오실레이터</li>
  <li><code class="language-plaintext highlighter-rouge">AmplitudeEnvelope</code>으로 각각 음의 게이트 제어</li>
  <li>최대 11음까지 동시에 연주 가능</li>
  <li><code class="language-plaintext highlighter-rouge">.noteOn</code>, <code class="language-plaintext highlighter-rouge">.noteOff</code>로 <code class="language-plaintext highlighter-rouge">envs[i].openGate()</code> / <code class="language-plaintext highlighter-rouge">closeGate()</code> 처리</li>
  <li>출력은 <code class="language-plaintext highlighter-rouge">Mixer(envs)</code> → <code class="language-plaintext highlighter-rouge">engine.output</code></li>
</ul>

<hr />

<h2 id="-동작-요약">🧪 동작 요약</h2>

<ol>
  <li>앱 실행 → MIDIManager 시작</li>
  <li>가상포트 혹은 실제 MIDI 키보드에서 노트를 누름</li>
  <li><code class="language-plaintext highlighter-rouge">.noteOn</code> 수신 → <code class="language-plaintext highlighter-rouge">noteOn(pitch:)</code> 호출</li>
  <li>RhodesPianoKey 연주 시작</li>
  <li><code class="language-plaintext highlighter-rouge">.noteOff</code> 수신 → <code class="language-plaintext highlighter-rouge">noteOff(pitch:)</code> → 게이트 닫힘</li>
</ol>

<hr />

<h2 id="사용-예">사용 예</h2>

<ul>
  <li>외부 MIDI 장치, 가상 MIDI 장치, DAW 등에서 이 앱으로 노트 전송 가능</li>
  <li>SwiftUI UI에서 <code class="language-plaintext highlighter-rouge">MIDIKItKeyboard</code>로 직접 연주도 가능</li>
  <li>모든 이벤트는 콘솔과 UI에 실시간 반영됨</li>
</ul>

<hr />]]></content><author><name>ayaysir(BGSMM)</name><email>your-email@example.com</email></author><category term="StudyLog" /><category term="AudioKit" /><category term="AudioKit" /><category term="음향이론" /><summary type="html"><![CDATA[Polyphonic STK + MIDIKit]]></summary></entry><entry><title type="html">AudioKit의 Roland TB303 Filter</title><link href="/posts/Roland_TB303_Filter/" rel="alternate" type="text/html" title="AudioKit의 Roland TB303 Filter" /><published>2025-06-22T17:36:28+09:00</published><updated>2025-06-22T17:36:28+09:00</updated><id>/posts/Roland_TB303_Filter</id><content type="html" xml:base="/posts/Roland_TB303_Filter/"><![CDATA[<h1 id="roland-tb-303-filter">Roland TB-303 Filter</h1>

<p><code class="language-plaintext highlighter-rouge">RolandTB303Filter</code>는 Roland의 전설적인 베이스 신시사이저 <strong>TB-303</strong>의 필터 사운드를 모방한 <strong>레조넌트 로우패스 필터</strong>입니다.
TB-303은 1980년대에 등장한 아날로그 신스 베이스 머신으로, 애시드 하우스(acid house)와 전자 음악 장르에서 매우 유명한 독특한 필터 사운드를 제공합니다.</p>

<hr />

<h2 id="️-roland-tb-303-filter란">🎛️ Roland TB-303 Filter란?</h2>

<ul>
  <li><strong>1-pole</strong> 혹은 <strong>4-pole 저역 통과 필터</strong>(Low-Pass Filter)로
고주파수를 잘라내고 저역만 통과시킵니다.</li>
  <li><strong>자극적이고 공격적인 레조넌스</strong> 특성으로 유명하며,
<strong>레조넌스를 극단적으로 높일 때 오실레이터처럼 자가 발진(self-oscillate)</strong> 하는 특성도 있음.</li>
  <li><code class="language-plaintext highlighter-rouge">SoundpipeAudioKit</code>에 구현된 <code class="language-plaintext highlighter-rouge">RolandTB303Filter</code>는 이 클래식한 아날로그 필터의 사운드 특성과 비선형 동작(디스토션, 비대칭성)을 디지털로 복제한 것입니다.</li>
</ul>

<hr />

<h2 id="️-파라미터-목록-및-효과-설명">⚙️ 파라미터 목록 및 효과 설명</h2>

<h3 id="1-cutoff-frequency">1. <strong>Cutoff Frequency</strong></h3>

<p><code class="language-plaintext highlighter-rouge">| 500.0 | 12.0...20000.0 Hz</code></p>

<ul>
  <li><strong>역할:</strong> 필터가 신호를 감쇄하기 시작하는 주파수</li>
  <li><strong>낮은 값:</strong> 저음만 통과 (우우우 하는 어두운 톤)</li>
  <li><strong>높은 값:</strong> 고음도 통과 → 밝고 날카로운 사운드</li>
</ul>

<blockquote>
  <p><strong>동적 제어</strong> 시 “와우 와우” 같은 자동 필터 스윕 효과 가능</p>
</blockquote>

<hr />

<h3 id="2-resonance">2. <strong>Resonance</strong></h3>

<p><code class="language-plaintext highlighter-rouge">| 0.5 | 0.0...2.0</code></p>

<ul>
  <li><strong>역할:</strong> 컷오프 주파수 근처의 특정 주파수를 강조(공명)</li>
  <li><strong>낮은 값 (0.0~0.3):</strong> 부드럽고 무난한 필터</li>
  <li><strong>중간 값 (0.5~1.0):</strong> TB-303 특유의 <strong>콱콱 찌르는 듯한 어택</strong> 생김</li>
  <li><strong>높은 값 (&gt;1.5):</strong> 거의 자체 발진에 가까운 강한 휘파람/휘웅 소리</li>
</ul>

<blockquote>
  <p><strong>TB-303 스타일 애시드 사운드의 핵심</strong></p>
</blockquote>

<hr />

<h3 id="3-distortion">3. <strong>Distortion</strong></h3>

<p><code class="language-plaintext highlighter-rouge">| 2.0 | 0.0...4.0</code></p>

<ul>
  <li><strong>역할:</strong> 필터 후단에 적용되는 <strong>비선형 오버드라이브 효과</strong></li>
  <li><strong>낮은 값:</strong> 깨끗하고 자연스러운 필터</li>
  <li><strong>중간 값 (~2.0):</strong> 살짝 과장된 <strong>빈티지 톤</strong></li>
  <li><strong>높은 값 (4.0):</strong> <strong>거칠고 찢어지는 음색</strong> → 애시드 사운드 강화</li>
</ul>

<blockquote>
  <p>디지털 필터의 지나치게 깔끔한 소리를 거칠게 만들기 위한 파라미터</p>
</blockquote>

<hr />

<h3 id="4-resonance-asymmetry">4. <strong>Resonance Asymmetry</strong></h3>

<p><code class="language-plaintext highlighter-rouge">| 0.5 | 0.0...1.0</code></p>

<ul>
  <li><strong>역할:</strong> 공명 피크(레조넌스)의 <strong>파형 비대칭도 제어</strong></li>
  <li><strong>0.0:</strong> 완전히 대칭적인 필터 반응</li>
  <li><strong>1.0:</strong> 비대칭 공명 → <strong>비자연적이고 디스토션된 느낌</strong></li>
  <li><strong>0.5:</strong> TB-303 특유의 <strong>약간 찌그러진 공명</strong> 표현 가능</li>
</ul>

<blockquote>
  <p>미세 조정용 파라미터로, 전체적인 톤의 “캐릭터”를 정함</p>
</blockquote>

<hr />

<h2 id="-파라미터-조합-예시">🧪 파라미터 조합 예시</h2>

<table>
  <thead>
    <tr>
      <th>Cutoff</th>
      <th>Resonance</th>
      <th>Distortion</th>
      <th>Asymmetry</th>
      <th>결과 사운드</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>800</td>
      <td>0.8</td>
      <td>1.5</td>
      <td>0.5</td>
      <td>기본적인 TB-303 베이스</td>
    </tr>
    <tr>
      <td>200</td>
      <td>1.8</td>
      <td>3.0</td>
      <td>1.0</td>
      <td>극단적 애시드 사운드, 거칠고 공격적</td>
    </tr>
    <tr>
      <td>1000</td>
      <td>0.2</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>부드럽고 깨끗한 베이스 필터링</td>
    </tr>
    <tr>
      <td>1500</td>
      <td>1.0</td>
      <td>4.0</td>
      <td>0.3</td>
      <td>고역 강조, 디스토션된 리드 사운드</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-요약">✅ 요약</h2>

<ul>
  <li><strong>RolandTB303Filter</strong>는 TB-303 베이스 신스의 핵심 요소인 <strong>레조넌트 로우패스 필터</strong>를 재현한 것</li>
  <li><strong>Cutoff + Resonance</strong>의 조합이 사운드 캐릭터의 중심</li>
  <li><strong>Distortion</strong>은 날카로운 빈티지 톤을 더함</li>
  <li><strong>Resonance Asymmetry</strong>는 필터의 비선형성을 미세하게 조절함</li>
</ul>]]></content><author><name>ayaysir(BGSMM)</name><email>your-email@example.com</email></author><category term="StudyLog" /><category term="AudioKit" /><category term="AudioKit" /><category term="음향이론" /><summary type="html"><![CDATA[Roland TB-303 Filter]]></summary></entry><entry><title type="html">AudioKit의 DunneSynth</title><link href="/posts/DunneSynth/" rel="alternate" type="text/html" title="AudioKit의 DunneSynth" /><published>2025-06-22T15:58:34+09:00</published><updated>2025-06-22T15:58:34+09:00</updated><id>/posts/DunneSynth</id><content type="html" xml:base="/posts/DunneSynth/"><![CDATA[<h1 id="dunne-synth">Dunne Synth</h1>

<ul>
  <li><a href="https://github.com/ayaysir/Swift-Playgrounds/blob/main/AudioKit%20Cookbook%20Copy/AudioKit%20Cookbook%20Copy/Recipe/WIP/DunneSynth.swift">코드 보기</a></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">DunneSynthConductor</code>는 AudioKit의 <code class="language-plaintext highlighter-rouge">Synth</code> (정확히는 <code class="language-plaintext highlighter-rouge">DunneAudioKit</code>의 Dunne Synthesizer)를 제어하는 <strong>오디오 신스 컨덕터 클래스</strong>입니다.
SwiftUI 기반의 UI와 연동하여 신스의 파라미터 조정, 노트 재생, 피크 리미팅, 팝 제거 등 다양한 오디오 처리 제어를 담당합니다.</p>

<hr />

<h2 id="클래스-개요">클래스 개요</h2>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kd">class</span> <span class="kt">DunneSynthConductor</span><span class="p">:</span> <span class="kt">ObservableObject</span><span class="p">,</span> <span class="kt">HasAudioEngine</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ObservableObject</code>이므로 SwiftUI 뷰와 상태 바인딩 가능</li>
  <li><code class="language-plaintext highlighter-rouge">HasAudioEngine</code> 프로토콜을 통해 <code class="language-plaintext highlighter-rouge">engine</code> 및 노드 연결 보장</li>
  <li>내부에서 <code class="language-plaintext highlighter-rouge">Synth</code> 객체를 사용하여 가상 악기를 구현</li>
</ul>

<hr />

<h2 id="주요-구성-요소">주요 구성 요소</h2>

<h3 id="let-engine--audioengine"><code class="language-plaintext highlighter-rouge">let engine = AudioEngine()</code></h3>

<ul>
  <li>AudioKit의 핵심 오디오 처리 엔진</li>
</ul>

<h3 id="var-instrument--synth"><code class="language-plaintext highlighter-rouge">var instrument = Synth()</code></h3>

<ul>
  <li>DunneAudioKit의 <strong>폴리포닉 신스</strong></li>
  <li>매핑된 파라미터들을 실시간으로 제어 가능</li>
</ul>

<hr />

<h2 id="noteon--noteoff">noteOn / noteOff</h2>

<h3 id="func-noteonpitch-pitch-point-_-cgpoint"><code class="language-plaintext highlighter-rouge">func noteOn(pitch: Pitch, point _: CGPoint)</code></h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">instrument</span><span class="o">.</span><span class="nf">play</span><span class="p">(</span><span class="nv">noteNumber</span><span class="p">:</span> <span class="o">...</span><span class="p">,</span> <span class="nv">velocity</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="nv">channel</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>전달된 <code class="language-plaintext highlighter-rouge">Pitch</code>를 MIDI note로 변환하여 재생 시작</li>
</ul>

<h3 id="func-noteoffpitch-pitch"><code class="language-plaintext highlighter-rouge">func noteOff(pitch: Pitch)</code></h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">instrument</span><span class="o">.</span><span class="nf">stop</span><span class="p">(</span><span class="nv">noteNumber</span><span class="p">:</span> <span class="o">...</span><span class="p">,</span> <span class="nv">channel</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>해당 음 높이의 노트를 정지시킴</li>
</ul>

<hr />

<h2 id="초기화-init">초기화: <code class="language-plaintext highlighter-rouge">init()</code></h2>

<h3 id="1-engineoutput--peaklimiter">1. <code class="language-plaintext highlighter-rouge">engine.output = PeakLimiter(...)</code></h3>

<ul>
  <li>출력단에 <code class="language-plaintext highlighter-rouge">PeakLimiter</code> 삽입 → 소리의 <strong>과도한 피크 방지</strong></li>
  <li><code class="language-plaintext highlighter-rouge">attackTime = 0.001</code>: 피크 감지 후 빠르게 제한</li>
  <li><code class="language-plaintext highlighter-rouge">decayTime = 0.001</code>: 제한 해제도 즉시</li>
  <li><code class="language-plaintext highlighter-rouge">preGain = 0</code>: 입력 게인을 증폭하지 않음</li>
</ul>

<h3 id="2-팝-노이즈-제거-설정">2. 팝 노이즈 제거 설정</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="n">instrument</span><span class="o">.</span><span class="n">releaseDuration</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="n">instrument</span><span class="o">.</span><span class="n">filterReleaseDuration</span> <span class="o">=</span> <span class="mf">10.0</span>
<span class="n">instrument</span><span class="o">.</span><span class="n">filterStrength</span> <span class="o">=</span> <span class="mf">40.0</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">releaseDuration</code>이 너무 짧으면 소리가 갑자기 끊기면서 <strong>팝(Pop)</strong> 노이즈 발생</li>
  <li><code class="language-plaintext highlighter-rouge">filterReleaseDuration</code>을 길게 설정해 필터 계열 소리가 부드럽게 사라지도록 함</li>
  <li><code class="language-plaintext highlighter-rouge">filterStrength</code>는 필터 적용 정도 조절</li>
</ul>

<hr />

<h2 id="파라미터-목록">파라미터 목록</h2>

<h3 id="일반-음성-파라미터">일반 음성 파라미터</h3>

<table>
  <thead>
    <tr>
      <th>파라미터</th>
      <th>기본값</th>
      <th>범위</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Master Volume</code></td>
      <td><code class="language-plaintext highlighter-rouge">1.0</code></td>
      <td><code class="language-plaintext highlighter-rouge">0.0...1.0</code></td>
      <td>전체 출력 볼륨</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Pitch Bend</code></td>
      <td><code class="language-plaintext highlighter-rouge">0.0</code></td>
      <td><code class="language-plaintext highlighter-rouge">-24.0...24.0</code></td>
      <td>실시간 피치 변조 (세미톤 단위)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Vibrato Depth</code></td>
      <td><code class="language-plaintext highlighter-rouge">0.0</code></td>
      <td><code class="language-plaintext highlighter-rouge">0.0...12.0</code></td>
      <td>비브라토 강도</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Filter Cutoff</code></td>
      <td><code class="language-plaintext highlighter-rouge">1.0</code></td>
      <td><code class="language-plaintext highlighter-rouge">0.0...1.0</code></td>
      <td>필터 컷오프 주파수 (정규화)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Filter Strength</code></td>
      <td><code class="language-plaintext highlighter-rouge">40.0</code></td>
      <td><code class="language-plaintext highlighter-rouge">0.0...100.0</code></td>
      <td>필터 효과의 강도</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Filter Resonance</code></td>
      <td><code class="language-plaintext highlighter-rouge">0.0</code></td>
      <td><code class="language-plaintext highlighter-rouge">-20.0...20.0</code></td>
      <td>공명(Resonance) 강도</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="앰플리튜드-adsr-amplitude-envelope">앰플리튜드 ADSR (Amplitude Envelope)</h3>

<table>
  <thead>
    <tr>
      <th>파라미터</th>
      <th>기본값</th>
      <th>범위</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Attack Duration</code></td>
      <td><code class="language-plaintext highlighter-rouge">0.0</code></td>
      <td><code class="language-plaintext highlighter-rouge">0.0...10.0</code></td>
      <td>노트 시작 시 볼륨이 증가하는 시간</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Decay Duration</code></td>
      <td><code class="language-plaintext highlighter-rouge">0.0</code></td>
      <td><code class="language-plaintext highlighter-rouge">0.0...10.0</code></td>
      <td>최대 볼륨에서 지속 볼륨까지 줄어드는 시간</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Sustain Level</code></td>
      <td><code class="language-plaintext highlighter-rouge">1.0</code></td>
      <td><code class="language-plaintext highlighter-rouge">0.0...1.0</code></td>
      <td>키를 누르고 있을 때 유지되는 볼륨</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Release Duration</code></td>
      <td><code class="language-plaintext highlighter-rouge">0.01</code></td>
      <td><code class="language-plaintext highlighter-rouge">0.0...10.0</code></td>
      <td>노트 종료 후 소리가 사라지는 시간</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="필터-adsr-filter-envelope">필터 ADSR (Filter Envelope)</h3>

<table>
  <thead>
    <tr>
      <th>파라미터</th>
      <th>기본값</th>
      <th>범위</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Filter Attack Duration</code></td>
      <td><code class="language-plaintext highlighter-rouge">0.0</code></td>
      <td><code class="language-plaintext highlighter-rouge">0.0...10.0</code></td>
      <td>필터가 작동을 시작하는 데 걸리는 시간</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Filter Decay Duration</code></td>
      <td><code class="language-plaintext highlighter-rouge">0.0</code></td>
      <td><code class="language-plaintext highlighter-rouge">0.0...10.0</code></td>
      <td>필터가 최대 효과에서 사라지는 시간</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Filter Sustain Level</code></td>
      <td><code class="language-plaintext highlighter-rouge">1.0</code></td>
      <td><code class="language-plaintext highlighter-rouge">0.0...1.0</code></td>
      <td>필터 효과의 유지 비율</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Filter Release Duration</code></td>
      <td><code class="language-plaintext highlighter-rouge">10.0</code></td>
      <td><code class="language-plaintext highlighter-rouge">0.0...10.0</code></td>
      <td>필터 효과가 사라지는 시간</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="콘솔-출력">콘솔 출력</h2>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="n">instrument</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">forEach</span> <span class="p">{</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="nv">$0</span><span class="o">.</span><span class="n">def</span><span class="o">.</span><span class="n">name</span><span class="se">)</span><span class="s"> | </span><span class="se">\(</span><span class="nv">$0</span><span class="o">.</span><span class="n">value</span><span class="se">)</span><span class="s"> | </span><span class="se">\(</span><span class="nv">$0</span><span class="o">.</span><span class="n">range</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>모든 파라미터 이름, 현재값, 범위를 디버깅용으로 출력</li>
  <li>UI 연결 확인이나 슬라이더 구성 시 유용함</li>
</ul>

<hr />

<h2 id="요약">요약</h2>

<p><code class="language-plaintext highlighter-rouge">DunneSynthConductor</code>는:</p>

<ul>
  <li>AudioKit의 Dunne 신스를 제어하고</li>
  <li>소리의 피크와 팝 노이즈를 제어하며</li>
  <li>다양한 신스 파라미터들을 외부 UI와 연결할 수 있게 준비된 컨트롤러입니다.</li>
</ul>

<blockquote>
  <p>SwiftUI와 함께 사용할 때 매우 직관적인 신디사이저 앱이나 교육용 악기 UI를 구성하는 데 적합합니다.</p>
</blockquote>]]></content><author><name>ayaysir(BGSMM)</name><email>your-email@example.com</email></author><category term="StudyLog" /><category term="AudioKit" /><category term="AudioKit" /><category term="음향이론" /><summary type="html"><![CDATA[Dunne Synth]]></summary></entry><entry><title type="html">AudioKit의 InputDeviceDemo+ChannelRouting</title><link href="/posts/InputDeviceDemo+ChannelRouting/" rel="alternate" type="text/html" title="AudioKit의 InputDeviceDemo+ChannelRouting" /><published>2025-06-22T15:36:36+09:00</published><updated>2025-06-22T15:36:36+09:00</updated><id>/posts/InputDeviceDemo+ChannelRouting</id><content type="html" xml:base="/posts/InputDeviceDemo+ChannelRouting/"><![CDATA[<h1 id="input-device-demo">Input Device Demo</h1>

<ul>
  <li><a href="https://github.com/ayaysir/Swift-Playgrounds/blob/main/AudioKit%20Cookbook%20Copy/AudioKit%20Cookbook%20Copy/Recipe/WIP/InputDeviceDemo.swift">코드 보기</a></li>
</ul>

<p>이 SwiftUI + AudioKit 코드의 목적은 <strong>입력 장치(마이크)를 선택하고 오디오 입력을 시작/정지하는 UI를 제공하는 것</strong>입니다.
즉, 여러 마이크 장치가 연결된 환경에서 사용자가 원하는 입력을 선택하고, 마이크 버튼을 눌러 오디오 입력을 켜거나 끌 수 있게 합니다.</p>

<blockquote>
  <p>Channel/Device Routing 예제와 거의 동일</p>
</blockquote>

<hr />

<h2 id="-클래스-inputdevicedemoconductor">🔧 클래스: <code class="language-plaintext highlighter-rouge">InputDeviceDemoConductor</code></h2>

<h3 id="-역할-오디오-입력-장치-관리--audiokit-엔진-제어">✅ 역할: 오디오 입력 장치 관리 + AudioKit 엔진 제어</h3>

<h4 id="주요-속성">주요 속성</h4>

<table>
  <thead>
    <tr>
      <th>변수</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">engine</code></td>
      <td>AudioKit의 <code class="language-plaintext highlighter-rouge">AudioEngine</code> 인스턴스</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">mic</code></td>
      <td>현재 연결된 오디오 입력 노드 (<code class="language-plaintext highlighter-rouge">engine.input</code>)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">mixer</code></td>
      <td>입력을 오디오 엔진의 출력으로 연결하기 위한 믹서 노드</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">inputDevices</code></td>
      <td><code class="language-plaintext highlighter-rouge">AVAudioSession</code>에서 얻은 사용 가능한 오디오 입력 장치 목록</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">inputDeviceList</code></td>
      <td><code class="language-plaintext highlighter-rouge">Picker</code>에 표시할 장치 이름 목록 (portName 배열)</td>
    </tr>
  </tbody>
</table>

<h4 id="init"><code class="language-plaintext highlighter-rouge">init()</code></h4>

<ul>
  <li>오디오 입력 노드가 있을 경우 <code class="language-plaintext highlighter-rouge">mic</code>에 할당하고 <code class="language-plaintext highlighter-rouge">Mixer(input)</code>으로 연결</li>
  <li>입력 장치 목록(<code class="language-plaintext highlighter-rouge">inputDevices</code>)을 불러와 <code class="language-plaintext highlighter-rouge">portName</code>을 <code class="language-plaintext highlighter-rouge">inputDeviceList</code>에 저장</li>
  <li><code class="language-plaintext highlighter-rouge">engine.output = mixer</code>를 통해 믹서를 엔진의 출력으로 설정</li>
</ul>

<h4 id="switchinputnumber"><code class="language-plaintext highlighter-rouge">switchInput(number:)</code></h4>

<ul>
  <li>선택된 입력 장치를 <code class="language-plaintext highlighter-rouge">setPreferredInput(...)</code>으로 변경</li>
  <li>변경 전에는 <code class="language-plaintext highlighter-rouge">stop()</code> 호출로 엔진을 멈춤</li>
</ul>

<hr />

<h2 id="️-view-inputdevicedemoview">🖼️ View: <code class="language-plaintext highlighter-rouge">InputDeviceDemoView</code></h2>

<h3 id="-역할-ui를-통해-입력-장치-선택-및-오디오-입력-시작정지">✅ 역할: UI를 통해 입력 장치 선택 및 오디오 입력 시작/정지</h3>

<h4 id="주요-상태-변수">주요 상태 변수</h4>

<table>
  <thead>
    <tr>
      <th>변수</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">isPlaying</code></td>
      <td>오디오 입력이 현재 켜져 있는지 여부</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">inputDevice</code></td>
      <td>현재 선택된 입력 장치의 인덱스 (<code class="language-plaintext highlighter-rouge">Picker</code>에서 선택됨)</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="-뷰-구조-설명">✅ 뷰 구조 설명</h3>

<h4 id="-안내-텍스트">📍 안내 텍스트</h4>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="kt">Text</span><span class="p">(</span><span class="s">"Please plug in headphones"</span><span class="p">)</span>
<span class="kt">Text</span><span class="p">(</span><span class="s">"to avoid a feedback loop."</span><span class="p">)</span>
<span class="kt">Text</span><span class="p">(</span><span class="s">"Then, select a device to start!"</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>피드백(하울링)을 피하기 위해 이어폰 사용을 권장</li>
</ul>

<hr />

<h4 id="-입력-장치-선택-picker">🎛 입력 장치 선택 Picker</h4>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="kt">Picker</span><span class="p">(</span><span class="s">"Input Device"</span><span class="p">,</span> <span class="nv">selection</span><span class="p">:</span> <span class="n">$inputDevice</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">ForEach</span><span class="p">(</span><span class="n">conductor</span><span class="o">.</span><span class="n">inputDeviceList</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="nv">id</span><span class="p">:</span> <span class="p">\</span><span class="o">.</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span> <span class="n">i</span> <span class="k">in</span>
    <span class="kt">Text</span><span class="p">(</span><span class="n">conductor</span><span class="o">.</span><span class="n">inputDeviceList</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
      <span class="o">.</span><span class="nf">tag</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">conductor.inputDeviceList</code>에 저장된 장치 이름을 기반으로 Picker 구성</li>
  <li>선택이 변경되면 <code class="language-plaintext highlighter-rouge">.onChange(of: inputDevice)</code>를 통해 <code class="language-plaintext highlighter-rouge">switchInput(...)</code> 호출</li>
</ul>

<hr />

<h4 id="-마이크-onoff-버튼">🎤 마이크 on/off 버튼</h4>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="kt">Button</span> <span class="p">{</span>
  <span class="n">isPlaying</span> <span class="p">?</span> <span class="n">conductor</span><span class="o">.</span><span class="nf">stop</span><span class="p">()</span> <span class="p">:</span> <span class="n">conductor</span><span class="o">.</span><span class="nf">start</span><span class="p">()</span>
  <span class="n">isPlaying</span><span class="o">.</span><span class="nf">toggle</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>클릭 시 마이크 입력이 시작되거나 종료</li>
  <li>버튼의 아이콘은 <code class="language-plaintext highlighter-rouge">isPlaying</code> 상태에 따라 <code class="language-plaintext highlighter-rouge">"mic.circle"</code> 또는 <code class="language-plaintext highlighter-rouge">"mic.circle.fill"</code>로 바뀜</li>
  <li><code class="language-plaintext highlighter-rouge">.resizable()</code> + <code class="language-plaintext highlighter-rouge">.frame(...)</code>으로 크기와 정렬 지정</li>
</ul>

<hr />

<h4 id="-종료-시-동작">📤 종료 시 동작</h4>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="o">.</span><span class="n">onDisappear</span> <span class="p">{</span>
  <span class="n">conductor</span><span class="o">.</span><span class="nf">stop</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>뷰가 사라질 때 자동으로 오디오 입력 종료</li>
</ul>

<hr />

<h2 id="-전체-동작-요약">✅ 전체 동작 요약</h2>

<table>
  <thead>
    <tr>
      <th>상황</th>
      <th>동작</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>앱 시작</td>
      <td>AudioKit 엔진 초기화 + 사용 가능한 입력 장치 목록 확보</td>
    </tr>
    <tr>
      <td>장치 선택</td>
      <td>선택된 장치로 입력 전환 (<code class="language-plaintext highlighter-rouge">switchInput</code>)</td>
    </tr>
    <tr>
      <td>버튼 클릭</td>
      <td>오디오 입력 시작/정지 (<code class="language-plaintext highlighter-rouge">start()</code> / <code class="language-plaintext highlighter-rouge">stop()</code>)</td>
    </tr>
    <tr>
      <td>뷰 종료</td>
      <td>입력 강제 종료</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-확장-가능성">✅ 확장 가능성</h2>

<ul>
  <li>입력 장치별 채널 수 확인</li>
  <li>입력을 파일로 녹음</li>
  <li>출력 장치 설정도 추가 가능</li>
</ul>

<hr />

<p>이 코드는 AudioKit을 활용한 <strong>기초 오디오 입출력 제어 구조</strong>를 익히기에 적절한 예제입니다.</p>]]></content><author><name>ayaysir(BGSMM)</name><email>your-email@example.com</email></author><category term="StudyLog" /><category term="AudioKit" /><category term="AudioKit" /><category term="음향이론" /><summary type="html"><![CDATA[Input Device Demo]]></summary></entry><entry><title type="html">AudioKit에서 BaseTapForSpeechRecognition을 사용한 음성인식 예제</title><link href="/posts/BaseTapForSpeechRecognition/" rel="alternate" type="text/html" title="AudioKit에서 BaseTapForSpeechRecognition을 사용한 음성인식 예제" /><published>2025-06-21T22:06:46+09:00</published><updated>2025-06-21T22:06:46+09:00</updated><id>/posts/BaseTapForSpeechRecognition</id><content type="html" xml:base="/posts/BaseTapForSpeechRecognition/"><![CDATA[<h1 id="base-tap-for-speech-recognition">Base Tap for Speech Recognition</h1>

<ul>
  <li><a href="https://github.com/ayaysir/Swift-Playgrounds/blob/main/AudioKit%20Cookbook%20Copy/AudioKit%20Cookbook%20Copy/Recipe/WIP/BaseTapDemo.swift">코드 보기</a></li>
</ul>

<p>현재 코드에서의 <code class="language-plaintext highlighter-rouge">SpeechRecognitionTap</code>과 <code class="language-plaintext highlighter-rouge">BaseTapForSpeechRecognitionConductor</code>는 <strong>AudioKit</strong>과 <strong>Speech Framework</strong>를 연결하여 실시간으로 마이크 입력을 받아 <strong>음성 인식 결과를 텍스트로 출력</strong>하는 역할을 수행합니다.
변경된 코드 기준으로 두 클래스의 구성과 동작을 자세히 설명드리겠습니다.</p>

<hr />

<h2 id="-speechrecognitiontap-마이크-오디오-버퍼를-음성-인식기로-전달">✅ <code class="language-plaintext highlighter-rouge">SpeechRecognitionTap</code>: 마이크 오디오 버퍼를 음성 인식기로 전달</h2>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kd">class</span> <span class="kt">SpeechRecognitionTap</span><span class="p">:</span> <span class="kt">BaseTap</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">BaseTap</code>은 AudioKit에서 입력을 분석하기 위한 탭(Tap)을 구현할 때 사용하는 기본 클래스입니다. <code class="language-plaintext highlighter-rouge">SpeechRecognitionTap</code>은 이를 상속받아 Apple의 <code class="language-plaintext highlighter-rouge">Speech</code> 프레임워크와 연결하는 데 초점을 둡니다.</p>

<h3 id="-주요-프로퍼티">🔧 주요 프로퍼티</h3>

<table>
  <thead>
    <tr>
      <th>프로퍼티</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">recognitionRequest</code></td>
      <td>오디오 버퍼를 지속적으로 전달받는 객체 (<code class="language-plaintext highlighter-rouge">SFSpeechAudioBufferRecognitionRequest</code>)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">analyzer</code></td>
      <td>언어별 음성 인식기 (<code class="language-plaintext highlighter-rouge">SFSpeechRecognizer</code>)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">reconitionTask</code></td>
      <td>실제 인식 작업을 수행하는 비동기 작업 (<code class="language-plaintext highlighter-rouge">SFSpeechRecognitionTask</code>)</td>
    </tr>
  </tbody>
</table>

<h3 id="-메서드-설명">🔨 메서드 설명</h3>

<h4 id="setuprecognitionlocale"><code class="language-plaintext highlighter-rouge">setupRecognition(locale:)</code></h4>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kd">func</span> <span class="nf">setupRecognition</span><span class="p">(</span><span class="nv">locale</span><span class="p">:</span> <span class="kt">Locale</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>선택한 언어(<code class="language-plaintext highlighter-rouge">Locale</code>)에 맞는 <code class="language-plaintext highlighter-rouge">SFSpeechRecognizer</code> 인스턴스를 생성</li>
  <li>실시간 스트리밍 인식을 위한 <code class="language-plaintext highlighter-rouge">SFSpeechAudioBufferRecognitionRequest</code> 초기화</li>
  <li><code class="language-plaintext highlighter-rouge">recognitionRequest.shouldReportPartialResults = true</code> 설정으로 중간 결과도 실시간 전달 가능</li>
</ul>

<h4 id="stoprecognition"><code class="language-plaintext highlighter-rouge">stopRecognition()</code></h4>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kd">func</span> <span class="nf">stopRecognition</span><span class="p">()</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>음성 인식 세션을 종료하고 관련 객체를 초기화하여 해제</li>
</ul>

<h4 id="dohandletapblockbufferat"><code class="language-plaintext highlighter-rouge">doHandleTapBlock(buffer:at:)</code></h4>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="k">override</span> <span class="kd">func</span> <span class="nf">doHandleTapBlock</span><span class="p">(</span><span class="nv">buffer</span><span class="p">:</span> <span class="kt">AVAudioPCMBuffer</span><span class="p">,</span> <span class="n">at</span> <span class="nv">time</span><span class="p">:</span> <span class="kt">AVAudioTime</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>AudioKit에서 자동으로 호출되는 메서드</li>
  <li>마이크 입력 버퍼를 <code class="language-plaintext highlighter-rouge">recognitionRequest</code>에 전달하여 음성 인식기가 실시간으로 처리하게 함</li>
</ul>

<hr />

<h2 id="-basetapforspeechrecognitionconductor-음성-인식과-오디오-경로를-통합-관리">✅ <code class="language-plaintext highlighter-rouge">BaseTapForSpeechRecognitionConductor</code>: 음성 인식과 오디오 경로를 통합 관리</h2>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kd">class</span> <span class="kt">BaseTapForSpeechRecognitionConductor</span><span class="p">:</span> <span class="kt">ObservableObject</span><span class="p">,</span> <span class="kt">HasAudioEngine</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="-주요-프로퍼티-1">🔧 주요 프로퍼티</h3>

<table>
  <thead>
    <tr>
      <th>프로퍼티</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">textString</code></td>
      <td>인식된 텍스트 결과</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">languageCode</code></td>
      <td>선택된 언어 코드 (<code class="language-plaintext highlighter-rouge">en-US</code>, <code class="language-plaintext highlighter-rouge">ko-KR</code>, <code class="language-plaintext highlighter-rouge">ja-JP</code>)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">srTap</code></td>
      <td><code class="language-plaintext highlighter-rouge">SpeechRecognitionTap</code> 인스턴스</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">engine</code>, <code class="language-plaintext highlighter-rouge">mic</code>, <code class="language-plaintext highlighter-rouge">outputMixer</code>, <code class="language-plaintext highlighter-rouge">silencer</code></td>
      <td>AudioKit의 오디오 라우팅 구성 요소</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">recognitionTask</code></td>
      <td>음성 인식 작업 참조용</td>
    </tr>
  </tbody>
</table>

<h3 id="-주요-로직">🔨 주요 로직</h3>

<h4 id="init"><code class="language-plaintext highlighter-rouge">init()</code></h4>

<ul>
  <li>오디오 엔진과 마이크 입력 초기화</li>
  <li>AudioKit의 <code class="language-plaintext highlighter-rouge">output = silencer</code>로 출력 경로 설정 (실제 소리는 꺼둔 상태)</li>
  <li><code class="language-plaintext highlighter-rouge">srTap.start()</code>로 마이크 데이터 수집 시작</li>
  <li><code class="language-plaintext highlighter-rouge">setLanguage(code:)</code>를 호출하여 기본 언어로 음성 인식 시작</li>
</ul>

<h4 id="setlanguagecode"><code class="language-plaintext highlighter-rouge">setLanguage(code:)</code></h4>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kd">func</span> <span class="nf">setLanguage</span><span class="p">(</span><span class="nv">code</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>현재 음성 인식 세션을 중단 (<code class="language-plaintext highlighter-rouge">stopRecognition</code>, <code class="language-plaintext highlighter-rouge">stop</code>)</li>
  <li>오디오 엔진을 재시작</li>
  <li>새로운 언어로 <code class="language-plaintext highlighter-rouge">SFSpeechRecognizer</code>를 초기화하고 <code class="language-plaintext highlighter-rouge">recognitionRequest</code>를 설정</li>
  <li><code class="language-plaintext highlighter-rouge">recognitionTask</code>를 새로 만들어 <code class="language-plaintext highlighter-rouge">textString</code>에 실시간 결과를 반영</li>
</ul>

<blockquote>
  <p><strong>핵심</strong>: 언어가 바뀔 때 <code class="language-plaintext highlighter-rouge">engine</code>, <code class="language-plaintext highlighter-rouge">tap</code>, <code class="language-plaintext highlighter-rouge">recognizer</code>를 모두 재시작해서 새로운 인식 환경을 구성</p>
</blockquote>

<hr />

<h2 id="-흐름-요약">🧠 흐름 요약</h2>

<ol>
  <li>뷰가 나타남 → <code class="language-plaintext highlighter-rouge">init()</code>에서 오디오 및 인식기 설정</li>
  <li>사용자가 언어를 선택 → <code class="language-plaintext highlighter-rouge">languageCode.didSet → setLanguage(...)</code></li>
  <li>마이크 입력 → <code class="language-plaintext highlighter-rouge">doHandleTapBlock</code> → <code class="language-plaintext highlighter-rouge">recognitionRequest.append(...)</code></li>
  <li>Apple 음성 인식기에서 처리된 결과가 <code class="language-plaintext highlighter-rouge">textString</code>에 실시간 업데이트됨</li>
  <li>뷰는 <code class="language-plaintext highlighter-rouge">ScrollView</code>를 통해 자동 스크롤하며 결과를 출력</li>
</ol>

<hr />

<h2 id="-정리">📌 정리</h2>

<table>
  <thead>
    <tr>
      <th>클래스</th>
      <th>역할</th>
      <th>핵심 기능</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">SpeechRecognitionTap</code></td>
      <td>오디오 → SpeechFramework 전달</td>
      <td>마이크 입력 버퍼를 <code class="language-plaintext highlighter-rouge">recognitionRequest</code>에 지속 전달</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">BaseTapForSpeechRecognitionConductor</code></td>
      <td>오디오 엔진 + 언어 변경 + 인식기 관리</td>
      <td>언어 변경 시 자동 재설정, 실시간 결과 처리</td>
    </tr>
  </tbody>
</table>

<hr />]]></content><author><name>ayaysir(BGSMM)</name><email>your-email@example.com</email></author><category term="StudyLog" /><category term="AudioKit" /><category term="AudioKit" /><category term="음향이론" /><summary type="html"><![CDATA[Base Tap for Speech Recognition]]></summary></entry><entry><title type="html">Tables</title><link href="/posts/Tables/" rel="alternate" type="text/html" title="Tables" /><published>2025-06-21T20:11:40+09:00</published><updated>2025-06-21T20:11:40+09:00</updated><id>/posts/Tables</id><content type="html" xml:base="/posts/Tables/"><![CDATA[<h1 id="tables">Tables</h1>

<ul>
  <li><a href="">코드 보기</a></li>
</ul>

<p>이 코드는 <code class="language-plaintext highlighter-rouge">AudioKit</code>의 <code class="language-plaintext highlighter-rouge">Table</code> 객체들을 생성하고 시각화하는 SwiftUI 뷰입니다.
특히 생성자(<code class="language-plaintext highlighter-rouge">init()</code>)에서는 다양한 방식으로 **파형 테이블(Table)**을 생성하여 오실레이터 등에서 사용할 수 있도록 준비합니다.
이 Table들은 사인파, 정사각파, 사용자 정의 파형 등의 <strong>루프 가능한 단일 사이클 웨이브폼</strong>입니다.</p>

<hr />

<h2 id="-클래스-개요-tableconductor">✅ 클래스 개요: <code class="language-plaintext highlighter-rouge">TableConductor</code></h2>

<p>이 클래스는 <code class="language-plaintext highlighter-rouge">ObservableObject</code>로, UI에서 이 객체의 <code class="language-plaintext highlighter-rouge">@Published</code> 값을 관찰할 수 있도록 구성되어 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kd">class</span> <span class="kt">TableConductor</span><span class="p">:</span> <span class="kt">ObservableObject</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="-속성-목록">📌 속성 목록</h3>

<table>
  <thead>
    <tr>
      <th>속성 이름</th>
      <th>역할</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">square</code></td>
      <td>정사각형 파형 테이블 (Square Wave)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">triangle</code></td>
      <td>삼각형 파형 테이블 (Triangle Wave)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">sine</code></td>
      <td>사인파 테이블 (Sine Wave)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">sineHarmonic</code></td>
      <td>하모닉(배음) 기반의 사인파</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">fileTable</code></td>
      <td>오디오 파일 기반 파형</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">custom</code></td>
      <td>사용자 정의 파형 (난수 + 인덱스 기반)</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-생성자-설명-init">🧠 생성자 설명: <code class="language-plaintext highlighter-rouge">init()</code></h2>

<h3 id="-1-기본-파형-테이블-생성">🔹 1. 기본 파형 테이블 생성</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="n">square</span> <span class="o">=</span> <span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="o">.</span><span class="n">square</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="mi">128</span><span class="p">)</span>
<span class="n">triangle</span> <span class="o">=</span> <span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="o">.</span><span class="n">triangle</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="mi">128</span><span class="p">)</span>
<span class="n">sine</span> <span class="o">=</span> <span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="o">.</span><span class="n">sine</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="mi">256</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.init(_:count:)</code>는 해당 파형 유형의 테이블을 지정된 크기만큼 생성</li>
  <li><code class="language-plaintext highlighter-rouge">count</code>는 <strong>테이블 길이 (샘플 수)</strong>, 2의 제곱수로 설정하는 것이 일반적 (FFT 등 성능에 영향)</li>
</ul>

<hr />

<h3 id="-2-오디오-파일-기반-파형-생성">🔹 2. 오디오 파일 기반 파형 생성</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="k">let</span> <span class="nv">url</span> <span class="o">=</span> <span class="kt">GlobalSource</span><span class="o">.</span><span class="n">piano</span><span class="o">.</span><span class="n">url</span><span class="o">!</span>
<span class="k">let</span> <span class="nv">file</span> <span class="o">=</span> <span class="k">try!</span> <span class="kt">AVAudioFile</span><span class="p">(</span><span class="nv">forReading</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span>
<span class="n">fileTable</span> <span class="o">=</span> <span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">file</span><span class="p">:</span> <span class="n">file</span><span class="p">)</span><span class="o">!</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.sfz</code> 또는 <code class="language-plaintext highlighter-rouge">.wav</code> 등의 오디오 파일을 읽어 들여 파형 테이블로 변환</li>
  <li><code class="language-plaintext highlighter-rouge">fileTable</code>은 실제 음성 데이터를 기반으로 한 루프 테이블이 됨</li>
</ul>

<p>주의:</p>
<ul>
  <li>파일 로딩은 오래 걸릴 수 있으므로 생성자에서 직접 하지 말고 <code class="language-plaintext highlighter-rouge">task</code> 등을 통해 비동기적으로 실행</li>
</ul>

<hr />

<h3 id="-3-하모닉-오버톤-기반-테이블-생성">🔹 3. 하모닉 오버톤 기반 테이블 생성</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">let</span> <span class="nv">harmonicOvertoneAmplitudes</span><span class="p">:</span> <span class="p">[</span><span class="kt">Float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
  <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.016</span><span class="p">,</span> <span class="mf">0.301</span>
<span class="p">]</span>
<span class="n">sineHarmonic</span> <span class="o">=</span> <span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="o">.</span><span class="nf">harmonic</span><span class="p">(</span><span class="n">harmonicOvertoneAmplitudes</span><span class="p">),</span> <span class="nv">phase</span><span class="p">:</span> <span class="mf">0.75</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">AudioKit.TableType.harmonic(_)</code>은 **기본파 + 배음(amplitudes)**으로 구성된 파형 생성</li>
  <li><code class="language-plaintext highlighter-rouge">harmonicOvertoneAmplitudes[n]</code>은 <strong>(n+1)번째 고조파의 세기</strong></li>
  <li><code class="language-plaintext highlighter-rouge">phase: 0.75</code>는 <strong>위상 오프셋</strong>으로, 시작 지점을 오른쪽으로 75%만큼 이동</li>
</ul>

<p>예:
배음 = <code class="language-plaintext highlighter-rouge">[0.0, 0.0, 0.016, 0.301]</code>
→ 기본파 없음, 3번째와 4번째 고조파만 있는 파형</p>

<hr />

<h3 id="-4-사용자-정의-파형-생성">🔹 4. 사용자 정의 파형 생성</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="n">custom</span> <span class="o">=</span> <span class="kt">Table</span><span class="p">(</span><span class="o">.</span><span class="n">sine</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="mi">256</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">custom</span><span class="o">.</span><span class="n">indices</span> <span class="p">{</span>
  <span class="n">custom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="kt">Float</span><span class="o">.</span><span class="nf">random</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="o">-</span><span class="mf">0.5</span><span class="o">...</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">+</span> <span class="kt">Float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2048.0</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>먼저 사인파 테이블을 생성한 뒤, 각 샘플에 <strong>무작위 값 + 인덱스 기반 값</strong>을 더함</li>
  <li>이는 <strong>잡음 성분이 섞인 사인파 또는 변형된 파형</strong>을 만들기 위한 목적</li>
</ul>

<p>예:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Float.random(in: -0.5...0.5)</code> → 랜덤 노이즈</li>
  <li><code class="language-plaintext highlighter-rouge">Float(i) / 2048.0</code> → 위치에 따라 증가하는 값</li>
</ul>

<hr />

<h2 id="️-테이블-시각화-뷰-tabledataview">🖼️ 테이블 시각화 뷰 (<code class="language-plaintext highlighter-rouge">TableDataView</code>)</h2>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kd">struct</span> <span class="kt">TableDataView</span><span class="p">:</span> <span class="kt">UIViewRepresentable</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>AudioKit에서 제공하는 <code class="language-plaintext highlighter-rouge">TableView</code>를 UIKit 기반으로 감싸 SwiftUI에서 사용 가능하게 함</li>
  <li><code class="language-plaintext highlighter-rouge">table</code>을 주입받아 <code class="language-plaintext highlighter-rouge">makeUIView</code>에서 그려줌</li>
</ul>

<hr />

<h2 id="-swiftui-구성-tablerecipeview">📱 SwiftUI 구성 (<code class="language-plaintext highlighter-rouge">TableRecipeView</code>)</h2>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="kt">VStack</span> <span class="p">{</span>
  <span class="kt">Text</span><span class="p">(</span><span class="s">"Square"</span><span class="p">)</span>
  <span class="kt">TableDataView</span><span class="p">(</span><span class="nv">table</span><span class="p">:</span> <span class="n">conductor</span><span class="o">.</span><span class="n">square</span><span class="p">)</span>
  <span class="o">...</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>각 Table을 <code class="language-plaintext highlighter-rouge">Text</code>와 함께 나열하여 시각적으로 비교 가능</li>
</ul>

<hr />

<h2 id="-요약">✅ 요약</h2>

<table>
  <thead>
    <tr>
      <th>생성 방식</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">.init(.sine, count: N)</code></td>
      <td>기본형 파형 생성</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">.init(file:)</code></td>
      <td>오디오 파일 기반 파형</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">.init(.harmonic, phase:)</code></td>
      <td>배음 기반 사용자 정의 파형</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">.init</code> + 인덱스 수식</td>
      <td>완전 커스텀 파형</td>
    </tr>
  </tbody>
</table>

<hr />]]></content><author><name>ayaysir(BGSMM)</name><email>your-email@example.com</email></author><category term="StudyLog" /><category term="AudioKit" /><category term="AudioKit" /><category term="음향이론" /><summary type="html"><![CDATA[Tables]]></summary></entry><entry><title type="html">AudioKit 예제: Callback MIDI Instrument</title><link href="/posts/CallbackMIDIInstrument/" rel="alternate" type="text/html" title="AudioKit 예제: Callback MIDI Instrument" /><published>2025-06-21T17:59:52+09:00</published><updated>2025-06-21T17:59:52+09:00</updated><id>/posts/CallbackMIDIInstrument</id><content type="html" xml:base="/posts/CallbackMIDIInstrument/"><![CDATA[<h1 id="callback-midi-instrument">Callback MIDI Instrument</h1>

<ul>
  <li><a href="https://github.com/ayaysir/Swift-Playgrounds/blob/main/AudioKit%20Cookbook%20Copy/AudioKit%20Cookbook%20Copy/Recipe/UncategorizedDemos/CallbackInstrument.swift">코드 보기</a></li>
</ul>

<p>이 코드는 <strong>AudioKit + SwiftUI</strong>를 이용해 MIDI 시퀀서 이벤트를 감지하고 사운드폰트로 소리를 재생하며, 동시에 이벤트 로그를 실시간으로 출력합니다.
핵심 개념은 다음 세 가지입니다:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">MIDICallbackInstrument</code>: MIDI 이벤트를 <strong>실시간으로 감지</strong>하여 로그 출력</li>
  <li><code class="language-plaintext highlighter-rouge">MIDISampler</code>: MIDI 노트를 <strong>실제로 재생</strong></li>
  <li><code class="language-plaintext highlighter-rouge">AppleSequencer</code>: 시간에 따라 MIDI 노트를 <strong>자동으로 발생</strong>시키는 시퀀서</li>
</ul>

<hr />

<h2 id="클래스-구성-callbackinstrumentconductor">클래스 구성: <code class="language-plaintext highlighter-rouge">CallbackInstrumentConductor</code></h2>

<h3 id="주요-변수">주요 변수</h3>

<table>
  <thead>
    <tr>
      <th>변수</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">engine</code></td>
      <td>AudioKit 오디오 엔진</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">sequencer</code></td>
      <td>AppleSequencer, 박자/템포 기반으로 노트를 자동 재생</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">callbacker</code></td>
      <td>MIDI 이벤트를 감지하기 위한 콜백 인스트루먼트</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">sampler</code></td>
      <td>사운드폰트 기반으로 소리를 출력하는 샘플러</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">tempo</code></td>
      <td>템포 (BPM)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">division</code></td>
      <td>한 마디 내 노트 수 (박자 세분화)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">text</code></td>
      <td>MIDI 이벤트 발생 로그</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="초기화-흐름">초기화 흐름</h2>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">setCallback</span><span class="p">()</span>                             <span class="c1">// 콜백 설정</span>
  <span class="k">try</span> <span class="n">sampler</span><span class="o">.</span><span class="nf">loadSoundFont</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>           <span class="c1">// 사운드폰트 로드</span>
  <span class="n">_</span> <span class="o">=</span> <span class="n">sequencer</span><span class="o">.</span><span class="nf">newTrack</span><span class="p">()</span>                 <span class="c1">// 클릭 트랙 (이벤트 감지)</span>
  <span class="n">_</span> <span class="o">=</span> <span class="n">sequencer</span><span class="o">.</span><span class="nf">newTrack</span><span class="p">(</span><span class="s">"sound"</span><span class="p">)</span>          <span class="c1">// 사운드 트랙 (소리 출력)</span>
  <span class="nf">createClickTrack</span><span class="p">()</span>                       <span class="c1">// 노트 생성</span>
  <span class="n">sequencer</span><span class="o">.</span><span class="nf">setTempo</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>                  <span class="c1">// 템포 설정</span>
  <span class="n">engine</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="n">sampler</span>                  <span class="c1">// 출력 설정</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<hr />

<h2 id="createclicktrack-실제-트랙-생성"><code class="language-plaintext highlighter-rouge">createClickTrack()</code>: 실제 트랙 생성</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">division</code> 만큼 루프를 돌면서 노트를 삽입</li>
  <li><code class="language-plaintext highlighter-rouge">clickTrack</code>: <code class="language-plaintext highlighter-rouge">callbacker</code>에게 MIDI를 보내 이벤트 로그를 남김</li>
  <li><code class="language-plaintext highlighter-rouge">soundTrack</code>: <code class="language-plaintext highlighter-rouge">sampler</code>에게 MIDI를 보내 실제 소리 재생</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="n">clickTrack</span><span class="o">.</span><span class="nf">setMIDIOutput</span><span class="p">(</span><span class="n">callbacker</span><span class="o">.</span><span class="n">midiIn</span><span class="p">)</span>
<span class="n">soundTrack</span><span class="o">.</span><span class="nf">setMIDIOutput</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">midiIn</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>노트는 아래 두 지점에 생성됩니다:</p>

<ol>
  <li><strong>첫 박자 시작 (<code class="language-plaintext highlighter-rouge">firstPosition</code>)</strong></li>
  <li><strong>중간 박자 위치 (<code class="language-plaintext highlighter-rouge">secondPosition</code>)</strong></li>
</ol>

<hr />

<h2 id="setcallback-콜백-로직"><code class="language-plaintext highlighter-rouge">setCallback()</code>: 콜백 로직</h2>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="k">self</span><span class="o">.</span><span class="n">callbacker</span> <span class="o">=</span> <span class="kt">MIDICallbackInstrument</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">.noteOn</code> 발생 시:</p>

    <ul>
      <li>현재 시퀀서 시간 (<code class="language-plaintext highlighter-rouge">self.sequencer.currentPosition.seconds</code>)과 노트 번호를 로그에 추가</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="️-swiftui-뷰-callbackinstrumentview">🖥️ SwiftUI 뷰: <code class="language-plaintext highlighter-rouge">CallbackInstrumentView</code></h2>

<h3 id="주요-ui-구성">주요 UI 구성:</h3>

<table>
  <thead>
    <tr>
      <th>UI 요소</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Play</code>, <code class="language-plaintext highlighter-rouge">Pause</code>, <code class="language-plaintext highlighter-rouge">Rewind</code></td>
      <td>시퀀서 제어</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">CookbookKnob</code></td>
      <td>템포 조절</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Slider</code></td>
      <td>division 조절</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ScrollView + Text</code></td>
      <td>콜백 로그 출력 (자동 스크롤 포함)</td>
    </tr>
  </tbody>
</table>

<h3 id="특징">특징:</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">division</code>을 변경하면 시퀀서를 멈추고 트랙을 재구성</li>
  <li>로그는 아래처럼 출력됨:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>Start Note 60 at 0.0000
Start Note 61 at 0.5000
...
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>스크롤은 <code class="language-plaintext highlighter-rouge">.scrollTo("logBottom")</code>으로 항상 아래로 유지됨</li>
</ul>

<hr />

<h2 id="preview">Preview</h2>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="cp">#Preview {</span>
  <span class="kt">CallbackInstrumentView</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Xcode의 canvas에서 인터랙티브 미리보기 지원</p>

<hr />

<h2 id="요약">요약</h2>

<table>
  <thead>
    <tr>
      <th>기능</th>
      <th>구현 방식</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>MIDI 노트 생성</td>
      <td><code class="language-plaintext highlighter-rouge">AppleSequencer</code>로 자동 반복 생성</td>
    </tr>
    <tr>
      <td>소리 재생</td>
      <td><code class="language-plaintext highlighter-rouge">MIDISampler</code> + 사운드폰트</td>
    </tr>
    <tr>
      <td>이벤트 감지</td>
      <td><code class="language-plaintext highlighter-rouge">MIDICallbackInstrument</code></td>
    </tr>
    <tr>
      <td>로그 출력</td>
      <td>SwiftUI <code class="language-plaintext highlighter-rouge">Text</code> + ScrollView</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="확장-아이디어">확장 아이디어</h2>

<ul>
  <li>각 노트에 따라 다른 소리/색상 출력</li>
  <li>외부 MIDI 입력과 연동</li>
  <li>division이나 템포 변경 시 실시간 반영</li>
  <li><code class="language-plaintext highlighter-rouge">.noteOff</code>도 감지해 note duration 분석</li>
</ul>]]></content><author><name>ayaysir(BGSMM)</name><email>your-email@example.com</email></author><category term="StudyLog" /><category term="AudioKit" /><category term="AudioKit" /><category term="음향이론" /><summary type="html"><![CDATA[Callback MIDI Instrument]]></summary></entry></feed>